{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param preprocessor - function by which each added line is modified\n * @param delay - delay after which buffer sends new data\n */\nexport const useDataBuffer = function () {\n  let preprocessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : lines => lines;\n  let delay = arguments.length > 1 ? arguments[1] : undefined;\n  const [data, setData] = useState([]);\n  const [buffer, setBuffer] = useState([]);\n  const [currentLineCount, setCurrentLineCount] = useState(0);\n  const savedTimer = useRef();\n  const inputCnts = useRef([]);\n  const currInput = useRef(0);\n  useEffect(() => {\n    savedTimer.current = setInterval(() => {\n      if (inputCnts.current.length > currInput.current) {\n        setCurrentLineCount(currentLineCount => currentLineCount + inputCnts.current[currInput.current]);\n        currInput.current += 1;\n      }\n    }, 1500);\n  }, []); // useEffect(() => {\n  //   if (data.length > buffer.length) {\n  //     savedTimer.current = setTimeout(() => {\n  //       setCurrentLineCount((currentLineCount) => currentLineCount + 5);\n  //     }, 1500);\n  //   }\n  //   return () => {\n  //     clearTimeout(savedTimer.current);\n  //   };\n  // }, [data.length, buffer.length]);\n\n  useEffect(() => {\n    if (data.length > buffer.length) setBuffer(data.slice(0, currentLineCount)); // if (currentLineCount > initLogData.length) {\n    //   clearInterval(savedTimer.current);\n    // } else {\n    //   // setLogData(initLogData.slice(0, currentLineCount));\n    //   addLines(initLogData.slice(currentLineCount - 3, currentLineCount));\n    // }\n  }, [currentLineCount]); // useEffect(() => {\n  //   setTimeout(() => {\n  //     setBuffer(data);\n  //   }, 3000);\n  // }, [data]);\n\n  const addLines = useCallback(lines => {\n    setData([...data, ...preprocessor(lines)]);\n    inputCnts.current.push(lines.length);\n  }, [data, preprocessor]);\n  return {\n    buffer,\n    addLines\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useDataBuffer","preprocessor","lines","delay","data","setData","buffer","setBuffer","currentLineCount","setCurrentLineCount","savedTimer","inputCnts","currInput","current","setInterval","length","slice","addLines","push"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/containers/useDataBuffer.ts"],"sourcesContent":["import { MutableRefObject, useCallback, useEffect, useRef, useState } from 'react';\n\ntype PreprocessorFunction = (lines: string[]) => string[];\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param preprocessor - function by which each added line is modified\n * @param delay - delay after which buffer sends new data\n */\nexport const useDataBuffer = (preprocessor: PreprocessorFunction = (lines: string[]) => lines, delay: number) => {\n  const [data, setData] = useState<string[]>([]);\n  const [buffer, setBuffer] = useState<string[]>([]);\n  const [currentLineCount, setCurrentLineCount] = useState<number>(0);\n  const savedTimer: MutableRefObject<NodeJS.Timer | undefined> = useRef();\n\n  const inputCnts = useRef<number[]>([]);\n  const currInput = useRef<number>(0);\n\n  useEffect(() => {\n    savedTimer.current = setInterval(() => {\n      if (inputCnts.current.length > currInput.current) {\n        setCurrentLineCount((currentLineCount) => currentLineCount + inputCnts.current[currInput.current]);\n        currInput.current += 1;\n      }\n    }, 1500);\n  }, []);\n\n  // useEffect(() => {\n  //   if (data.length > buffer.length) {\n  //     savedTimer.current = setTimeout(() => {\n  //       setCurrentLineCount((currentLineCount) => currentLineCount + 5);\n  //     }, 1500);\n  //   }\n  //   return () => {\n  //     clearTimeout(savedTimer.current);\n  //   };\n  // }, [data.length, buffer.length]);\n\n  useEffect(() => {\n    if (data.length > buffer.length) setBuffer(data.slice(0, currentLineCount));\n    // if (currentLineCount > initLogData.length) {\n    //   clearInterval(savedTimer.current);\n    // } else {\n    //   // setLogData(initLogData.slice(0, currentLineCount));\n    //   addLines(initLogData.slice(currentLineCount - 3, currentLineCount));\n    // }\n  }, [currentLineCount]);\n\n  // useEffect(() => {\n  //   setTimeout(() => {\n  //     setBuffer(data);\n  //   }, 3000);\n  // }, [data]);\n\n  const addLines = useCallback(\n    (lines: string[]) => {\n      setData([...data, ...preprocessor(lines)]);\n      inputCnts.current.push(lines.length);\n    },\n    [data, preprocessor]\n  );\n\n  return { buffer, addLines };\n};\n"],"mappings":"AAAA,SAA2BA,WAA3B,EAAwCC,SAAxC,EAAmDC,MAAnD,EAA2DC,QAA3D,QAA2E,OAA3E;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG,YAAoF;EAAA,IAAnFC,YAAmF,uEAA7CC,KAAD,IAAqBA,KAAyB;EAAA,IAAlBC,KAAkB;EAC/G,MAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBN,QAAQ,CAAW,EAAX,CAAhC;EACA,MAAM,CAACO,MAAD,EAASC,SAAT,IAAsBR,QAAQ,CAAW,EAAX,CAApC;EACA,MAAM,CAACS,gBAAD,EAAmBC,mBAAnB,IAA0CV,QAAQ,CAAS,CAAT,CAAxD;EACA,MAAMW,UAAsD,GAAGZ,MAAM,EAArE;EAEA,MAAMa,SAAS,GAAGb,MAAM,CAAW,EAAX,CAAxB;EACA,MAAMc,SAAS,GAAGd,MAAM,CAAS,CAAT,CAAxB;EAEAD,SAAS,CAAC,MAAM;IACda,UAAU,CAACG,OAAX,GAAqBC,WAAW,CAAC,MAAM;MACrC,IAAIH,SAAS,CAACE,OAAV,CAAkBE,MAAlB,GAA2BH,SAAS,CAACC,OAAzC,EAAkD;QAChDJ,mBAAmB,CAAED,gBAAD,IAAsBA,gBAAgB,GAAGG,SAAS,CAACE,OAAV,CAAkBD,SAAS,CAACC,OAA5B,CAA1C,CAAnB;QACAD,SAAS,CAACC,OAAV,IAAqB,CAArB;MACD;IACF,CAL+B,EAK7B,IAL6B,CAAhC;EAMD,CAPQ,EAON,EAPM,CAAT,CAT+G,CAkB/G;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEAhB,SAAS,CAAC,MAAM;IACd,IAAIO,IAAI,CAACW,MAAL,GAAcT,MAAM,CAACS,MAAzB,EAAiCR,SAAS,CAACH,IAAI,CAACY,KAAL,CAAW,CAAX,EAAcR,gBAAd,CAAD,CAAT,CADnB,CAEd;IACA;IACA;IACA;IACA;IACA;EACD,CARQ,EAQN,CAACA,gBAAD,CARM,CAAT,CA7B+G,CAuC/G;EACA;EACA;EACA;EACA;;EAEA,MAAMS,QAAQ,GAAGrB,WAAW,CACzBM,KAAD,IAAqB;IACnBG,OAAO,CAAC,CAAC,GAAGD,IAAJ,EAAU,GAAGH,YAAY,CAACC,KAAD,CAAzB,CAAD,CAAP;IACAS,SAAS,CAACE,OAAV,CAAkBK,IAAlB,CAAuBhB,KAAK,CAACa,MAA7B;EACD,CAJyB,EAK1B,CAACX,IAAD,EAAOH,YAAP,CAL0B,CAA5B;EAQA,OAAO;IAAEK,MAAF;IAAUW;EAAV,CAAP;AACD,CAtDM"},"metadata":{},"sourceType":"module"}