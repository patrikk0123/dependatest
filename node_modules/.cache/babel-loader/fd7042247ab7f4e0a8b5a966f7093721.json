{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param delay - delay after which buffer outputs new data (if any)\n * @param preprocessor - function by which each added line is modified\n */\nexport const useDataBuffer = function (delay) {\n  let preprocessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lines => lines;\n  const [dataIn, setDataIn] = useState([]);\n  const [dataOut, setDataOut] = useState([]);\n  const [currentLineCount, setCurrentLineCount] = useState(0);\n  const bufferInterval = useRef();\n  const newLinesCounts = useRef([]);\n  useEffect(() => {\n    bufferInterval.current = setInterval(() => {\n      if (newLinesCounts.current.length) {\n        setCurrentLineCount(currentLineCount => currentLineCount + newLinesCounts.current[0]);\n        newLinesCounts.current.shift();\n      }\n    }, delay);\n  }, [delay]);\n  useEffect(() => {\n    setDataOut(dataIn.slice(0, currentLineCount)); // this code has to execute only when currentLineCount changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentLineCount]); // adds new lines to the buffer\n\n  const addLines = useCallback(lines => {\n    setDataIn([...dataIn, ...preprocessor(lines)]);\n    newLinesCounts.current.push(lines.length);\n  }, [dataIn, preprocessor]);\n  return {\n    dataOut,\n    addLines\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useDataBuffer","delay","preprocessor","lines","dataIn","setDataIn","dataOut","setDataOut","currentLineCount","setCurrentLineCount","bufferInterval","newLinesCounts","current","setInterval","length","shift","slice","addLines","push"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/containers/useDataBuffer.ts"],"sourcesContent":["import { MutableRefObject, useCallback, useEffect, useRef, useState } from 'react';\n\ntype PreprocessorFunction = (lines: string[]) => string[];\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param delay - delay after which buffer outputs new data (if any)\n * @param preprocessor - function by which each added line is modified\n */\nexport const useDataBuffer = (delay: number, preprocessor: PreprocessorFunction = (lines: string[]) => lines) => {\n  const [dataIn, setDataIn] = useState<string[]>([]);\n  const [dataOut, setDataOut] = useState<string[]>([]);\n  const [currentLineCount, setCurrentLineCount] = useState<number>(0);\n\n  const bufferInterval: MutableRefObject<NodeJS.Timer | undefined> = useRef();\n\n  const newLinesCounts = useRef<number[]>([]);\n\n  useEffect(() => {\n    bufferInterval.current = setInterval(() => {\n      if (newLinesCounts.current.length) {\n        setCurrentLineCount((currentLineCount) => currentLineCount + newLinesCounts.current[0]);\n        newLinesCounts.current.shift();\n      }\n    }, delay);\n  }, [delay]);\n\n  useEffect(() => {\n    setDataOut(dataIn.slice(0, currentLineCount));\n    // this code has to execute only when currentLineCount changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentLineCount]);\n\n  // adds new lines to the buffer\n  const addLines = useCallback(\n    (lines: string[]) => {\n      setDataIn([...dataIn, ...preprocessor(lines)]);\n      newLinesCounts.current.push(lines.length);\n    },\n    [dataIn, preprocessor]\n  );\n\n  return { dataOut, addLines };\n};\n"],"mappings":"AAAA,SAA2BA,WAA3B,EAAwCC,SAAxC,EAAmDC,MAAnD,EAA2DC,QAA3D,QAA2E,OAA3E;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG,UAACC,KAAD,EAAoF;EAAA,IAApEC,YAAoE,uEAA9BC,KAAD,IAAqBA,KAAU;EAC/G,MAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAW,EAAX,CAApC;EACA,MAAM,CAACO,OAAD,EAAUC,UAAV,IAAwBR,QAAQ,CAAW,EAAX,CAAtC;EACA,MAAM,CAACS,gBAAD,EAAmBC,mBAAnB,IAA0CV,QAAQ,CAAS,CAAT,CAAxD;EAEA,MAAMW,cAA0D,GAAGZ,MAAM,EAAzE;EAEA,MAAMa,cAAc,GAAGb,MAAM,CAAW,EAAX,CAA7B;EAEAD,SAAS,CAAC,MAAM;IACda,cAAc,CAACE,OAAf,GAAyBC,WAAW,CAAC,MAAM;MACzC,IAAIF,cAAc,CAACC,OAAf,CAAuBE,MAA3B,EAAmC;QACjCL,mBAAmB,CAAED,gBAAD,IAAsBA,gBAAgB,GAAGG,cAAc,CAACC,OAAf,CAAuB,CAAvB,CAA1C,CAAnB;QACAD,cAAc,CAACC,OAAf,CAAuBG,KAAvB;MACD;IACF,CALmC,EAKjCd,KALiC,CAApC;EAMD,CAPQ,EAON,CAACA,KAAD,CAPM,CAAT;EASAJ,SAAS,CAAC,MAAM;IACdU,UAAU,CAACH,MAAM,CAACY,KAAP,CAAa,CAAb,EAAgBR,gBAAhB,CAAD,CAAV,CADc,CAEd;IACA;EACD,CAJQ,EAIN,CAACA,gBAAD,CAJM,CAAT,CAlB+G,CAwB/G;;EACA,MAAMS,QAAQ,GAAGrB,WAAW,CACzBO,KAAD,IAAqB;IACnBE,SAAS,CAAC,CAAC,GAAGD,MAAJ,EAAY,GAAGF,YAAY,CAACC,KAAD,CAA3B,CAAD,CAAT;IACAQ,cAAc,CAACC,OAAf,CAAuBM,IAAvB,CAA4Bf,KAAK,CAACW,MAAlC;EACD,CAJyB,EAK1B,CAACV,MAAD,EAASF,YAAT,CAL0B,CAA5B;EAQA,OAAO;IAAEI,OAAF;IAAWW;EAAX,CAAP;AACD,CAlCM"},"metadata":{},"sourceType":"module"}