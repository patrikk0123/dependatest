{"ast":null,"code":"import memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index, _data) => index; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nlet devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent(_ref) {\n  let {\n    getItemOffset,\n    getEstimatedTotalSize,\n    getItemSize,\n    getOffsetForIndexAndAlignment,\n    getStartIndexForOffset,\n    getStopIndexForStartIndex,\n    initInstanceProps,\n    shouldResetStyleCacheOnItemSizeChange,\n    validateProps\n  } = _ref;\n\n  var _a;\n\n  return _a = class List extends PureComponent {\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props) {\n      super(props);\n      this._instanceProps = initInstanceProps(this.props, this);\n      this._resetIsScrollingTimeoutId = null;\n      this.state = {\n        instance: this,\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof this.props.initialScrollOffset === 'number' ? this.props.initialScrollOffset : 0,\n        scrollOffsetToBottom: -1,\n        scrollUpdateWasRequested: false\n      };\n      this._callOnItemsRendered = memoizeOne((overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) => this.props.onItemsRendered({\n        overscanStartIndex,\n        overscanStopIndex,\n        visibleStartIndex,\n        visibleStopIndex\n      }));\n      this._callOnScroll = memoizeOne((scrollDirection, scrollOffset, scrollOffsetToBottom, scrollUpdateWasRequested) => this.props.onScroll({\n        scrollDirection,\n        scrollOffset,\n        scrollOffsetToBottom,\n        scrollUpdateWasRequested\n      })); // Lazily create and cache item styles while scrolling,\n      // So that pure component sCU will prevent re-renders.\n      // We maintain this cache, and pass a style prop rather than index,\n      // So that List can clear cached styles and force item re-render if necessary.\n\n      this._getItemStyle = index => {\n        const {\n          itemSize\n        } = this.props;\n\n        const itemStyleCache = this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize);\n\n        let style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          const offset = getItemOffset(this.props, index, this._instanceProps);\n          const size = getItemSize(this.props, index, this._instanceProps);\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            top: offset,\n            height: size\n          };\n        }\n\n        return style;\n      };\n\n      this._getItemStyleCache = memoizeOne(() => ({}));\n\n      this._onScrollVertical = event => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = event.currentTarget;\n        this.setState(prevState => {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          const scrollOffsetToBottom = scrollHeight - scrollTop - clientHeight;\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset,\n            scrollOffsetToBottom,\n            scrollUpdateWasRequested: false\n          };\n        }, this._resetIsScrollingDebounced);\n      };\n\n      this._outerRefSetter = ref => {\n        const {\n          outerRef\n        } = this.props;\n        this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      this._resetIsScrollingDebounced = () => {\n        if (this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(this._resetIsScrollingTimeoutId);\n        }\n\n        this._resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      this._resetIsScrolling = () => {\n        this._resetIsScrollingTimeoutId = null;\n        this.setState({\n          isScrolling: false\n        }, () => {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          this._getItemStyleCache(-1);\n        });\n      };\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index) {\n      let align = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';\n      const {\n        itemCount\n      } = this.props;\n      const {\n        scrollOffset\n      } = this.state;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    }\n\n    scrollToBottom() {\n      const outerRef = this._outerRef;\n      const {\n        scrollHeight,\n        clientHeight\n      } = outerRef;\n      this.scrollTo(scrollHeight - clientHeight);\n    }\n\n    onTextSelectionStart() {\n      if (this._outerRef) {\n        this._outerRef.style.overflowY = 'hidden';\n      }\n    }\n\n    onTextSelectionStop() {\n      if (this._outerRef) {\n        this._outerRef.style.overflowY = 'auto';\n      }\n    }\n\n    componentDidMount() {\n      const {\n        initialScrollOffset\n      } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = this._outerRef;\n        outerRef.scrollTop = initialScrollOffset;\n      }\n\n      const innerRef = this._outerRef.firstChild; // innerRef will be 'pf-c-log-viewer__list'\n\n      ['mousedown', 'touchstart'].forEach(event => {\n        innerRef.addEventListener(event, this.onTextSelectionStart.bind(this));\n      }); // set mouseup event listener on the whole document\n      // because the cursor could be out side of the log window when the mouse is up\n      // in that case the window would not be able to scroll up and down because overflow-Y is not set back to 'auto'\n\n      ['mouseup', 'touchend'].forEach(event => {\n        document.addEventListener(event, this.onTextSelectionStop.bind(this));\n      });\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const {\n        scrollOffset,\n        scrollUpdateWasRequested\n      } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = this._outerRef;\n        outerRef.scrollTop = scrollOffset;\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      const innerRef = this._outerRef.firstChild; // innerRef will be 'pf-c-log-viewer__list'\n\n      ['mousedown', 'touchstart'].forEach(event => {\n        innerRef.removeEventListener(event, this.onTextSelectionStart.bind(this));\n      });\n      ['mouseup', 'touchend'].forEach(event => {\n        document.removeEventListener(event, this.onTextSelectionStop.bind(this));\n      });\n    }\n\n    render() {\n      const {\n        children,\n        outerClassName,\n        innerClassName,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n        isTextWrapped,\n        hasLineNumbers,\n        ansiUp\n      } = this.props;\n      const {\n        isScrolling\n      } = this.state;\n      const onScroll = this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(index, itemData),\n            index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(index),\n            ansiUp\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      const estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: outerClassName,\n        onScroll,\n        ref: this._outerRefSetter,\n        tabIndex: 0,\n        style: Object.assign({\n          height,\n          paddingTop: 0,\n          paddingBottom: 0,\n          WebkitOverflowScrolling: 'touch',\n          overflowX: isTextWrapped ? 'hidden' : 'auto'\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        className: innerClassName,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalSize > height ? estimatedTotalSize : height,\n\n          /* eslint-disable-next-line no-nested-ternary */\n          width: isTextWrapped ? hasLineNumbers ? width - 65 : width : 'auto',\n          pointerEvents: isScrolling ? 'none' : undefined\n        }\n      }, items));\n    }\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const {\n          itemCount\n        } = this.props;\n\n        if (itemCount > 0) {\n          const [overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex] = this._getRangeToRender();\n\n          this._callOnItemsRendered(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollOffsetToBottom,\n          scrollUpdateWasRequested\n        } = this.state;\n\n        this._callOnScroll(scrollDirection, scrollOffset, scrollOffsetToBottom, scrollUpdateWasRequested);\n      }\n    }\n\n    _getRangeToRender() {\n      const {\n        itemCount,\n        overscanCount\n      } = this.props;\n      const {\n        isScrolling,\n        scrollDirection,\n        scrollOffset\n      } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      const stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      const overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      const overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    }\n\n  }, _a.defaultProps = {\n    itemData: undefined,\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _a;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (_ref2, _ref3) => {\n  let {\n    children,\n    innerTagName,\n    outerTagName\n  } = _ref2;\n  let {\n    instance\n  } = _ref3;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance); // eslint-disable-next-line no-console\n\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + `\"${children === null ? 'null' : typeof children}\" was specified.`);\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["memoizeOne","createElement","PureComponent","cancelTimeout","requestTimeout","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","index","_data","devWarningsTagName","process","env","NODE_ENV","window","WeakSet","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","List","constructor","props","instance","isScrolling","scrollDirection","scrollOffset","initialScrollOffset","scrollOffsetToBottom","scrollUpdateWasRequested","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","onItemsRendered","onScroll","itemSize","itemStyleCache","_getItemStyleCache","style","hasOwnProperty","offset","_instanceProps","size","position","top","height","event","clientHeight","scrollHeight","scrollTop","currentTarget","setState","prevState","Math","max","min","_resetIsScrollingDebounced","ref","outerRef","_outerRef","current","_resetIsScrollingTimeoutId","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","scrollTo","scrollToItem","align","itemCount","state","scrollToBottom","onTextSelectionStart","overflowY","onTextSelectionStop","componentDidMount","innerRef","firstChild","forEach","addEventListener","bind","document","_callPropsCallbacks","componentDidUpdate","componentWillUnmount","removeEventListener","render","children","outerClassName","innerClassName","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","width","isTextWrapped","hasLineNumbers","ansiUp","_onScrollVertical","startIndex","stopIndex","_getRangeToRender","items","push","data","key","undefined","_getItemStyle","estimatedTotalSize","className","_outerRefSetter","tabIndex","paddingTop","paddingBottom","WebkitOverflowScrolling","overflowX","pointerEvents","_callOnItemsRendered","_callOnScroll","overscanCount","overscanBackward","overscanForward","_a","has","add","console","warn","Error"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-log-viewer/src/react-window/createListComponent.ts"],"sourcesContent":["import memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\n\nimport { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\nexport interface RowProps {\n  data: any;\n  index: number;\n  isScrolling?: boolean;\n  style: React.CSSProperties;\n  ansiUp: any;\n}\n\nexport interface ListProps {\n  estimatedItemSize?: number;\n  children: React.FunctionComponent<RowProps>;\n  [key: string]: any;\n}\n\nexport interface ItemMetadata {\n  offset: number;\n  size: number;\n}\n\nexport interface InstanceProps {\n  itemMetadataMap: { [index: number]: ItemMetadata };\n  estimatedItemSize: number;\n  lastMeasuredIndex: number;\n}\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex,\n  overscanStopIndex,\n  visibleStartIndex,\n  visibleStopIndex\n}: {\n  overscanStartIndex: number;\n  overscanStopIndex: number;\n  visibleStartIndex: number;\n  visibleStopIndex: number;\n}) => void;\n\ntype ScrollEvent = React.SyntheticEvent<HTMLDivElement>;\n\nexport interface State {\n  instance: any;\n  isScrolling: boolean;\n  scrollDirection: ScrollDirection;\n  scrollOffset: number;\n  scrollOffsetToBottom: number;\n  scrollUpdateWasRequested: boolean;\n}\n\ntype GetItemOffset = (props: ListProps, index: number, instanceProps?: any) => number;\ntype GetItemSize = (props: ListProps, index?: number, instanceProps?: any) => number;\ntype GetEstimatedTotalSize = (props: ListProps, instanceProps?: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: ListProps,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps?: any\n) => number;\ntype GetStartIndexForOffset = (props: ListProps, offset: number, instanceProps?: any) => number;\ntype GetStopIndexForStartIndex = (\n  props: ListProps,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps?: InstanceProps\n) => number;\ntype InitInstanceProps = (props?: ListProps, instance?: any) => any;\ntype ValidateProps = (props: ListProps) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, _data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsTagName: WeakSet<State> = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps\n}: {\n  getItemOffset: GetItemOffset;\n  getEstimatedTotalSize: GetEstimatedTotalSize;\n  getItemSize: GetItemSize;\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment;\n  getStartIndexForOffset: GetStartIndexForOffset;\n  getStopIndexForStartIndex: GetStopIndexForStartIndex;\n  initInstanceProps: InitInstanceProps;\n  shouldResetStyleCacheOnItemSizeChange: boolean;\n  validateProps: ValidateProps;\n}) {\n  return class List extends PureComponent<ListProps, State> {\n    _instanceProps = initInstanceProps(this.props, this);\n    _outerRef?: HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      itemData: undefined as any,\n      overscanCount: 2,\n      useIsScrolling: false\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset: typeof this.props.initialScrollOffset === 'number' ? this.props.initialScrollOffset : 0,\n      scrollOffsetToBottom: -1,\n      scrollUpdateWasRequested: false\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: ListProps) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(nextProps: ListProps, prevState: State): State | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    }\n\n    scrollToBottom(): void {\n      const outerRef = this._outerRef as HTMLElement;\n      const { scrollHeight, clientHeight } = outerRef;\n\n      this.scrollTo(scrollHeight - clientHeight);\n    }\n\n    onTextSelectionStart(): void {\n      if (this._outerRef) {\n        this._outerRef.style.overflowY = 'hidden';\n      }\n    }\n\n    onTextSelectionStop(): void {\n      if (this._outerRef) {\n        this._outerRef.style.overflowY = 'auto';\n      }\n    }\n\n    componentDidMount() {\n      const { initialScrollOffset } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = this._outerRef as HTMLElement;\n        outerRef.scrollTop = initialScrollOffset;\n      }\n      const innerRef = this._outerRef.firstChild; // innerRef will be 'pf-c-log-viewer__list'\n      ['mousedown', 'touchstart'].forEach(event => {\n        innerRef.addEventListener(event, this.onTextSelectionStart.bind(this));\n      });\n      // set mouseup event listener on the whole document\n      // because the cursor could be out side of the log window when the mouse is up\n      // in that case the window would not be able to scroll up and down because overflow-Y is not set back to 'auto'\n      ['mouseup', 'touchend'].forEach(event => {\n        document.addEventListener(event, this.onTextSelectionStop.bind(this));\n      });\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = this._outerRef as HTMLElement;\n        outerRef.scrollTop = scrollOffset;\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n      const innerRef = this._outerRef.firstChild; // innerRef will be 'pf-c-log-viewer__list'\n      ['mousedown', 'touchstart'].forEach(event => {\n        innerRef.removeEventListener(event, this.onTextSelectionStart.bind(this));\n      });\n      ['mouseup', 'touchend'].forEach(event => {\n        document.removeEventListener(event, this.onTextSelectionStop.bind(this));\n      });\n    }\n\n    render() {\n      const {\n        children,\n        outerClassName,\n        innerClassName,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n        isTextWrapped,\n        hasLineNumbers,\n        ansiUp\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const onScroll = this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n              ansiUp\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className: outerClassName,\n          onScroll,\n          ref: this._outerRefSetter,\n          tabIndex: 0,\n          style: {\n            height,\n            paddingTop: 0,\n            paddingBottom: 0,\n            WebkitOverflowScrolling: 'touch',\n            overflowX: isTextWrapped ? 'hidden' : 'auto',\n            ...style\n          }\n        },\n        createElement(\n          innerElementType || innerTagName || 'div',\n          {\n            className: innerClassName,\n            ref: innerRef,\n            style: {\n              height: estimatedTotalSize > height ? estimatedTotalSize : height,\n              /* eslint-disable-next-line no-nested-ternary */\n              width: isTextWrapped ? (hasLineNumbers ? width - 65 : width) : 'auto',\n              pointerEvents: isScrolling ? 'none' : undefined\n            }\n          },\n          items\n        )\n      );\n    }\n\n    _callOnItemsRendered = memoizeOne(\n      (overscanStartIndex: number, overscanStopIndex: number, visibleStartIndex: number, visibleStopIndex: number) =>\n        (this.props.onItemsRendered as onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex\n        })\n    );\n\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollOffsetToBottom: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        this.props.onScroll({\n          scrollDirection,\n          scrollOffset,\n          scrollOffsetToBottom,\n          scrollUpdateWasRequested\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex] = this._getRangeToRender();\n          this._callOnItemsRendered(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const { scrollDirection, scrollOffset, scrollOffsetToBottom, scrollUpdateWasRequested } = this.state;\n        this._callOnScroll(scrollDirection, scrollOffset, scrollOffsetToBottom, scrollUpdateWasRequested);\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle = (index: number): Object => {\n      const { itemSize } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize);\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          top: offset,\n          height: size\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache = memoizeOne(() => ({})) as (itemSize?: any) => { [key: number]: Object };\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      const stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps);\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      const overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex\n      ];\n    }\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n\n        const scrollOffsetToBottom = scrollHeight - scrollTop - clientHeight;\n\n        return {\n          isScrolling: true,\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollOffsetToBottom,\n          scrollUpdateWasRequested: false\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ref;\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = ({ children, innerTagName, outerTagName }: ListProps, { instance }: State): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        // eslint-disable-next-line no-console\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}