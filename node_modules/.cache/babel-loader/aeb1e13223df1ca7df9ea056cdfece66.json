{"ast":null,"code":"import getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n/**\n *\n */\n\nfunction arrow(_ref) {\n  let {\n    state,\n    name\n  } = _ref;\n  const arrowElement = state.elements.arrow;\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const axis = getMainAxisFromPlacement(basePlacement);\n  const isVertical = [left, right].indexOf(basePlacement) >= 0;\n  const len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n  const arrowRect = getLayoutRect(arrowElement);\n  const minProp = axis === 'y' ? top : left;\n  const maxProp = axis === 'y' ? bottom : right;\n  const endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  const arrowOffsetParent = getOffsetParent(arrowElement);\n  const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  const min = paddingObject[minProp];\n  const max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  const offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  const axisProp = axis;\n  state.modifiersData[name] = {\n    [axisProp]: offset,\n    centerOffset: offset - center\n  };\n}\n/**\n *\n */\n\n\nfunction effect(_ref2) {\n  let {\n    state,\n    options,\n    name\n  } = _ref2;\n  let {\n    element: arrowElement = '[data-popper-arrow]',\n    padding = 0\n  } = options;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false\n  /* __DEV__*/\n  ) {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false\n    /* __DEV__*/\n    ) {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[`${name}#persistent`] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n}\n\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","map":{"version":3,"mappings":"AAEA,OAAOA,gBAAP,MAA6B,2BAA7B;AACA,OAAOC,aAAP,MAA0B,4BAA1B;AACA,OAAOC,QAAP,MAAqB,uBAArB;AACA,OAAOC,eAAP,MAA4B,8BAA5B;AACA,OAAOC,wBAAP,MAAqC,mCAArC;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,OAAOC,kBAAP,MAA+B,6BAA/B;AACA,OAAOC,eAAP,MAA4B,0BAA5B;AACA,SAASC,IAAT,EAAeC,KAAf,EAAsBC,cAAtB,EAAsCC,GAAtC,EAA2CC,MAA3C,QAAyD,UAAzD;AACA,SAASC,aAAT,QAA8B,yBAA9B;AAQA;;;;AAGA,SAASC,KAAT,OAA0D;EAAA,IAA3C;IAAEC,KAAF;IAASC;EAAT,CAA2C;EACxD,MAAMC,YAAY,GAAGF,KAAK,CAACG,QAAN,CAAeJ,KAApC;EACA,MAAMK,aAAa,GAAGJ,KAAK,CAACK,aAAN,CAAoBD,aAA1C;EACA,MAAME,aAAa,GAAGrB,gBAAgB,CAACe,KAAK,CAACO,SAAP,CAAtC;EACA,MAAMC,IAAI,GAAGnB,wBAAwB,CAACiB,aAAD,CAArC;EACA,MAAMG,UAAU,GAAG,CAAChB,IAAD,EAAOC,KAAP,EAAcgB,OAAd,CAAsBJ,aAAtB,KAAwC,CAA3D;EACA,MAAMK,GAAG,GAAGF,UAAU,GAAG,QAAH,GAAc,OAApC;;EAEA,IAAI,CAACP,YAAD,IAAiB,CAACE,aAAtB,EAAqC;IACnC;EACD;;EAED,MAAMQ,aAAa,GAAGZ,KAAK,CAACK,aAAN,CAAoB,GAAGJ,IAAI,aAA3B,EAA0CY,OAAhE;EACA,MAAMC,SAAS,GAAG5B,aAAa,CAACgB,YAAD,CAA/B;EACA,MAAMa,OAAO,GAAGP,IAAI,KAAK,GAAT,GAAeZ,GAAf,GAAqBH,IAArC;EACA,MAAMuB,OAAO,GAAGR,IAAI,KAAK,GAAT,GAAeX,MAAf,GAAwBH,KAAxC;EAEA,MAAMuB,OAAO,GACXjB,KAAK,CAACkB,KAAN,CAAYC,SAAZ,CAAsBR,GAAtB,IAA6BX,KAAK,CAACkB,KAAN,CAAYC,SAAZ,CAAsBX,IAAtB,CAA7B,GAA2DJ,aAAa,CAACI,IAAD,CAAxE,GAAiFR,KAAK,CAACkB,KAAN,CAAYE,MAAZ,CAAmBT,GAAnB,CADnF;EAEA,MAAMU,SAAS,GAAGjB,aAAa,CAACI,IAAD,CAAb,GAAsBR,KAAK,CAACkB,KAAN,CAAYC,SAAZ,CAAsBX,IAAtB,CAAxC;EAEA,MAAMc,iBAAiB,GAAGlC,eAAe,CAACc,YAAD,CAAzC;EACA,MAAMqB,UAAU,GAAGD,iBAAiB,GAChCd,IAAI,KAAK,GAAT,GACEc,iBAAiB,CAACE,YAAlB,IAAkC,CADpC,GAEEF,iBAAiB,CAACG,WAAlB,IAAiC,CAHH,GAIhC,CAJJ;EAMA,MAAMC,iBAAiB,GAAGT,OAAO,GAAG,CAAV,GAAcI,SAAS,GAAG,CAApD,CA5BwD,CA8BxD;EACA;;EACA,MAAMM,GAAG,GAAGf,aAAa,CAACG,OAAD,CAAzB;EACA,MAAMa,GAAG,GAAGL,UAAU,GAAGT,SAAS,CAACH,GAAD,CAAtB,GAA8BC,aAAa,CAACI,OAAD,CAAvD;EACA,MAAMa,MAAM,GAAGN,UAAU,GAAG,CAAb,GAAiBT,SAAS,CAACH,GAAD,CAAT,GAAiB,CAAlC,GAAsCe,iBAArD;EACA,MAAMI,MAAM,GAAGxC,MAAM,CAACqC,GAAD,EAAME,MAAN,EAAcD,GAAd,CAArB,CAnCwD,CAqCxD;;EACA,MAAMG,QAAQ,GAAWvB,IAAzB;EACAR,KAAK,CAACK,aAAN,CAAoBJ,IAApB,IAA4B;IAC1B,CAAC8B,QAAD,GAAYD,MADc;IAE1BE,YAAY,EAAEF,MAAM,GAAGD;EAFG,CAA5B;AAID;AAED;;;;;AAGA,SAASI,MAAT,QAAoE;EAAA,IAApD;IAAEjC,KAAF;IAASkC,OAAT;IAAkBjC;EAAlB,CAAoD;EAClE,IAAI;IAAEkC,OAAO,EAAEjC,YAAY,GAAG,qBAA1B;IAAiDW,OAAO,GAAG;EAA3D,IAAiEqB,OAArE;;EAEA,IAAIhC,YAAY,IAAI,IAApB,EAA0B;IACxB;EACD,CALiE,CAOlE;;;EACA,IAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;IACpCA,YAAY,GAAGF,KAAK,CAACG,QAAN,CAAeiB,MAAf,CAAsBgB,aAAtB,CAAoClC,YAApC,CAAf;;IAEA,IAAI,CAACA,YAAL,EAAmB;MACjB;IACD;EACF;;EAED,IAAI;EAAM;EAAV,EAAwB;IACtB,IAAI,CAACJ,aAAa,CAACI,YAAD,CAAlB,EAAkC;MAChCmC,OAAO,CAACC,KAAR,CACE,CACE,qEADF,EAEE,qEAFF,EAGE,YAHF,EAIEC,IAJF,CAIO,GAJP,CADF;IAOD;EACF;;EAED,IAAI,CAACpD,QAAQ,CAACa,KAAK,CAACG,QAAN,CAAeiB,MAAhB,EAAwBlB,YAAxB,CAAb,EAAoD;IAClD,IAAI;IAAM;IAAV,EAAwB;MACtBmC,OAAO,CAACC,KAAR,CAAc,CAAC,qEAAD,EAAwE,UAAxE,EAAoFC,IAApF,CAAyF,GAAzF,CAAd;IACD;;IAED;EACD;;EAEDvC,KAAK,CAACG,QAAN,CAAeJ,KAAf,GAAuBG,YAAvB;EACAF,KAAK,CAACK,aAAN,CAAoB,GAAGJ,IAAI,aAA3B,IAA4C;IAC1CY,OAAO,EAAEtB,kBAAkB,CAAC,OAAOsB,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwCrB,eAAe,CAACqB,OAAD,EAAUlB,cAAV,CAAxD;EADe,CAA5C;AAGD;;AAID,eAAe;EACbM,IAAI,EAAE,OADO;EAEbuC,OAAO,EAAE,IAFI;EAGbC,KAAK,EAAE,MAHM;EAIbC,EAAE,EAAE3C,KAJS;EAKbkC,MALa;EAMbU,QAAQ,EAAE,CAAC,eAAD,CANG;EAObC,gBAAgB,EAAE,CAAC,iBAAD;AAPL,CAAf","names":["getBasePlacement","getLayoutRect","contains","getOffsetParent","getMainAxisFromPlacement","within","mergePaddingObject","expandToHashMap","left","right","basePlacements","top","bottom","isHTMLElement","arrow","state","name","arrowElement","elements","popperOffsets","modifiersData","basePlacement","placement","axis","isVertical","indexOf","len","paddingObject","padding","arrowRect","minProp","maxProp","endDiff","rects","reference","popper","startDiff","arrowOffsetParent","clientSize","clientHeight","clientWidth","centerToReference","min","max","center","offset","axisProp","centerOffset","effect","options","element","querySelector","console","error","join","enabled","phase","fn","requires","requiresIfExists"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/arrow.ts"],"sourcesContent":["// @ts-nocheck\nimport { Modifier, ModifierArguments, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  element: HTMLElement | string | null;\n  padding: Padding;\n}\n\n/**\n *\n */\nfunction arrow({ state, name }: ModifierArguments<Options>) {\n  const arrowElement = state.elements.arrow;\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const axis = getMainAxisFromPlacement(basePlacement);\n  const isVertical = [left, right].indexOf(basePlacement) >= 0;\n  const len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n  const arrowRect = getLayoutRect(arrowElement);\n  const minProp = axis === 'y' ? top : left;\n  const maxProp = axis === 'y' ? bottom : right;\n\n  const endDiff =\n    state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n\n  const arrowOffsetParent = getOffsetParent(arrowElement);\n  const clientSize = arrowOffsetParent\n    ? axis === 'y'\n      ? arrowOffsetParent.clientHeight || 0\n      : arrowOffsetParent.clientWidth || 0\n    : 0;\n\n  const centerToReference = endDiff / 2 - startDiff / 2;\n\n  // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n  const min = paddingObject[minProp];\n  const max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  const offset = within(min, center, max);\n\n  // Prevents breaking syntax highlighting...\n  const axisProp: string = axis;\n  state.modifiersData[name] = {\n    [axisProp]: offset,\n    centerOffset: offset - center\n  };\n}\n\n/**\n *\n */\nfunction effect({ state, options, name }: ModifierArguments<Options>) {\n  let { element: arrowElement = '[data-popper-arrow]', padding = 0 } = options;\n\n  if (arrowElement == null) {\n    return;\n  }\n\n  // CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false /* __DEV__*/) {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(\n        [\n          'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n          'To use an SVG arrow, wrap it in an HTMLElement that will be used as',\n          'the arrow.'\n        ].join(' ')\n      );\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false /* __DEV__*/) {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[`${name}#persistent`] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type ArrowModifier = Modifier<'arrow', Options>;\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n} as ArrowModifier;\n"]},"metadata":{},"sourceType":"module"}