{"ast":null,"code":"import { top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getComputedStyle from '../dom-utils/getComputedStyle';\nimport getBasePlacement from '../utils/getBasePlacement';\nconst unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\n/**\n *\n */\n\nfunction roundOffsets(_ref) {\n  let {\n    x,\n    y\n  } = _ref;\n  const win = window;\n  const dpr = win.devicePixelRatio || 1;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n/**\n *\n */\n\n\nexport function mapToStyles(_ref2) {\n  let {\n    popper,\n    popperRect,\n    placement,\n    offsets,\n    position,\n    gpuAcceleration,\n    adaptive\n  } = _ref2;\n  let {\n    x,\n    y\n  } = roundOffsets(offsets);\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n  let sideX = left;\n  let sideY = top;\n  const win = window;\n\n  if (adaptive) {\n    let offsetParent = getOffsetParent(popper);\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /* :: offsetParent = (offsetParent: Element); */\n\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  const commonStyles = Object.assign({\n    position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    return Object.assign(Object.assign({}, commonStyles), {\n      [sideY]: hasY ? '0' : '',\n      [sideX]: hasX ? '0' : '',\n      // Layer acceleration can disable subpixel rendering which causes slightly\n      // blurry text on low PPI displays, so we want to use 2D transforms\n      // instead\n      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`\n    });\n  }\n\n  return Object.assign(Object.assign({}, commonStyles), {\n    [sideY]: hasY ? `${y}px` : '',\n    [sideX]: hasX ? `${x}px` : '',\n    transform: ''\n  });\n}\n/**\n *\n */\n\nfunction computeStyles(_ref3) {\n  let {\n    state,\n    options\n  } = _ref3;\n  const {\n    gpuAcceleration = true,\n    adaptive = true\n  } = options;\n\n  if (false\n  /* __DEV__*/\n  ) {\n    const transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(property => transitionProperty.indexOf(property) >= 0)) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  const commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false\n    })));\n  }\n\n  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {\n    'data-popper-placement': state.placement\n  });\n}\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","map":{"version":3,"mappings":"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","names":["top","left","right","bottom","getOffsetParent","getWindow","getDocumentElement","getComputedStyle","getBasePlacement","unsetSides","roundOffsets","x","y","win","window","dpr","devicePixelRatio","Math","round","mapToStyles","popper","popperRect","placement","offsets","position","gpuAcceleration","adaptive","hasX","hasOwnProperty","hasY","sideX","sideY","offsetParent","clientHeight","height","clientWidth","width","commonStyles","transform","computeStyles","state","options","transitionProperty","elements","some","property","indexOf","console","warn","join","rects","modifiersData","popperOffsets","styles","Object","strategy","arrow","attributes","name","enabled","phase","fn","data"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/computeStyles.ts"],"sourcesContent":["// @ts-nocheck\nimport { PositioningStrategy, Offsets, Modifier, ModifierArguments, Rect, Window } from '../types';\nimport { BasePlacement, top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getComputedStyle from '../dom-utils/getComputedStyle';\nimport getBasePlacement from '../utils/getBasePlacement';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  gpuAcceleration: boolean;\n  adaptive: boolean;\n}\n\nconst unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n};\n\n// Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n/**\n *\n */\nfunction roundOffsets({ x, y }): Offsets {\n  const win: Window = window;\n  const dpr = win.devicePixelRatio || 1;\n\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n\n/**\n *\n */\nexport function mapToStyles({\n  popper,\n  popperRect,\n  placement,\n  offsets,\n  position,\n  gpuAcceleration,\n  adaptive\n}: {\n  popper: HTMLElement;\n  popperRect: Rect;\n  placement: BasePlacement;\n  offsets: Partial<{ x: number; y: number; centerOffset: number }>;\n  position: PositioningStrategy;\n  gpuAcceleration: boolean;\n  adaptive: boolean;\n}) {\n  let { x, y } = roundOffsets(offsets);\n\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n\n  let sideX: string = left;\n  let sideY: string = top;\n\n  const win: Window = window;\n\n  if (adaptive) {\n    let offsetParent = getOffsetParent(popper);\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    }\n\n    // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /* :: offsetParent = (offsetParent: Element); */\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  const commonStyles = {\n    position,\n    ...(adaptive && unsetSides)\n  };\n\n  if (gpuAcceleration) {\n    return {\n      ...commonStyles,\n      [sideY]: hasY ? '0' : '',\n      [sideX]: hasX ? '0' : '',\n      // Layer acceleration can disable subpixel rendering which causes slightly\n      // blurry text on low PPI displays, so we want to use 2D transforms\n      // instead\n      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`\n    };\n  }\n\n  return {\n    ...commonStyles,\n    [sideY]: hasY ? `${y}px` : '',\n    [sideX]: hasX ? `${x}px` : '',\n    transform: ''\n  };\n}\n\n/**\n *\n */\nfunction computeStyles({ state, options }: ModifierArguments<Options>) {\n  const { gpuAcceleration = true, adaptive = true } = options;\n\n  if (false /* __DEV__*/) {\n    const transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n\n    if (\n      adaptive &&\n      ['transform', 'top', 'right', 'bottom', 'left'].some(property => transitionProperty.indexOf(property) >= 0)\n    ) {\n      console.warn(\n        [\n          'Popper: Detected CSS transitions on at least one of the following',\n          'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',\n          '\\n\\n',\n          'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\n          'for smooth transitions, or remove these properties from the CSS',\n          'transition declaration on the popper element if only transitioning',\n          'opacity or background-color for example.',\n          '\\n\\n',\n          'We recommend using the popper element as a wrapper around an inner',\n          'element that can have any CSS property transitioned for animations.'\n        ].join(' ')\n      );\n    }\n  }\n\n  const commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = {\n      ...state.styles.popper,\n      ...mapToStyles({\n        ...commonStyles,\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive\n      })\n    };\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = {\n      ...state.styles.arrow,\n      ...mapToStyles({\n        ...commonStyles,\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false\n      })\n    };\n  }\n\n  state.attributes.popper = {\n    ...state.attributes.popper,\n    'data-popper-placement': state.placement\n  };\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type ComputeStylesModifier = Modifier<'computeStyles', Options>;\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n} as ComputeStylesModifier;\n"]},"metadata":{},"sourceType":"module"}