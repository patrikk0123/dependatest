{"ast":null,"code":"import * as WebConfigAPI from '../services/WebConfigService';\nimport { Keycloak } from '../services/keycloakHolder';\n/**\n * Enum with possible authentication roles in keycloak.\n *\n */\n\nexport let AUTH_ROLE;\n/**\n * Class managing authentication functionality.\n */\n\n(function (AUTH_ROLE) {\n  AUTH_ROLE[\"Admin\"] = \"admin\";\n  AUTH_ROLE[\"User\"] = \"user\";\n  AUTH_ROLE[\"System\"] = \"system-user\";\n  AUTH_ROLE[\"Power\"] = \"power-user\";\n})(AUTH_ROLE || (AUTH_ROLE = {}));\n\nclass KeycloakService {\n  //We can't get KeycloakInstance type because of dynamic loading of keycloak library\n  // Default: 24 Hours\n  // false if keycloak could not be loaded / initialized\n  constructor() {\n    this.keycloakAuth = void 0;\n    this.KEYCLOAK_TOKEN_MIN_EXP = 86400;\n    this.isKeycloakInitialized = void 0;\n    this._isKeycloakAvailable = false;\n    this.isKeycloakInitialized = this.init();\n  }\n\n  get isKeycloakAvailable() {\n    return this._isKeycloakAvailable;\n  }\n  /**\n   * Initialize keycloak and create instance.\n   *\n   * @returns Promise\n   */\n\n\n  init() {\n    const keycloakConfig = WebConfigAPI.getWebConfig().keycloak;\n    console.log(window.Keycloak);\n\n    if (keycloakConfig) {\n      this.keycloakAuth = new Keycloak({\n        url: keycloakConfig.url,\n        realm: keycloakConfig.realm,\n        clientId: keycloakConfig.clientId\n      });\n      return new Promise((resolve, reject) => {\n        this.keycloakAuth.init({\n          onLoad: 'check-sso'\n        }).then(() => {\n          this._isKeycloakAvailable = true;\n          resolve('success');\n        }).catch(errorData => {\n          reject(errorData);\n        });\n      });\n    } else {\n      return Promise.reject('Keycloak library not available');\n    }\n  }\n  /**\n   * Returns promise of keycloak initialization.\n   *\n   * @returns Promise\n   */\n\n\n  isInitialized() {\n    return this.isKeycloakInitialized;\n  }\n  /**\n   * Returns if user is authenticated.\n   *\n   * @returns true if user is authenticated, otherwise returns false.\n   */\n\n\n  isAuthenticated() {\n    return this.keycloakAuth.authenticated;\n  }\n  /**\n   * Initiate login process in keycloak.\n   *\n   * @returns Promise\n   */\n\n\n  login() {\n    return this.keycloakAuth.login();\n  }\n  /**\n   * Initiate logout process in keycloak.\n   *\n   * @param redirectUri - uri to redirect after logout\n   */\n\n\n  logout(redirectUri) {\n    this.keycloakAuth.logout({\n      redirectUri\n    });\n  }\n  /**\n   * Gets keycloak token.\n   *\n   * @returns String with token if user is logged in or returns undefined when not.\n   */\n\n\n  getToken() {\n    this.updateToken().then(isTokenRefreshed => {\n      if (isTokenRefreshed) {\n        console.log('Token refreshed.');\n      } else {//console.log('Token not refreshed, valid for: \\n' + this.getTokenValidity()); //dev purpose, too much spam\n      }\n    }).catch(() => {\n      throw new Error('Failed to refresh token');\n    });\n    return this.keycloakAuth.token;\n  }\n\n  getTokenValidity() {\n    if (!this.keycloakAuth.tokenParsed) {\n      return 'Not authenticated';\n    }\n\n    let validity = 'Token Expires:\\t\\t' + new Date((this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() + '\\n';\n    validity += 'Token Expires in:\\t' + Math.round(this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) + ' seconds\\n';\n\n    if (this.keycloakAuth.refreshTokenParsed) {\n      validity += 'Refresh Token Expires:\\t' + new Date((this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() + '\\n';\n      validity += 'Refresh Expires in:\\t' + Math.round(this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) + ' seconds';\n    }\n\n    return validity;\n  }\n\n  isTokenExpired() {\n    return this.keycloakAuth.isTokenExpired(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n\n  updateToken() {\n    return this.keycloakAuth.updateToken(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n  /**\n   * Gets user name from keycloak.\n   *\n   * @returns String with username if user is logged in or returns undefined when not.\n   */\n\n\n  getUser() {\n    var _this$keycloakAuth$id;\n\n    return (_this$keycloakAuth$id = this.keycloakAuth.idTokenParsed) === null || _this$keycloakAuth$id === void 0 ? void 0 : _this$keycloakAuth$id.preferred_username;\n  }\n  /**\n   * Checks if user has required auth role.\n   *\n   * @param role AUTH_ROLE\n   * @returns true when user is logged in and has required role for access, otherwise return false.\n   */\n\n\n  hasRealmRole(role) {\n    return this.keycloakAuth.hasRealmRole(role);\n  }\n\n}\n/**\n * Instance of KeycloakService providing group of Keycloak related API operations.\n */\n\n\nexport const keycloakService = new KeycloakService();","map":{"version":3,"names":["WebConfigAPI","Keycloak","AUTH_ROLE","KeycloakService","constructor","keycloakAuth","KEYCLOAK_TOKEN_MIN_EXP","isKeycloakInitialized","_isKeycloakAvailable","init","isKeycloakAvailable","keycloakConfig","getWebConfig","keycloak","console","log","window","url","realm","clientId","Promise","resolve","reject","onLoad","then","catch","errorData","isInitialized","isAuthenticated","authenticated","login","logout","redirectUri","getToken","updateToken","isTokenRefreshed","Error","token","getTokenValidity","tokenParsed","validity","Date","exp","timeSkew","toLocaleString","Math","round","getTime","refreshTokenParsed","isTokenExpired","getUser","idTokenParsed","preferred_username","hasRealmRole","role","keycloakService"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/services/keycloakService.ts"],"sourcesContent":["import * as WebConfigAPI from '../services/WebConfigService';\nimport { Keycloak } from '../services/keycloakHolder';\n\n/**\n * Enum with possible authentication roles in keycloak.\n *\n */\nexport enum AUTH_ROLE {\n  Admin = 'admin',\n  User = 'user',\n  System = 'system-user',\n  Power = 'power-user',\n}\n\n/**\n * Class managing authentication functionality.\n */\nclass KeycloakService {\n  //We can't get KeycloakInstance type because of dynamic loading of keycloak library\n  private keycloakAuth: any;\n\n  private KEYCLOAK_TOKEN_MIN_EXP = 86400; // Default: 24 Hours\n\n  private isKeycloakInitialized;\n\n  // false if keycloak could not be loaded / initialized\n  private _isKeycloakAvailable: boolean = false;\n\n  constructor() {\n    this.isKeycloakInitialized = this.init();\n  }\n\n  public get isKeycloakAvailable(): boolean {\n    return this._isKeycloakAvailable;\n  }\n\n  /**\n   * Initialize keycloak and create instance.\n   *\n   * @returns Promise\n   */\n  private init(): Promise<any> {\n    const keycloakConfig = WebConfigAPI.getWebConfig().keycloak;\n    console.log(window.Keycloak);\n\n    if (keycloakConfig) {\n      this.keycloakAuth = new Keycloak({\n        url: keycloakConfig.url,\n        realm: keycloakConfig.realm,\n        clientId: keycloakConfig.clientId,\n      });\n\n      return new Promise((resolve, reject) => {\n        this.keycloakAuth\n          .init({ onLoad: 'check-sso' })\n          .then(() => {\n            this._isKeycloakAvailable = true;\n            resolve('success');\n          })\n          .catch((errorData: any) => {\n            reject(errorData);\n          });\n      });\n    } else {\n      return Promise.reject('Keycloak library not available');\n    }\n  }\n  /**\n   * Returns promise of keycloak initialization.\n   *\n   * @returns Promise\n   */\n  public isInitialized(): Promise<any> {\n    return this.isKeycloakInitialized;\n  }\n  /**\n   * Returns if user is authenticated.\n   *\n   * @returns true if user is authenticated, otherwise returns false.\n   */\n  public isAuthenticated(): boolean {\n    return this.keycloakAuth.authenticated!;\n  }\n\n  /**\n   * Initiate login process in keycloak.\n   *\n   * @returns Promise\n   */\n  public login(): Promise<any> {\n    return this.keycloakAuth.login();\n  }\n\n  /**\n   * Initiate logout process in keycloak.\n   *\n   * @param redirectUri - uri to redirect after logout\n   */\n  public logout(redirectUri?: String): void {\n    this.keycloakAuth.logout({ redirectUri });\n  }\n\n  /**\n   * Gets keycloak token.\n   *\n   * @returns String with token if user is logged in or returns undefined when not.\n   */\n  public getToken(): String {\n    this.updateToken()\n      .then((isTokenRefreshed: boolean) => {\n        if (isTokenRefreshed) {\n          console.log('Token refreshed.');\n        } else {\n          //console.log('Token not refreshed, valid for: \\n' + this.getTokenValidity()); //dev purpose, too much spam\n        }\n      })\n      .catch(() => {\n        throw new Error('Failed to refresh token');\n      });\n\n    return this.keycloakAuth.token;\n  }\n\n  public getTokenValidity(): String {\n    if (!this.keycloakAuth.tokenParsed) {\n      return 'Not authenticated';\n    }\n\n    let validity =\n      'Token Expires:\\t\\t' +\n      new Date((this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() +\n      '\\n';\n    validity +=\n      'Token Expires in:\\t' +\n      Math.round(this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) +\n      ' seconds\\n';\n\n    if (this.keycloakAuth.refreshTokenParsed) {\n      validity +=\n        'Refresh Token Expires:\\t' +\n        new Date((this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() +\n        '\\n';\n      validity +=\n        'Refresh Expires in:\\t' +\n        Math.round(this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) +\n        ' seconds';\n    }\n\n    return validity;\n  }\n\n  public isTokenExpired(): boolean {\n    return this.keycloakAuth.isTokenExpired(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n\n  public updateToken(): Promise<boolean> {\n    return this.keycloakAuth.updateToken(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n\n  /**\n   * Gets user name from keycloak.\n   *\n   * @returns String with username if user is logged in or returns undefined when not.\n   */\n  public getUser(): String {\n    return this.keycloakAuth.idTokenParsed?.preferred_username;\n  }\n\n  /**\n   * Checks if user has required auth role.\n   *\n   * @param role AUTH_ROLE\n   * @returns true when user is logged in and has required role for access, otherwise return false.\n   */\n  public hasRealmRole(role: AUTH_ROLE): boolean {\n    return this.keycloakAuth.hasRealmRole(role);\n  }\n}\n/**\n * Instance of KeycloakService providing group of Keycloak related API operations.\n */\nexport const keycloakService = new KeycloakService();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}