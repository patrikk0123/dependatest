{"ast":null,"code":"export const amSuffix = ' AM';\nexport const pmSuffix = ' PM';\nexport const makeTimeOptions = (stepMinutes, hour12, delimiter, minTime, maxTime, includeSeconds) => {\n  const res = [];\n  const iter = new Date(new Date().setHours(0, 0, 0, 0));\n  const iterDay = iter.getDay();\n\n  while (iter.getDay() === iterDay) {\n    let hour = iter.getHours();\n    let suffix = amSuffix;\n\n    if (hour12) {\n      if (hour === 0) {\n        hour = 12; // 12am\n      } else if (hour >= 12) {\n        suffix = pmSuffix;\n      }\n\n      if (hour > 12) {\n        hour %= 12;\n      }\n    }\n\n    hour = hour12 ? hour.toString() : hour.toString().padStart(2, '0');\n    const minutes = iter.getMinutes().toString().padStart(2, '0');\n    const timeOption = `${hour}${delimiter}${minutes}${hour12 ? suffix : ''}`; // time option is valid if within min/max constraints\n\n    if (isWithinMinMax(minTime, maxTime, timeOption, delimiter, includeSeconds)) {\n      res.push(timeOption);\n    }\n\n    iter.setMinutes(iter.getMinutes() + stepMinutes);\n  }\n\n  return res;\n};\nexport const parseTime = (time, timeRegex, delimiter, is12Hour, includeSeconds) => {\n  const date = new Date(time); // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n\n  if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n    const hours = is12Hour ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}` : `${date.getHours()}`.padStart(2, '0');\n    const minutes = `${date.getMinutes()}`.padStart(2, '0');\n    const seconds = includeSeconds ? `${date.getSeconds()}`.padStart(2, '0') : '';\n    const secondsWithDelimiter = seconds ? `${delimiter}${seconds}` : '';\n    let ampm = '';\n\n    if (is12Hour && date.getHours() > 11) {\n      ampm = pmSuffix;\n    } else if (is12Hour) {\n      ampm = amSuffix;\n    }\n\n    return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n  } else if (typeof time === 'string') {\n    time = time.trim();\n\n    if (time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n      const [, hours, minutes, seconds, suffix = ''] = timeRegex.exec(time);\n      const secondsWithDelimiter = includeSeconds ? `${delimiter}${seconds !== null && seconds !== void 0 ? seconds : '00'}` : '';\n      let ampm = ''; // Format AM/PM according to design\n\n      if (is12Hour) {\n        const uppercaseSuffix = suffix.toUpperCase();\n\n        if (uppercaseSuffix === amSuffix.toUpperCase().trim()) {\n          ampm = amSuffix;\n        } else if (uppercaseSuffix === pmSuffix.toUpperCase().trim()) {\n          ampm = pmSuffix;\n        } else {\n          // if this 12 hour time is missing am/pm but otherwise valid,\n          // append am/pm depending on time of day\n          ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n        }\n      }\n\n      return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n    }\n  }\n\n  return time.toString();\n};\nexport const validateTime = (time, timeRegex, delimiter, is12Hour) => {\n  // ISO 8601 format is valid\n  const date = new Date(time);\n\n  if (!isNaN(date.getDate()) && time.includes('T')) {\n    return true;\n  } // hours only valid if they are [0-23] or [1-12]\n\n\n  const hours = parseInt(time.split(delimiter)[0]);\n  const validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23); // minutes verified by timeRegex\n  // empty string is valid\n\n  return time === '' || timeRegex.test(time) && validHours;\n};\nexport const getHours = (time, timeRegex) => {\n  const parts = time.match(timeRegex);\n\n  if (parts && parts.length) {\n    if (/pm/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n    }\n\n    if (/am/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);\n    }\n\n    return parseInt(parts[1]);\n  }\n\n  return null;\n};\nexport const getMinutes = (time, timeRegex) => {\n  const parts = time.match(timeRegex);\n  return parts && parts.length ? parseInt(parts[2]) : null;\n};\nexport const getSeconds = (time, timeRegex) => {\n  var _a;\n\n  const seconds = (_a = time.match(timeRegex)) === null || _a === void 0 ? void 0 : _a[3];\n  return seconds ? parseInt(seconds) : null;\n};\nexport const isWithinMinMax = (minTime, maxTime, time, delimiter, includeSeconds) => {\n  // do not throw error if empty string\n  if (time.trim() === '') {\n    return true;\n  } // correctly format as 24hr times (12:30AM => 00:30, 1:15 => 01:15)\n\n\n  const min24HourTime = convertTo24Hour(minTime, delimiter, includeSeconds);\n  const selected24HourTime = convertTo24Hour(time, delimiter, includeSeconds);\n  const max24HourTime = convertTo24Hour(maxTime, delimiter, includeSeconds); // simple string comparison for 24hr times\n\n  return min24HourTime <= selected24HourTime && selected24HourTime <= max24HourTime;\n};\n\nconst convertTo24Hour = (time, delimiter, includeSeconds) => {\n  const timeReg = new RegExp(`^\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)${delimiter}?([0-5]\\\\d)?\\\\s*([AaPp][Mm])?\\\\s*$`);\n  const regMatches = timeReg.exec(time);\n\n  if (!regMatches || !regMatches.length) {\n    return;\n  }\n\n  let hours = regMatches[1].padStart(2, '0');\n  const minutes = regMatches[2];\n  let seconds = regMatches[3] ? `${delimiter}${regMatches[3]}` : ''; // When seconds is empty and 'includeSeconds' is enabled, append 0 seconds.\n\n  if (!seconds && includeSeconds) {\n    seconds = `${delimiter}00`;\n  }\n\n  const suffix = regMatches[4] || '';\n\n  if (suffix.toUpperCase() === 'PM' && hours !== '12') {\n    hours = `${parseInt(hours) + 12}`;\n  } else if (suffix.toUpperCase() === 'AM' && hours === '12') {\n    hours = '00';\n  }\n\n  return `${hours}${delimiter}${minutes}${seconds}`;\n};","map":{"version":3,"mappings":"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","names":["amSuffix","pmSuffix","makeTimeOptions","stepMinutes","hour12","delimiter","minTime","maxTime","includeSeconds","res","iter","Date","setHours","iterDay","getDay","hour","getHours","suffix","toString","padStart","minutes","getMinutes","timeOption","isWithinMinMax","push","setMinutes","parseTime","time","timeRegex","is12Hour","date","isNaN","getDate","includes","hours","seconds","getSeconds","secondsWithDelimiter","ampm","trim","validateTime","exec","uppercaseSuffix","toUpperCase","parseInt","split","validHours","test","parts","match","length","_a","min24HourTime","convertTo24Hour","selected24HourTime","max24HourTime","timeReg","RegExp","regMatches"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/components/TimePicker/TimePickerUtils.tsx"],"sourcesContent":["export const amSuffix = ' AM';\nexport const pmSuffix = ' PM';\n\nexport const makeTimeOptions = (\n  stepMinutes: number,\n  hour12: boolean,\n  delimiter: string,\n  minTime: string,\n  maxTime: string,\n  includeSeconds: boolean\n) => {\n  const res = [];\n  const iter = new Date(new Date().setHours(0, 0, 0, 0));\n  const iterDay = iter.getDay();\n  while (iter.getDay() === iterDay) {\n    let hour: string | number = iter.getHours();\n    let suffix = amSuffix;\n    if (hour12) {\n      if (hour === 0) {\n        hour = 12; // 12am\n      } else if (hour >= 12) {\n        suffix = pmSuffix;\n      }\n      if (hour > 12) {\n        hour %= 12;\n      }\n    }\n    hour = hour12 ? hour.toString() : hour.toString().padStart(2, '0');\n    const minutes = iter\n      .getMinutes()\n      .toString()\n      .padStart(2, '0');\n    const timeOption = `${hour}${delimiter}${minutes}${hour12 ? suffix : ''}`;\n    // time option is valid if within min/max constraints\n    if (isWithinMinMax(minTime, maxTime, timeOption, delimiter, includeSeconds)) {\n      res.push(timeOption);\n    }\n    iter.setMinutes(iter.getMinutes() + stepMinutes);\n  }\n  return res;\n};\n\nexport const parseTime = (\n  time: string | Date,\n  timeRegex: RegExp,\n  delimiter: string,\n  is12Hour: boolean,\n  includeSeconds: boolean\n): string => {\n  const date = new Date(time);\n\n  // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n  if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n    const hours = is12Hour\n      ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}`\n      : `${date.getHours()}`.padStart(2, '0');\n    const minutes = `${date.getMinutes()}`.padStart(2, '0');\n    const seconds = includeSeconds ? `${date.getSeconds()}`.padStart(2, '0') : '';\n    const secondsWithDelimiter = seconds ? `${delimiter}${seconds}` : '';\n    let ampm = '';\n\n    if (is12Hour && date.getHours() > 11) {\n      ampm = pmSuffix;\n    } else if (is12Hour) {\n      ampm = amSuffix;\n    }\n\n    return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n  } else if (typeof time === 'string') {\n    time = time.trim();\n    if (time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n      const [, hours, minutes, seconds, suffix = ''] = timeRegex.exec(time);\n      const secondsWithDelimiter = includeSeconds ? `${delimiter}${seconds ?? '00'}` : '';\n      let ampm = '';\n\n      // Format AM/PM according to design\n      if (is12Hour) {\n        const uppercaseSuffix = suffix.toUpperCase();\n\n        if (uppercaseSuffix === amSuffix.toUpperCase().trim()) {\n          ampm = amSuffix;\n        } else if (uppercaseSuffix === pmSuffix.toUpperCase().trim()) {\n          ampm = pmSuffix;\n        } else {\n          // if this 12 hour time is missing am/pm but otherwise valid,\n          // append am/pm depending on time of day\n          ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n        }\n      }\n\n      return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n    }\n  }\n  return time.toString();\n};\n\nexport const validateTime = (time: string, timeRegex: RegExp, delimiter: string, is12Hour: boolean) => {\n  // ISO 8601 format is valid\n  const date = new Date(time);\n  if (!isNaN(date.getDate()) && time.includes('T')) {\n    return true;\n  }\n  // hours only valid if they are [0-23] or [1-12]\n  const hours = parseInt(time.split(delimiter)[0]);\n  const validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23);\n  // minutes verified by timeRegex\n\n  // empty string is valid\n  return time === '' || (timeRegex.test(time) && validHours);\n};\n\nexport const getHours = (time: string, timeRegex: RegExp) => {\n  const parts = time.match(timeRegex);\n  if (parts && parts.length) {\n    if (/pm/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n    }\n    if (/am/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);\n    }\n    return parseInt(parts[1]);\n  }\n  return null;\n};\n\nexport const getMinutes = (time: string, timeRegex: RegExp) => {\n  const parts = time.match(timeRegex);\n  return parts && parts.length ? parseInt(parts[2]) : null;\n};\n\nexport const getSeconds = (time: string, timeRegex: RegExp) => {\n  const seconds = time.match(timeRegex)?.[3];\n\n  return seconds ? parseInt(seconds) : null;\n};\n\nexport const isWithinMinMax = (\n  minTime: string,\n  maxTime: string,\n  time: string,\n  delimiter: string,\n  includeSeconds?: boolean\n) => {\n  // do not throw error if empty string\n  if (time.trim() === '') {\n    return true;\n  }\n\n  // correctly format as 24hr times (12:30AM => 00:30, 1:15 => 01:15)\n  const min24HourTime = convertTo24Hour(minTime, delimiter, includeSeconds);\n  const selected24HourTime = convertTo24Hour(time, delimiter, includeSeconds);\n  const max24HourTime = convertTo24Hour(maxTime, delimiter, includeSeconds);\n\n  // simple string comparison for 24hr times\n  return min24HourTime <= selected24HourTime && selected24HourTime <= max24HourTime;\n};\n\nconst convertTo24Hour = (time: string, delimiter: string, includeSeconds: boolean): string => {\n  const timeReg = new RegExp(`^\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)${delimiter}?([0-5]\\\\d)?\\\\s*([AaPp][Mm])?\\\\s*$`);\n  const regMatches = timeReg.exec(time);\n  if (!regMatches || !regMatches.length) {\n    return;\n  }\n  let hours = regMatches[1].padStart(2, '0');\n  const minutes = regMatches[2];\n  let seconds = regMatches[3] ? `${delimiter}${regMatches[3]}` : '';\n\n  // When seconds is empty and 'includeSeconds' is enabled, append 0 seconds.\n  if (!seconds && includeSeconds) {\n    seconds = `${delimiter}00`;\n  }\n\n  const suffix = regMatches[4] || '';\n  if (suffix.toUpperCase() === 'PM' && hours !== '12') {\n    hours = `${parseInt(hours) + 12}`;\n  } else if (suffix.toUpperCase() === 'AM' && hours === '12') {\n    hours = '00';\n  }\n\n  return `${hours}${delimiter}${minutes}${seconds}`;\n};\n"]},"metadata":{},"sourceType":"module"}