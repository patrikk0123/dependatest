{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param delay - delay after which buffer outputs new data (if any)\n * @param preprocessor - function by which each added line is modified\n */\nexport const useDataBuffer = function (delay) {\n  let preprocessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lines => lines;\n  const [data, setData] = useState([]);\n  const [buffer, setBuffer] = useState([]);\n  const [currentLineCount, setCurrentLineCount] = useState(0);\n  const savedTimer = useRef();\n  const newLinesCounts = useRef([]);\n  useEffect(() => {\n    savedTimer.current = setInterval(() => {\n      console.log(newLinesCounts.current);\n\n      if (newLinesCounts.current.length) {\n        setCurrentLineCount(currentLineCount => currentLineCount + newLinesCounts.current[0]);\n        newLinesCounts.current.shift();\n      }\n    }, delay);\n  }, [delay]); // useEffect(() => {\n  //   if (data.length > buffer.length) {\n  //     savedTimer.current = setTimeout(() => {\n  //       setCurrentLineCount((currentLineCount) => currentLineCount + 5);\n  //     }, 1500);\n  //   }\n  //   return () => {\n  //     clearTimeout(savedTimer.current);\n  //   };\n  // }, [data.length, buffer.length]);\n\n  useEffect(() => {\n    if (data.length > buffer.length) setBuffer(data.slice(0, currentLineCount)); // if (currentLineCount > initLogData.length) {\n    //   clearInterval(savedTimer.current);\n    // } else {\n    //   // setLogData(initLogData.slice(0, currentLineCount));\n    //   addLines(initLogData.slice(currentLineCount - 3, currentLineCount));\n    // }\n  }, [currentLineCount]);\n  const addLines = useCallback(lines => {\n    setData([...data, ...preprocessor(lines)]);\n    newLinesCounts.current.push(lines.length);\n  }, [data, preprocessor]);\n  return {\n    buffer,\n    addLines\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useDataBuffer","delay","preprocessor","lines","data","setData","buffer","setBuffer","currentLineCount","setCurrentLineCount","savedTimer","newLinesCounts","current","setInterval","console","log","length","shift","slice","addLines","push"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/containers/useDataBuffer.ts"],"sourcesContent":["import { MutableRefObject, useCallback, useEffect, useRef, useState } from 'react';\n\ntype PreprocessorFunction = (lines: string[]) => string[];\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param delay - delay after which buffer outputs new data (if any)\n * @param preprocessor - function by which each added line is modified\n */\nexport const useDataBuffer = (delay: number, preprocessor: PreprocessorFunction = (lines: string[]) => lines) => {\n  const [data, setData] = useState<string[]>([]);\n  const [buffer, setBuffer] = useState<string[]>([]);\n  const [currentLineCount, setCurrentLineCount] = useState<number>(0);\n  const savedTimer: MutableRefObject<NodeJS.Timer | undefined> = useRef();\n\n  const newLinesCounts = useRef<number[]>([]);\n\n  useEffect(() => {\n    savedTimer.current = setInterval(() => {\n      console.log(newLinesCounts.current);\n      if (newLinesCounts.current.length) {\n        setCurrentLineCount((currentLineCount) => currentLineCount + newLinesCounts.current[0]);\n        newLinesCounts.current.shift();\n      }\n    }, delay);\n  }, [delay]);\n\n  // useEffect(() => {\n  //   if (data.length > buffer.length) {\n  //     savedTimer.current = setTimeout(() => {\n  //       setCurrentLineCount((currentLineCount) => currentLineCount + 5);\n  //     }, 1500);\n  //   }\n  //   return () => {\n  //     clearTimeout(savedTimer.current);\n  //   };\n  // }, [data.length, buffer.length]);\n\n  useEffect(() => {\n    if (data.length > buffer.length) setBuffer(data.slice(0, currentLineCount));\n    // if (currentLineCount > initLogData.length) {\n    //   clearInterval(savedTimer.current);\n    // } else {\n    //   // setLogData(initLogData.slice(0, currentLineCount));\n    //   addLines(initLogData.slice(currentLineCount - 3, currentLineCount));\n    // }\n  }, [currentLineCount]);\n\n  const addLines = useCallback(\n    (lines: string[]) => {\n      setData([...data, ...preprocessor(lines)]);\n      newLinesCounts.current.push(lines.length);\n    },\n    [data, preprocessor]\n  );\n\n  return { buffer, addLines };\n};\n"],"mappings":"AAAA,SAA2BA,WAA3B,EAAwCC,SAAxC,EAAmDC,MAAnD,EAA2DC,QAA3D,QAA2E,OAA3E;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG,UAACC,KAAD,EAAoF;EAAA,IAApEC,YAAoE,uEAA9BC,KAAD,IAAqBA,KAAU;EAC/G,MAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBN,QAAQ,CAAW,EAAX,CAAhC;EACA,MAAM,CAACO,MAAD,EAASC,SAAT,IAAsBR,QAAQ,CAAW,EAAX,CAApC;EACA,MAAM,CAACS,gBAAD,EAAmBC,mBAAnB,IAA0CV,QAAQ,CAAS,CAAT,CAAxD;EACA,MAAMW,UAAsD,GAAGZ,MAAM,EAArE;EAEA,MAAMa,cAAc,GAAGb,MAAM,CAAW,EAAX,CAA7B;EAEAD,SAAS,CAAC,MAAM;IACda,UAAU,CAACE,OAAX,GAAqBC,WAAW,CAAC,MAAM;MACrCC,OAAO,CAACC,GAAR,CAAYJ,cAAc,CAACC,OAA3B;;MACA,IAAID,cAAc,CAACC,OAAf,CAAuBI,MAA3B,EAAmC;QACjCP,mBAAmB,CAAED,gBAAD,IAAsBA,gBAAgB,GAAGG,cAAc,CAACC,OAAf,CAAuB,CAAvB,CAA1C,CAAnB;QACAD,cAAc,CAACC,OAAf,CAAuBK,KAAvB;MACD;IACF,CAN+B,EAM7BhB,KAN6B,CAAhC;EAOD,CARQ,EAQN,CAACA,KAAD,CARM,CAAT,CAR+G,CAkB/G;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEAJ,SAAS,CAAC,MAAM;IACd,IAAIO,IAAI,CAACY,MAAL,GAAcV,MAAM,CAACU,MAAzB,EAAiCT,SAAS,CAACH,IAAI,CAACc,KAAL,CAAW,CAAX,EAAcV,gBAAd,CAAD,CAAT,CADnB,CAEd;IACA;IACA;IACA;IACA;IACA;EACD,CARQ,EAQN,CAACA,gBAAD,CARM,CAAT;EAUA,MAAMW,QAAQ,GAAGvB,WAAW,CACzBO,KAAD,IAAqB;IACnBE,OAAO,CAAC,CAAC,GAAGD,IAAJ,EAAU,GAAGF,YAAY,CAACC,KAAD,CAAzB,CAAD,CAAP;IACAQ,cAAc,CAACC,OAAf,CAAuBQ,IAAvB,CAA4BjB,KAAK,CAACa,MAAlC;EACD,CAJyB,EAK1B,CAACZ,IAAD,EAAOF,YAAP,CAL0B,CAA5B;EAQA,OAAO;IAAEI,MAAF;IAAUa;EAAV,CAAP;AACD,CAhDM"},"metadata":{},"sourceType":"module"}