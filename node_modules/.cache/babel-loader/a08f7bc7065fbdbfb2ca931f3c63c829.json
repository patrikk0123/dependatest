{"ast":null,"code":"import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\n\nexport default function detectOverflow(state) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  const altContext = elementContext === popper ? reference : popper;\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  const offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","map":{"version":3,"mappings":"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","names":["getBoundingClientRect","getClippingRect","getDocumentElement","computeOffsets","rectToClientRect","clippingParents","reference","popper","bottom","top","right","basePlacements","viewport","isElement","mergePaddingObject","expandToHashMap","detectOverflow","state","options","placement","boundary","rootBoundary","elementContext","altBoundary","padding","paddingObject","altContext","referenceElement","elements","popperRect","rects","element","clippingClientRect","contextElement","referenceClientRect","popperOffsets","strategy","popperClientRect","elementClientRect","overflowOffsets","left","offsetData","modifiersData","offset","Object","keys","forEach","key","multiply","indexOf","axis"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.ts"],"sourcesContent":["// @ts-nocheck\nimport { State, SideObject, Padding } from '../types';\nimport { Placement, Boundary, RootBoundary, Context } from '../enums';\nimport getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  placement: Placement;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  elementContext: Context;\n  altBoundary: boolean;\n  padding: Padding;\n}\n\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state: State, options: Partial<Options> = {}): SideObject {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements)\n  );\n\n  const altContext = elementContext === popper ? reference : popper;\n\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n\n  const clippingClientRect = getClippingRect(\n    isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper),\n    boundary,\n    rootBoundary\n  );\n\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n\n  const popperClientRect = rectToClientRect({\n    ...popperRect,\n    ...popperOffsets\n  });\n\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n\n  const offsetData = state.modifiersData.offset;\n\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n"]},"metadata":{},"sourceType":"module"}