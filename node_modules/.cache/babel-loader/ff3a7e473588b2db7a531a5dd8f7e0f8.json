{"ast":null,"code":"import _toConsumableArray from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n/**\n * @param element\n */\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n/**\n * @param element\n * @param clippingParent\n */\n\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n/**\n * @param element\n */\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\n\n\nexport default function getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(_toConsumableArray(mainClippingParents), [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","map":{"version":3,"mappings":"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","names":["viewport","getViewportRect","getDocumentRect","listScrollParents","getOffsetParent","getDocumentElement","getComputedStyle","isElement","isHTMLElement","getBoundingClientRect","getParentNode","contains","getNodeName","rectToClientRect","getInnerBoundingClientRect","element","rect","top","clientTop","left","clientLeft","bottom","clientHeight","right","clientWidth","width","height","x","y","getClientRectFromMixedType","clippingParent","getClippingParents","clippingParents","canEscapeClipping","indexOf","position","clipperElement","filter","getClippingRect","boundary","rootBoundary","mainClippingParents","concat","firstClippingParent","clippingRect","reduce","accRect","Math","max","min"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.ts"],"sourcesContent":["// @ts-nocheck\nimport { ClientRectObject } from '../types';\nimport { Boundary, RootBoundary } from '../enums';\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n\n/**\n * @param element\n */\nfunction getInnerBoundingClientRect(element: Element) {\n  const rect = getBoundingClientRect(element);\n\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n\n  return rect;\n}\n\n/**\n * @param element\n * @param clippingParent\n */\nfunction getClientRectFromMixedType(element: Element, clippingParent: Element | RootBoundary): ClientRectObject {\n  return clippingParent === viewport\n    ? rectToClientRect(getViewportRect(element))\n    : isHTMLElement(clippingParent)\n    ? getInnerBoundingClientRect(clippingParent)\n    : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n/**\n * @param element\n */\nfunction getClippingParents(element: Element): Element[] {\n  const clippingParents = listScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n\n  // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n  return clippingParents.filter(\n    clippingParent =>\n      isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body'\n  );\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\nexport default function getClippingRect(\n  element: Element,\n  boundary: Boundary,\n  rootBoundary: RootBoundary\n): ClientRectObject {\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromMixedType(element, clippingParent);\n\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n\n  return clippingRect;\n}\n"]},"metadata":{},"sourceType":"module"}