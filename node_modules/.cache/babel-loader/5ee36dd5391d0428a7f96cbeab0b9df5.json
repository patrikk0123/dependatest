{"ast":null,"code":"import * as WebConfigAPI from './WebConfigService';\nimport { Keycloak } from './keycloakHolder';\n/**\n * Enum with possible authentication roles in Keycloak.\n *\n */\n\nexport let AUTH_ROLE;\n/**\n * Class managing authentication functionality.\n */\n\n(function (AUTH_ROLE) {\n  AUTH_ROLE[\"Admin\"] = \"admin\";\n  AUTH_ROLE[\"User\"] = \"user\";\n  AUTH_ROLE[\"System\"] = \"system-user\";\n  AUTH_ROLE[\"Power\"] = \"power-user\";\n})(AUTH_ROLE || (AUTH_ROLE = {}));\n\nclass KeycloakService {\n  // We can't get KeycloakInstance type because of dynamic loading of Keycloak library\n  // Default: 24 Hours\n\n  /*\n  false if: \n  - Keycloak library is not loaded,\n  or library is loaded, but:\n  - was not initialized yet\n  - is initializing\n  - initialization failed\n  */\n  constructor() {\n    this.keycloakAuth = null;\n    this.KEYCLOAK_TOKEN_MIN_EXP = 86400;\n    this.isKeycloakInitialized = void 0;\n    this._isKeycloakAvailable = false;\n    this.isKeycloakInitialized = this.init();\n  }\n\n  get isKeycloakAvailable() {\n    return this._isKeycloakAvailable;\n  }\n  /**\n   * Initialize Keycloak and create instance.\n   *\n   * @returns Promise.\n   */\n\n\n  init() {\n    const keycloakConfig = WebConfigAPI.getWebConfig().keycloak;\n\n    if (Keycloak) {\n      this.keycloakAuth = new Keycloak({\n        url: keycloakConfig.url,\n        realm: keycloakConfig.realm,\n        clientId: keycloakConfig.clientId\n      });\n      return new Promise((resolve, reject) => {\n        this.keycloakAuth.init({\n          onLoad: 'check-sso'\n        }).then(() => {\n          this._isKeycloakAvailable = true;\n          resolve('success');\n        }).catch(errorData => {\n          reject(errorData);\n        });\n      });\n    } else {\n      return Promise.reject('Keycloak library not available');\n    }\n  }\n  /**\n   * Returns promise of Keycloak initialization.\n   *\n   * @returns Promise.\n   */\n\n\n  isInitialized() {\n    return this.isKeycloakInitialized;\n  }\n  /**\n   * Returns if user is authenticated.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns True if user is authenticated, false otherwise.\n   */\n\n\n  isAuthenticated() {\n    this.checkKeycloakAvailability();\n    return this.keycloakAuth.authenticated;\n  }\n  /**\n   * Initiate login process in keycloak.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns Promise.\n   */\n\n\n  login() {\n    this.checkKeycloakAvailability();\n    return this.keycloakAuth.login();\n  }\n  /**\n   * Initiate logout process in keycloak.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @param redirectUri URI to redirect after logout.\n   */\n\n\n  logout(redirectUri) {\n    this.checkKeycloakAvailability();\n    this.keycloakAuth.logout({\n      redirectUri\n    });\n  }\n  /**\n   * Gets keycloak token.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns String with token if user is logged in, undefined otherwise.\n   */\n\n\n  getToken() {\n    this.checkKeycloakAvailability();\n    this.updateToken().then(isTokenRefreshed => {\n      if (isTokenRefreshed) {\n        console.log('Token refreshed.');\n      } else {//console.log('Token not refreshed, valid for: \\n' + this.getTokenValidity()); //dev purpose, too much spam\n      }\n    }).catch(() => {\n      throw new Error('Failed to refresh token');\n    });\n    return this.keycloakAuth.token;\n  }\n  /**\n   * Returns token validity string.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns Token validity string.\n   */\n\n\n  getTokenValidity() {\n    this.checkKeycloakAvailability();\n\n    if (!this.keycloakAuth.tokenParsed) {\n      return 'Not authenticated';\n    }\n\n    let validity = 'Token Expires:\\t\\t' + new Date((this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() + '\\n';\n    validity += 'Token Expires in:\\t' + Math.round(this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) + ' seconds\\n';\n\n    if (this.keycloakAuth.refreshTokenParsed) {\n      validity += 'Refresh Token Expires:\\t' + new Date((this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() + '\\n';\n      validity += 'Refresh Expires in:\\t' + Math.round(this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) + ' seconds';\n    }\n\n    return validity;\n  }\n  /**\n   * Returns whether is token expired.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns True if token is expired, false otherwise.\n   */\n\n\n  isTokenExpired() {\n    this.checkKeycloakAvailability();\n    return this.keycloakAuth.isTokenExpired(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n  /**\n   * Updates token.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns Promise.\n   */\n\n\n  updateToken() {\n    this.checkKeycloakAvailability();\n    return this.keycloakAuth.updateToken(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n  /**\n   * Gets user name from keycloak.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns String with username if user is logged in, undefined otherwise.\n   */\n\n\n  getUser() {\n    var _this$keycloakAuth$id;\n\n    this.checkKeycloakAvailability();\n    return (_this$keycloakAuth$id = this.keycloakAuth.idTokenParsed) === null || _this$keycloakAuth$id === void 0 ? void 0 : _this$keycloakAuth$id.preferred_username;\n  }\n  /**\n   * Checks if user has required auth role.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @param role AUTH_ROLE\n   * @returns True when user is logged in and has required role for access, false otherwise.\n   */\n\n\n  hasRealmRole(role) {\n    this.checkKeycloakAvailability();\n    return this.keycloakAuth.hasRealmRole(role);\n  }\n  /**\n   * Checks Keycloak availability and throws exception if Keycloak is not available.\n   */\n\n\n  checkKeycloakAvailability() {\n    if (!this.isKeycloakAvailable) {\n      throw new Error('Keycloak not available! Please check Keycloak availability before using Keycloak service method.');\n    }\n  }\n\n}\n/**\n * Instance of KeycloakService providing group of Keycloak related API operations.\n */\n\n\nexport const keycloakService = new KeycloakService();","map":{"version":3,"names":["WebConfigAPI","Keycloak","AUTH_ROLE","KeycloakService","constructor","keycloakAuth","KEYCLOAK_TOKEN_MIN_EXP","isKeycloakInitialized","_isKeycloakAvailable","init","isKeycloakAvailable","keycloakConfig","getWebConfig","keycloak","url","realm","clientId","Promise","resolve","reject","onLoad","then","catch","errorData","isInitialized","isAuthenticated","checkKeycloakAvailability","authenticated","login","logout","redirectUri","getToken","updateToken","isTokenRefreshed","console","log","Error","token","getTokenValidity","tokenParsed","validity","Date","exp","timeSkew","toLocaleString","Math","round","getTime","refreshTokenParsed","isTokenExpired","getUser","idTokenParsed","preferred_username","hasRealmRole","role","keycloakService"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/services/keycloakService.ts"],"sourcesContent":["import * as WebConfigAPI from './WebConfigService';\nimport { Keycloak } from './keycloakHolder';\n\n/**\n * Enum with possible authentication roles in Keycloak.\n *\n */\nexport enum AUTH_ROLE {\n  Admin = 'admin',\n  User = 'user',\n  System = 'system-user',\n  Power = 'power-user',\n}\n\n/**\n * Class managing authentication functionality.\n */\nclass KeycloakService {\n  // We can't get KeycloakInstance type because of dynamic loading of Keycloak library\n  private keycloakAuth: any = null;\n\n  private KEYCLOAK_TOKEN_MIN_EXP = 86400; // Default: 24 Hours\n\n  private isKeycloakInitialized;\n\n  /*\n  false if: \n  - Keycloak library is not loaded,\n  or library is loaded, but:\n  - was not initialized yet\n  - is initializing\n  - initialization failed\n  */\n  private _isKeycloakAvailable: boolean = false;\n\n  constructor() {\n    this.isKeycloakInitialized = this.init();\n  }\n\n  public get isKeycloakAvailable(): boolean {\n    return this._isKeycloakAvailable;\n  }\n\n  /**\n   * Initialize Keycloak and create instance.\n   *\n   * @returns Promise.\n   */\n  private init(): Promise<any> {\n    const keycloakConfig = WebConfigAPI.getWebConfig().keycloak;\n\n    if (Keycloak) {\n      this.keycloakAuth = new Keycloak({\n        url: keycloakConfig.url,\n        realm: keycloakConfig.realm,\n        clientId: keycloakConfig.clientId,\n      });\n\n      return new Promise((resolve, reject) => {\n        this.keycloakAuth\n          .init({ onLoad: 'check-sso' })\n          .then(() => {\n            this._isKeycloakAvailable = true;\n            resolve('success');\n          })\n          .catch((errorData: any) => {\n            reject(errorData);\n          });\n      });\n    } else {\n      return Promise.reject('Keycloak library not available');\n    }\n  }\n  /**\n   * Returns promise of Keycloak initialization.\n   *\n   * @returns Promise.\n   */\n  public isInitialized(): Promise<any> {\n    return this.isKeycloakInitialized;\n  }\n  /**\n   * Returns if user is authenticated.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns True if user is authenticated, false otherwise.\n   */\n  public isAuthenticated(): boolean {\n    this.checkKeycloakAvailability();\n\n    return this.keycloakAuth.authenticated!;\n  }\n\n  /**\n   * Initiate login process in keycloak.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns Promise.\n   */\n  public login(): Promise<any> {\n    this.checkKeycloakAvailability();\n\n    return this.keycloakAuth.login();\n  }\n\n  /**\n   * Initiate logout process in keycloak.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @param redirectUri URI to redirect after logout.\n   */\n  public logout(redirectUri?: string): void {\n    this.checkKeycloakAvailability();\n\n    this.keycloakAuth.logout({ redirectUri });\n  }\n\n  /**\n   * Gets keycloak token.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns String with token if user is logged in, undefined otherwise.\n   */\n  public getToken(): string {\n    this.checkKeycloakAvailability();\n\n    this.updateToken()\n      .then((isTokenRefreshed: boolean) => {\n        if (isTokenRefreshed) {\n          console.log('Token refreshed.');\n        } else {\n          //console.log('Token not refreshed, valid for: \\n' + this.getTokenValidity()); //dev purpose, too much spam\n        }\n      })\n      .catch(() => {\n        throw new Error('Failed to refresh token');\n      });\n\n    return this.keycloakAuth.token;\n  }\n\n  /**\n   * Returns token validity string.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns Token validity string.\n   */\n  public getTokenValidity(): string {\n    this.checkKeycloakAvailability();\n\n    if (!this.keycloakAuth.tokenParsed) {\n      return 'Not authenticated';\n    }\n\n    let validity =\n      'Token Expires:\\t\\t' +\n      new Date((this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() +\n      '\\n';\n    validity +=\n      'Token Expires in:\\t' +\n      Math.round(this.keycloakAuth.tokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) +\n      ' seconds\\n';\n\n    if (this.keycloakAuth.refreshTokenParsed) {\n      validity +=\n        'Refresh Token Expires:\\t' +\n        new Date((this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew) * 1000).toLocaleString() +\n        '\\n';\n      validity +=\n        'Refresh Expires in:\\t' +\n        Math.round(this.keycloakAuth.refreshTokenParsed.exp + this.keycloakAuth.timeSkew - new Date().getTime() / 1000) +\n        ' seconds';\n    }\n\n    return validity;\n  }\n\n  /**\n   * Returns whether is token expired.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns True if token is expired, false otherwise.\n   */\n  public isTokenExpired(): boolean {\n    this.checkKeycloakAvailability();\n\n    return this.keycloakAuth.isTokenExpired(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n\n  /**\n   * Updates token.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns Promise.\n   */\n  public updateToken(): Promise<boolean> {\n    this.checkKeycloakAvailability();\n\n    return this.keycloakAuth.updateToken(this.KEYCLOAK_TOKEN_MIN_EXP);\n  }\n\n  /**\n   * Gets user name from keycloak.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @returns String with username if user is logged in, undefined otherwise.\n   */\n  public getUser(): string | null {\n    this.checkKeycloakAvailability();\n\n    return this.keycloakAuth.idTokenParsed?.preferred_username;\n  }\n\n  /**\n   * Checks if user has required auth role.\n   *\n   * Throws exception if Keycloak is not available.\n   *\n   * @param role AUTH_ROLE\n   * @returns True when user is logged in and has required role for access, false otherwise.\n   */\n  public hasRealmRole(role: AUTH_ROLE): boolean {\n    this.checkKeycloakAvailability();\n\n    return this.keycloakAuth.hasRealmRole(role);\n  }\n\n  /**\n   * Checks Keycloak availability and throws exception if Keycloak is not available.\n   */\n  private checkKeycloakAvailability() {\n    if (!this.isKeycloakAvailable) {\n      throw new Error('Keycloak not available! Please check Keycloak availability before using Keycloak service method.');\n    }\n  }\n}\n\n/**\n * Instance of KeycloakService providing group of Keycloak related API operations.\n */\nexport const keycloakService = new KeycloakService();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}