{"ast":null,"code":"// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n/**\n *\n */\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","map":{"version":3,"mappings":"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","names":["top","left","right","bottom","start","getBasePlacement","getMainAxisFromPlacement","getAltAxis","within","getLayoutRect","getOffsetParent","detectOverflow","getVariation","getFreshSideObject","preventOverflow","state","options","name","mainAxis","checkMainAxis","altAxis","checkAltAxis","boundary","rootBoundary","altBoundary","padding","tether","tetherOffset","overflow","basePlacement","placement","variation","isBasePlacement","popperOffsets","modifiersData","referenceRect","rects","reference","popperRect","popper","tetherOffsetValue","data","x","y","mainSide","altSide","len","offset","min","max","additive","minLen","maxLen","arrowElement","elements","arrow","arrowRect","width","height","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","minOffset","maxOffset","arrowOffsetParent","clientOffset","clientTop","clientLeft","offsetModifierValue","tetherMin","tetherMax","preventedOffset","Math","enabled","phase","fn","requiresIfExists"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.ts"],"sourcesContent":["// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport { Placement, Boundary, RootBoundary } from '../enums';\nimport { Rect, ModifierArguments, Modifier, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n\ntype TetherOffset = (arg0: { popper: Rect; reference: Rect; placement: Placement }) => number | number;\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  /* Prevents boundaries overflow on the main axis */\n  mainAxis: boolean;\n\n  /* Prevents boundaries overflow on the alternate axis */\n  altAxis: boolean;\n\n  /* The area to check the popper is overflowing in */\n  boundary: Boundary;\n\n  /* If the popper is not overflowing the main area, fallback to this one */\n  rootBoundary: RootBoundary;\n\n  /* Use the reference's \"clippingParents\" boundary context */\n  altBoundary: boolean;\n\n  /**\n   * Allows the popper to overflow from its boundaries to keep it near its\n   * reference element\n   */\n  tether: boolean;\n\n  /* Offsets when the `tether` option should activate */\n  tetherOffset: TetherOffset;\n\n  /* Sets a padding to the provided boundary */\n  padding: Padding;\n}\n\n/**\n *\n */\nfunction preventOverflow({ state, options, name }: ModifierArguments<Options>) {\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = false,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    padding,\n    tether = true,\n    tetherOffset = 0\n  } = options;\n\n  const overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  const basePlacement = getBasePlacement(state.placement);\n  const variation = getVariation(state.placement);\n  const isBasePlacement = !variation;\n  const mainAxis = getMainAxisFromPlacement(basePlacement);\n  const altAxis = getAltAxis(mainAxis);\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const tetherOffsetValue =\n    typeof tetherOffset === 'function'\n      ? tetherOffset({\n          ...state.rects,\n          placement: state.placement\n        })\n      : tetherOffset;\n\n  const data = { x: 0, y: 0 };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    const mainSide = mainAxis === 'y' ? top : left;\n    const altSide = mainAxis === 'y' ? bottom : right;\n    const len = mainAxis === 'y' ? 'height' : 'width';\n    const offset = popperOffsets[mainAxis];\n\n    const min = popperOffsets[mainAxis] + overflow[mainSide];\n    const max = popperOffsets[mainAxis] - overflow[altSide];\n\n    const additive = tether ? -popperRect[len] / 2 : 0;\n\n    const minLen = variation === start ? referenceRect[len] : popperRect[len];\n    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n\n    // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n    const arrowElement = state.elements.arrow;\n    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };\n    const arrowPaddingObject = state.modifiersData['arrow#persistent']\n      ? state.modifiersData['arrow#persistent'].padding\n      : getFreshSideObject();\n    const arrowPaddingMin = arrowPaddingObject[mainSide];\n    const arrowPaddingMax = arrowPaddingObject[altSide];\n\n    // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n    const arrowLen = within(0, referenceRect[len], arrowRect[len]);\n\n    const minOffset = isBasePlacement\n      ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue\n      : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    const maxOffset = isBasePlacement\n      ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue\n      : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n\n    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    const clientOffset = arrowOffsetParent\n      ? mainAxis === 'y'\n        ? arrowOffsetParent.clientTop || 0\n        : arrowOffsetParent.clientLeft || 0\n      : 0;\n\n    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n\n    const tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    const tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n    const preventedOffset = within(\n      tether ? Math.min(min, tetherMin) : min,\n      offset,\n      tether ? Math.max(max, tetherMax) : max\n    );\n\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    const mainSide = mainAxis === 'x' ? top : left;\n    const altSide = mainAxis === 'x' ? bottom : right;\n    const offset = popperOffsets[altAxis];\n\n    const min = offset + overflow[mainSide];\n    const max = offset - overflow[altSide];\n\n    const preventedOffset = within(min, offset, max);\n\n    popperOffsets[altAxis] = preventedOffset;\n    data[altAxis] = preventedOffset - offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type PreventOverflowModifier = Modifier<'preventOverflow', Options>;\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n} as PreventOverflowModifier;\n"]},"metadata":{},"sourceType":"module"}