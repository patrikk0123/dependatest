{"ast":null,"code":"// @ts-nocheck\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport getNodeName from './getNodeName';\nimport getWindow from './getWindow';\nimport isScrollParent from './isScrollParent';\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\n/**\n * @param element\n * @param list\n */\n\nexport default function listScrollParents(element) {\n  let list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const scrollParent = getScrollParent(element);\n  const isBody = getNodeName(scrollParent) === 'body';\n  const win = getWindow(scrollParent);\n  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList // $FlowFixMe: isBody tells us target will be an HTMLElement here\n  : updatedList.concat(listScrollParents(getParentNode(target)));\n}","map":{"version":3,"mappings":"AAAA;AACA,OAAOA,eAAP,MAA4B,mBAA5B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AAEA,OAAOC,cAAP,MAA2B,kBAA3B;AAEA;;;;;;;AAMA;;;;;AAIA,eAAc,SAAUC,iBAAV,CACZC,OADY,EAEmB;EAAA,IAA/BC,IAA+B,uEAAF,EAAE;EAE/B,MAAMC,YAAY,GAAGR,eAAe,CAACM,OAAD,CAApC;EACA,MAAMG,MAAM,GAAGP,WAAW,CAACM,YAAD,CAAX,KAA8B,MAA7C;EACA,MAAME,GAAG,GAAGP,SAAS,CAACK,YAAD,CAArB;EACA,MAAMG,MAAM,GAAGF,MAAM,GACjB,CAACC,GAAD,EAAME,MAAN,CAAaF,GAAG,CAACG,cAAJ,IAAsB,EAAnC,EAAuCT,cAAc,CAACI,YAAD,CAAd,GAA+BA,YAA/B,GAA8C,EAArF,CADiB,GAEjBA,YAFJ;EAGA,MAAMM,WAAW,GAAGP,IAAI,CAACK,MAAL,CAAYD,MAAZ,CAApB;EAEA,OAAOF,MAAM,GACTK,WADS,CACG;EADH,EAETA,WAAW,CAACF,MAAZ,CAAmBP,iBAAiB,CAACJ,aAAa,CAACU,MAAD,CAAd,CAApC,CAFJ;AAGD","names":["getScrollParent","getParentNode","getNodeName","getWindow","isScrollParent","listScrollParents","element","list","scrollParent","isBody","win","target","concat","visualViewport","updatedList"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/dom-utils/listScrollParents.ts"],"sourcesContent":["// @ts-nocheck\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport getNodeName from './getNodeName';\nimport getWindow from './getWindow';\nimport { Window, VisualViewport } from '../types';\nimport isScrollParent from './isScrollParent';\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the \nreference element's position.\n*/\n/**\n * @param element\n * @param list\n */\nexport default function listScrollParents(\n  element: Node,\n  list: (Element | Window)[] = []\n): (Element | Window | VisualViewport)[] {\n  const scrollParent = getScrollParent(element);\n  const isBody = getNodeName(scrollParent) === 'body';\n  const win = getWindow(scrollParent);\n  const target = isBody\n    ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : [])\n    : scrollParent;\n  const updatedList = list.concat(target);\n\n  return isBody\n    ? updatedList // $FlowFixMe: isBody tells us target will be an HTMLElement here\n    : updatedList.concat(listScrollParents(getParentNode(target)));\n}\n"]},"metadata":{},"sourceType":"module"}