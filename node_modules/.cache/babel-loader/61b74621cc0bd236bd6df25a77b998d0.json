{"ast":null,"code":"const hasCompoundParentsExpanded = (parentId, compoundParent, rows) => {\n  // max rows.length parents\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const i of rows) {\n    if (rows[parentId].hasOwnProperty('parent')) {\n      parentId = rows[parentId].parent;\n    } else {\n      return rows[parentId].cells[compoundParent].props.isOpen;\n    }\n  }\n\n  return false;\n};\n\nconst hasParentsExpanded = (parentId, rows) => {\n  // max rows.length parents\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const i of rows) {\n    if (rows[parentId].hasOwnProperty('parent')) {\n      parentId = rows[parentId].parent;\n    } else {\n      return rows[parentId].isOpen;\n    }\n  }\n\n  return false;\n};\n\nexport const isRowExpanded = (row, rows) => {\n  if (row.parent !== undefined) {\n    if (row.hasOwnProperty('compoundParent')) {\n      return hasCompoundParentsExpanded(row.parent, row.compoundParent, rows);\n    }\n\n    return hasParentsExpanded(row.parent, rows) && rows[row.parent].isOpen;\n  }\n\n  return undefined;\n};\nexport const getErrorTextByValidator = (validatorName, validators) => {\n  const result = validators.filter(validator => validator.name === validatorName);\n  return result[0].errorText;\n};\nexport const cancelCellEdits = row => {\n  row.cells.forEach(cell => {\n    delete cell.props.errorText;\n    delete cell.props.editableValue;\n    cell.props.isValid = true; // for editable selects, revert the selected property to its original value\n\n    if (cell.props.selected) {\n      cell.props.selected = cell.props.value;\n    }\n  });\n  row.isEditable = !row.isEditable;\n  row.isValid = true;\n  return row;\n};\nexport const validateCellEdits = function (row, type, validationErrors) {\n  let missingPropErrorTxt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Validation requires unique name property for row cells';\n  row.isValid = Object.keys(validationErrors).length ? false : true;\n  row.cells.forEach(cell => {\n    delete cell.props.errorText;\n    const hasValue = cell.props.value !== undefined && cell.props.value !== null;\n    const hasEditableValue = cell.props.editableValue !== undefined && cell.props.editableValue !== null;\n\n    if (cell.props && hasValue && hasEditableValue) {\n      if (type === 'save') {\n        const errorMsg = Object.keys(validationErrors).filter(validatorName => validationErrors[validatorName].includes(cell.props.name)).map(validatorName => getErrorTextByValidator(validatorName, row.rowEditValidationRules));\n\n        if (errorMsg.length) {\n          cell.props.errorText = cell.props.name ? errorMsg.join(', ') : missingPropErrorTxt;\n\n          if (cell.props.name === undefined) {\n            // eslint-disable-next-line no-console\n            console.warn('Row edit validation reporting requires cell definitions to have a unique name property.');\n          }\n        } else {\n          delete cell.props.errorText;\n          cell.props.isValid = true;\n        }\n      }\n    }\n  });\n  return row;\n};\nexport const applyCellEdits = (row, type) => {\n  row.cells.forEach(cell => {\n    delete cell.props.errorText;\n    const hasValue = cell.props.value !== undefined && cell.props.value !== null;\n    const hasEditableValue = cell.props.editableValue !== undefined && cell.props.editableValue !== null; // sync for validation\n\n    if (hasValue && !hasEditableValue) {\n      cell.props.editableValue = cell.props.value;\n    }\n\n    if (cell.props && hasValue && hasEditableValue) {\n      if (type === 'save') {\n        cell.props.value = cell.props.editableValue;\n        cell.props.isValid = true;\n        delete cell.props.errorText;\n      }\n\n      delete cell.props.editableValue;\n    }\n  });\n  row.isEditable = !row.isEditable;\n  row.isValid = true;\n  return row;\n};\n\nconst camelize = s => s.toUpperCase().replace('-', '').replace('_', '');\n\nexport const toCamel = s => s.replace(/([-_][a-z])/gi, camelize);\n/**\n * @param {string} input - String to capitalize\n */\n\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}","map":{"version":3,"mappings":"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","names":["hasCompoundParentsExpanded","parentId","compoundParent","rows","i","hasOwnProperty","parent","cells","props","isOpen","hasParentsExpanded","isRowExpanded","row","undefined","getErrorTextByValidator","validatorName","validators","result","filter","validator","name","errorText","cancelCellEdits","forEach","cell","editableValue","isValid","selected","value","isEditable","validateCellEdits","type","validationErrors","missingPropErrorTxt","Object","keys","length","hasValue","hasEditableValue","errorMsg","includes","map","rowEditValidationRules","join","console","warn","applyCellEdits","camelize","s","toUpperCase","replace","toCamel","capitalize","input","substring"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-table/src/components/Table/utils/utils.tsx"],"sourcesContent":["import { IRow, IRowCell, IValidatorDef, RowEditType, RowErrors } from '../TableTypes';\n\nconst hasCompoundParentsExpanded = (parentId: number, compoundParent: number, rows: IRow[]) => {\n  // max rows.length parents\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const i of rows) {\n    if (rows[parentId].hasOwnProperty('parent')) {\n      parentId = rows[parentId].parent;\n    } else {\n      return (rows[parentId].cells[compoundParent] as IRowCell).props.isOpen;\n    }\n  }\n  return false;\n};\n\nconst hasParentsExpanded = (parentId: number, rows: IRow[]) => {\n  // max rows.length parents\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const i of rows) {\n    if (rows[parentId].hasOwnProperty('parent')) {\n      parentId = rows[parentId].parent;\n    } else {\n      return rows[parentId].isOpen;\n    }\n  }\n  return false;\n};\n\nexport const isRowExpanded = (row: IRow, rows: IRow[]) => {\n  if (row.parent !== undefined) {\n    if (row.hasOwnProperty('compoundParent')) {\n      return hasCompoundParentsExpanded(row.parent, row.compoundParent, rows);\n    }\n    return hasParentsExpanded(row.parent, rows) && rows[row.parent].isOpen;\n  }\n  return undefined;\n};\n\nexport const getErrorTextByValidator = (validatorName: string, validators: IValidatorDef[]) => {\n  const result = validators.filter(validator => validator.name === validatorName);\n  return result[0].errorText;\n};\n\nexport const cancelCellEdits = (row: IRow) => {\n  (row.cells as IRowCell[]).forEach(cell => {\n    delete cell.props.errorText;\n    delete cell.props.editableValue;\n    cell.props.isValid = true;\n    // for editable selects, revert the selected property to its original value\n    if (cell.props.selected) {\n      cell.props.selected = cell.props.value;\n    }\n  });\n\n  row.isEditable = !row.isEditable;\n  row.isValid = true;\n  return row;\n};\n\nexport const validateCellEdits = (\n  row: IRow,\n  type: RowEditType,\n  validationErrors: RowErrors,\n  missingPropErrorTxt = 'Validation requires unique name property for row cells'\n) => {\n  row.isValid = Object.keys(validationErrors).length ? false : true;\n\n  (row.cells as IRowCell[]).forEach(cell => {\n    delete cell.props.errorText;\n\n    const hasValue = cell.props.value !== undefined && cell.props.value !== null;\n    const hasEditableValue = cell.props.editableValue !== undefined && cell.props.editableValue !== null;\n\n    if (cell.props && hasValue && hasEditableValue) {\n      if (type === 'save') {\n        const errorMsg = Object.keys(validationErrors)\n          .filter(validatorName => validationErrors[validatorName].includes(cell.props.name))\n          .map(validatorName => getErrorTextByValidator(validatorName, row.rowEditValidationRules));\n\n        if (errorMsg.length) {\n          cell.props.errorText = cell.props.name ? errorMsg.join(', ') : missingPropErrorTxt;\n          if (cell.props.name === undefined) {\n            // eslint-disable-next-line no-console\n            console.warn('Row edit validation reporting requires cell definitions to have a unique name property.');\n          }\n        } else {\n          delete cell.props.errorText;\n          cell.props.isValid = true;\n        }\n      }\n    }\n  });\n  return row;\n};\n\nexport const applyCellEdits = (row: IRow, type: RowEditType) => {\n  (row.cells as IRowCell[]).forEach(cell => {\n    delete cell.props.errorText;\n    const hasValue = cell.props.value !== undefined && cell.props.value !== null;\n    const hasEditableValue = cell.props.editableValue !== undefined && cell.props.editableValue !== null;\n\n    // sync for validation\n    if (hasValue && !hasEditableValue) {\n      cell.props.editableValue = cell.props.value;\n    }\n\n    if (cell.props && hasValue && hasEditableValue) {\n      if (type === 'save') {\n        cell.props.value = cell.props.editableValue;\n        cell.props.isValid = true;\n        delete cell.props.errorText;\n      }\n      delete cell.props.editableValue;\n    }\n  });\n\n  row.isEditable = !row.isEditable;\n  row.isValid = true;\n  return row;\n};\n\nconst camelize = (s: string) =>\n  s\n    .toUpperCase()\n    .replace('-', '')\n    .replace('_', '');\nexport const toCamel = (s: string) => s.replace(/([-_][a-z])/gi, camelize);\n\n/**\n * @param {string} input - String to capitalize\n */\nexport function capitalize(input: string) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n"]},"metadata":{},"sourceType":"module"}