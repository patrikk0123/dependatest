{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport { parseTime, validateTime, makeTimeOptions, amSuffix, pmSuffix, getHours, getMinutes, isWithinMinMax, getSeconds } from './TimePickerUtils';\nexport class TimePicker extends React.Component {\n  constructor(props) {\n    var _this;\n\n    super(props);\n    _this = this;\n    this.baseComponentRef = React.createRef();\n    this.toggleRef = React.createRef();\n    this.inputRef = React.createRef();\n    this.menuRef = React.createRef();\n\n    this.onDocClick = event => {\n      var _a, _b, _c, _d;\n\n      const clickedOnToggle = (_b = (_a = this.toggleRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);\n      const clickedWithinMenu = (_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);\n\n      if (this.state.isOpen && !(clickedOnToggle || clickedWithinMenu)) {\n        this.onToggle(false);\n      }\n    };\n\n    this.handleGlobalKeys = event => {\n      var _a, _b, _c, _d;\n\n      const {\n        isOpen,\n        focusedIndex,\n        scrollIndex\n      } = this.state; // keyboard pressed while focus on toggle\n\n      if ((_b = (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {\n        if (!isOpen && event.key !== KeyTypes.Tab) {\n          this.onToggle(true);\n        } else if (isOpen) {\n          if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n            this.onToggle(false);\n          } else if (event.key === KeyTypes.Enter) {\n            if (focusedIndex !== null) {\n              this.focusSelection(focusedIndex);\n              event.stopPropagation();\n            } else {\n              this.onToggle(false);\n            }\n          } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n            this.focusSelection(scrollIndex);\n            this.updateFocusedIndex(0);\n            event.preventDefault();\n          }\n        } // keyboard pressed while focus on menu item\n\n      } else if ((_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {\n        if (event.key === KeyTypes.ArrowDown) {\n          this.updateFocusedIndex(1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.ArrowUp) {\n          this.updateFocusedIndex(-1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.inputRef.current.focus();\n          this.onToggle(false);\n        }\n      }\n    };\n\n    this.updateFocusedIndex = increment => {\n      this.setState(prevState => {\n        const maxIndex = this.getOptions().length - 1;\n        let nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n\n        if (nextIndex < 0) {\n          nextIndex = maxIndex;\n        } else if (nextIndex > maxIndex) {\n          nextIndex = 0;\n        }\n\n        this.scrollToIndex(nextIndex);\n        return {\n          focusedIndex: nextIndex\n        };\n      });\n    }; // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n\n\n    this.getIndexToScroll = index => {\n      if (this.props.menuAppendTo === 'inline') {\n        return index > 0 ? index - 1 : 0;\n      }\n\n      return index;\n    };\n\n    this.scrollToIndex = index => {\n      this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[this.getIndexToScroll(index)].offsetTop;\n    };\n\n    this.focusSelection = index => {\n      var _a;\n\n      const indexToFocus = index !== -1 ? index : 0;\n\n      if ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) {\n        this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`).focus();\n      }\n    };\n\n    this.scrollToSelection = time => {\n      const {\n        delimiter,\n        is24Hour\n      } = this.props;\n      let splitTime = time.split(this.props.delimiter);\n      let focusedIndex = null; // build out the rest of the time assuming hh:00 if it's a partial time\n\n      if (splitTime.length < 2) {\n        time = `${time}${delimiter}00`;\n        splitTime = time.split(delimiter); // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n      } else if (splitTime.length > 2) {\n        time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n        splitTime = time.split(delimiter);\n      } // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n\n\n      if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n        const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n        time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      } else if (!is24Hour && splitTime.length > 1 && splitTime[1].length === 2 && !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) && !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n        time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      }\n\n      let scrollIndex = this.getOptions().findIndex(option => option.innerText === time); // if we found an exact match, scroll to match and return index of match for focus\n\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n        focusedIndex = scrollIndex;\n      } else if (splitTime.length === 2) {\n        // no exact match, scroll to closest hour but don't return index for focus\n        let amPm = '';\n\n        if (!is24Hour) {\n          if (splitTime[1].toUpperCase().includes('P')) {\n            amPm = pmSuffix;\n          } else if (splitTime[1].toUpperCase().includes('A')) {\n            amPm = amSuffix;\n          }\n        }\n\n        time = `${splitTime[0]}${delimiter}00${amPm}`;\n        scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n\n        if (scrollIndex !== -1) {\n          this.scrollToIndex(scrollIndex);\n        }\n      }\n\n      this.setState({\n        focusedIndex,\n        scrollIndex\n      });\n    };\n\n    this.getRegExp = function () {\n      let includeSeconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      const {\n        is24Hour,\n        delimiter\n      } = _this.props;\n      let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n\n      if (includeSeconds) {\n        baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n      }\n\n      return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n    };\n\n    this.getOptions = () => {\n      var _a;\n\n      return ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`)) : [];\n    };\n\n    this.isValidFormat = time => {\n      if (this.props.validateTime) {\n        return this.props.validateTime(time);\n      }\n\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds\n      } = this.props;\n      return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n    };\n\n    this.isValidTime = time => {\n      const {\n        delimiter,\n        includeSeconds\n      } = this.props;\n      const {\n        minTimeState,\n        maxTimeState\n      } = this.state;\n      return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n    };\n\n    this.isValid = time => this.isValidFormat(time) && this.isValidTime(time);\n\n    this.onToggle = isOpen => {\n      // on close, parse and validate input\n      this.setState(prevState => {\n        const {\n          timeRegex,\n          isInvalid\n        } = prevState;\n        const {\n          delimiter,\n          is24Hour,\n          includeSeconds\n        } = this.props;\n        const time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n        return {\n          isOpen,\n          timeState: time,\n          isInvalid: isOpen ? isInvalid : !this.isValid(time)\n        };\n      });\n    };\n\n    this.onSelect = e => {\n      const {\n        timeRegex,\n        timeState\n      } = this.state;\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds\n      } = this.props;\n      const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      if (time !== timeState) {\n        this.onInputChange(time);\n      }\n\n      this.inputRef.current.focus();\n      this.setState({\n        isOpen: false,\n        isInvalid: false\n      });\n    };\n\n    this.onInputClick = e => {\n      if (!this.state.isOpen) {\n        this.onToggle(true);\n      }\n\n      e.stopPropagation();\n    };\n\n    this.onInputChange = newTime => {\n      const {\n        onChange\n      } = this.props;\n      const {\n        timeRegex\n      } = this.state;\n\n      if (onChange) {\n        onChange(newTime, getHours(newTime, timeRegex), getMinutes(newTime, timeRegex), getSeconds(newTime, timeRegex), this.isValid(newTime));\n      }\n\n      this.scrollToSelection(newTime);\n      this.setState({\n        timeState: newTime\n      });\n    };\n\n    this.onBlur = event => {\n      const {\n        timeRegex\n      } = this.state;\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds\n      } = this.props;\n      const time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n      this.setState({\n        isInvalid: !this.isValid(time)\n      });\n    };\n\n    const {\n      is24Hour,\n      delimiter,\n      time,\n      includeSeconds\n    } = this.props;\n    let {\n      minTime,\n      maxTime\n    } = this.props;\n\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isOpen: false,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      timeState,\n      isOpen,\n      isInvalid,\n      timeRegex\n    } = this.state;\n    const {\n      time,\n      is24Hour,\n      delimiter,\n      includeSeconds\n    } = this.props;\n\n    if (isOpen && !prevState.isOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n\n    if (time !== '' && time !== prevProps.time) {\n      this.setState({\n        timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      'aria-label': ariaLabel,\n      isDisabled,\n      className,\n      placeholder,\n      id,\n      menuAppendTo,\n      is24Hour,\n      invalidFormatErrorMessage,\n      invalidMinMaxErrorMessage,\n      stepMinutes,\n      width,\n      delimiter,\n      inputProps,\n\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      onChange,\n      time,\n      validateTime,\n      minTime,\n      maxTime,\n      includeSeconds\n    } = _a,\n\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    props = __rest(_a, ['aria-label', \"isDisabled\", \"className\", \"placeholder\", \"id\", \"menuAppendTo\", \"is24Hour\", \"invalidFormatErrorMessage\", \"invalidMinMaxErrorMessage\", \"stepMinutes\", \"width\", \"delimiter\", \"inputProps\", \"onChange\", \"time\", \"validateTime\", \"minTime\", \"maxTime\", \"includeSeconds\"]);\n\n    const {\n      timeState,\n      isOpen,\n      isInvalid,\n      minTimeState,\n      maxTimeState\n    } = this.state;\n    const style = {\n      '--pf-c-date-picker__input--c-form-control--Width': width\n    };\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n\n      return null;\n    };\n\n    const menuContainer = React.createElement(Menu, {\n      ref: this.menuRef,\n      isScrollable: true\n    }, React.createElement(MenuContent, {\n      maxMenuHeight: \"200px\"\n    }, React.createElement(MenuList, {\n      \"aria-label\": ariaLabel\n    }, options.map((option, index) => React.createElement(MenuItem, {\n      onClick: this.onSelect,\n      key: option,\n      id: `${randomId}-option-${index}`\n    }, option)))));\n    const textInput = React.createElement(TextInput, Object.assign({\n      \"aria-haspopup\": \"menu\",\n      className: css(formStyles.formControl),\n      id: `${randomId}-input`,\n      \"aria-label\": ariaLabel,\n      validated: isInvalid ? 'error' : 'default',\n      placeholder: placeholder,\n      value: timeState || '',\n      type: \"text\",\n      iconVariant: \"clock\",\n      onClick: this.onInputClick,\n      onChange: this.onInputChange,\n      onBlur: this.onBlur,\n      autoComplete: \"off\",\n      isDisabled: isDisabled,\n      ref: this.inputRef\n    }, inputProps));\n    return React.createElement(\"div\", {\n      ref: this.baseComponentRef,\n      className: css(datePickerStyles.datePicker, className)\n    }, React.createElement(\"div\", Object.assign({\n      className: css(datePickerStyles.datePickerInput),\n      style: style\n    }, props), React.createElement(InputGroup, null, React.createElement(\"div\", {\n      id: randomId\n    }, React.createElement(\"div\", {\n      ref: this.toggleRef,\n      style: {\n        paddingLeft: '0'\n      }\n    }, menuAppendTo !== 'inline' ? React.createElement(Popper, {\n      appendTo: menuAppendTo === 'parent' ? getParentElement() : menuAppendTo,\n      trigger: textInput,\n      popper: menuContainer,\n      isVisible: isOpen\n    }) : textInput), isOpen && menuAppendTo === 'inline' && menuContainer)), isInvalid && React.createElement(\"div\", {\n      className: css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)\n    }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)));\n  }\n\n}\nTimePicker.displayName = 'TimePicker';\nTimePicker.defaultProps = {\n  className: '',\n  isDisabled: false,\n  time: '',\n  is24Hour: false,\n  invalidFormatErrorMessage: 'Invalid time format',\n  invalidMinMaxErrorMessage: 'Invalid time entered',\n  placeholder: 'hh:mm',\n  delimiter: ':',\n  'aria-label': 'Time picker',\n  width: '150px',\n  menuAppendTo: 'inline',\n  stepMinutes: 30,\n  inputProps: {},\n  minTime: '',\n  maxTime: ''\n};","map":{"version":3,"mappings":"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","names":["React","css","datePickerStyles","formStyles","menuStyles","getUniqueId","Popper","Menu","MenuContent","MenuList","MenuItem","InputGroup","TextInput","KeyTypes","parseTime","validateTime","makeTimeOptions","amSuffix","pmSuffix","getHours","getMinutes","isWithinMinMax","getSeconds","TimePicker","Component","constructor","props","createRef","event","clickedOnToggle","toggleRef","_a","current","_b","contains","target","clickedWithinMenu","menuRef","_c","_d","state","isOpen","onToggle","focusedIndex","scrollIndex","inputRef","key","Tab","Escape","Enter","focusSelection","stopPropagation","ArrowDown","ArrowUp","updateFocusedIndex","preventDefault","focus","increment","setState","prevState","maxIndex","getOptions","length","nextIndex","scrollToIndex","index","menuAppendTo","closest","menuContent","scrollTop","getIndexToScroll","offsetTop","indexToFocus","querySelector","menuItem","time","delimiter","is24Hour","splitTime","split","timeRegex","minutes","Date","toUpperCase","includes","trim","findIndex","option","innerText","amPm","includeSeconds","baseRegex","RegExp","Array","from","querySelectorAll","menuListItem","getRegExp","minTimeState","maxTimeState","isValidFormat","isValidTime","isInvalid","timeState","isValid","e","textContent","onInputChange","newTime","onChange","scrollToSelection","currentTarget","value","minTime","maxTime","minSeconds","maxSeconds","componentDidMount","document","addEventListener","onDocClick","handleGlobalKeys","componentWillUnmount","removeEventListener","componentDidUpdate","prevProps","render","ariaLabel","isDisabled","className","placeholder","id","invalidFormatErrorMessage","invalidMinMaxErrorMessage","stepMinutes","width","inputProps","style","options","randomId","getParentElement","baseComponentRef","parentElement","menuContainer","ref","isScrollable","maxMenuHeight","map","onClick","onSelect","textInput","Object","formControl","validated","type","iconVariant","onInputClick","onBlur","autoComplete","datePicker","datePickerInput","paddingLeft","appendTo","trigger","popper","isVisible","datePickerHelperText","modifiers","error"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/components/TimePicker/TimePicker.tsx"],"sourcesContent":["import * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput, TextInputProps } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport {\n  parseTime,\n  validateTime,\n  makeTimeOptions,\n  amSuffix,\n  pmSuffix,\n  getHours,\n  getMinutes,\n  isWithinMinMax,\n  getSeconds\n} from './TimePickerUtils';\n\nexport interface TimePickerProps\n  extends Omit<React.HTMLProps<HTMLDivElement>, 'onChange' | 'onFocus' | 'onBlur' | 'disabled' | 'ref'> {\n  /** Additional classes added to the time picker. */\n  className?: string;\n  /** Accessible label for the time picker */\n  'aria-label'?: string;\n  /** Flag indicating the time picker is disabled */\n  isDisabled?: boolean;\n  /** String to display in the empty time picker field as a hint for the expected time format */\n  placeholder?: string;\n  /** Character to display between the hour and minute */\n  delimiter?: string;\n  /** A time string. The format could be  an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  time?: string | Date;\n  /** Error message to display when the time is provided in an invalid format. */\n  invalidFormatErrorMessage?: string;\n  /** Error message to display when the time provided is not within the minTime/maxTime constriants */\n  invalidMinMaxErrorMessage?: string;\n  /** True if the time is 24 hour time. False if the time is 12 hour time */\n  is24Hour?: boolean;\n  /** Optional event handler called each time the value in the time picker input changes. */\n  onChange?: (time: string, hour?: number, minute?: number, seconds?: number, isValid?: boolean) => void;\n  /** Optional validator can be provided to override the internal time validator. */\n  validateTime?: (time: string) => boolean;\n  /** Id of the time picker */\n  id?: string;\n  /** Width of the time picker. */\n  width?: string;\n  /** The container to append the menu to. Defaults to 'inline'.\n   * If your menu is being cut off you can append it to an element higher up the DOM tree.\n   * Some examples:\n   * menuAppendTo=\"parent\"\n   * menuAppendTo={() => document.body}\n   * menuAppendTo={document.getElementById('target')}\n   */\n  menuAppendTo?: HTMLElement | (() => HTMLElement) | 'inline' | 'parent';\n  /** Size of step between time options in minutes.*/\n  stepMinutes?: number;\n  /** Additional props for input field */\n  inputProps?: TextInputProps;\n  /** A time string indicating the minimum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  minTime?: string | Date;\n  /** A time string indicating the maximum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  maxTime?: string | Date;\n  /** Includes number of seconds with the chosen time and allows users to manually edit the seconds value. */\n  includeSeconds?: boolean;\n}\n\ninterface TimePickerState {\n  isInvalid: boolean;\n  isOpen: boolean;\n  timeState: string;\n  focusedIndex: number;\n  scrollIndex: number;\n  timeRegex: RegExp;\n  minTimeState: string;\n  maxTimeState: string;\n}\n\nexport class TimePicker extends React.Component<TimePickerProps, TimePickerState> {\n  static displayName = 'TimePicker';\n  private baseComponentRef = React.createRef<any>();\n  private toggleRef = React.createRef<HTMLDivElement>();\n  private inputRef = React.createRef<HTMLInputElement>();\n  private menuRef = React.createRef<HTMLDivElement>();\n\n  static defaultProps = {\n    className: '',\n    isDisabled: false,\n    time: '',\n    is24Hour: false,\n    invalidFormatErrorMessage: 'Invalid time format',\n    invalidMinMaxErrorMessage: 'Invalid time entered',\n    placeholder: 'hh:mm',\n    delimiter: ':',\n    'aria-label': 'Time picker',\n    width: '150px',\n    menuAppendTo: 'inline',\n    stepMinutes: 30,\n    inputProps: {},\n    minTime: '',\n    maxTime: ''\n  };\n\n  constructor(props: TimePickerProps) {\n    super(props);\n    const { is24Hour, delimiter, time, includeSeconds } = this.props;\n    let { minTime, maxTime } = this.props;\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isOpen: false,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  onDocClick = (event: MouseEvent | TouchEvent) => {\n    const clickedOnToggle = this.toggleRef?.current?.contains(event.target as Node);\n    const clickedWithinMenu = this.menuRef?.current?.contains(event.target as Node);\n    if (this.state.isOpen && !(clickedOnToggle || clickedWithinMenu)) {\n      this.onToggle(false);\n    }\n  };\n\n  handleGlobalKeys = (event: KeyboardEvent) => {\n    const { isOpen, focusedIndex, scrollIndex } = this.state;\n    // keyboard pressed while focus on toggle\n    if (this.inputRef?.current?.contains(event.target as Node)) {\n      if (!isOpen && event.key !== KeyTypes.Tab) {\n        this.onToggle(true);\n      } else if (isOpen) {\n        if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.onToggle(false);\n        } else if (event.key === KeyTypes.Enter) {\n          if (focusedIndex !== null) {\n            this.focusSelection(focusedIndex);\n            event.stopPropagation();\n          } else {\n            this.onToggle(false);\n          }\n        } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n          this.focusSelection(scrollIndex);\n          this.updateFocusedIndex(0);\n          event.preventDefault();\n        }\n      }\n      // keyboard pressed while focus on menu item\n    } else if (this.menuRef?.current?.contains(event.target as Node)) {\n      if (event.key === KeyTypes.ArrowDown) {\n        this.updateFocusedIndex(1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.ArrowUp) {\n        this.updateFocusedIndex(-1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n        this.inputRef.current.focus();\n        this.onToggle(false);\n      }\n    }\n  };\n\n  componentDidUpdate(prevProps: TimePickerProps, prevState: TimePickerState) {\n    const { timeState, isOpen, isInvalid, timeRegex } = this.state;\n    const { time, is24Hour, delimiter, includeSeconds } = this.props;\n    if (isOpen && !prevState.isOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n    if (time !== '' && time !== prevProps.time) {\n      this.setState({\n        timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n\n  updateFocusedIndex = (increment: number) => {\n    this.setState(prevState => {\n      const maxIndex = this.getOptions().length - 1;\n      let nextIndex =\n        prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n      if (nextIndex < 0) {\n        nextIndex = maxIndex;\n      } else if (nextIndex > maxIndex) {\n        nextIndex = 0;\n      }\n      this.scrollToIndex(nextIndex);\n      return {\n        focusedIndex: nextIndex\n      };\n    });\n  };\n\n  // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n  getIndexToScroll = (index: number) => {\n    if (this.props.menuAppendTo === 'inline') {\n      return index > 0 ? index - 1 : 0;\n    }\n    return index;\n  };\n\n  scrollToIndex = (index: number) => {\n    this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[\n      this.getIndexToScroll(index)\n    ].offsetTop;\n  };\n\n  focusSelection = (index: number) => {\n    const indexToFocus = index !== -1 ? index : 0;\n\n    if (this.menuRef?.current) {\n      (this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`) as HTMLElement).focus();\n    }\n  };\n\n  scrollToSelection = (time: string) => {\n    const { delimiter, is24Hour } = this.props;\n    let splitTime = time.split(this.props.delimiter);\n    let focusedIndex = null;\n\n    // build out the rest of the time assuming hh:00 if it's a partial time\n    if (splitTime.length < 2) {\n      time = `${time}${delimiter}00`;\n      splitTime = time.split(delimiter);\n      // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n    } else if (splitTime.length > 2) {\n      time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n      splitTime = time.split(delimiter);\n    }\n\n    // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n    if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n      const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n      time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    } else if (\n      !is24Hour &&\n      splitTime.length > 1 &&\n      splitTime[1].length === 2 &&\n      !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) &&\n      !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())\n    ) {\n      time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    }\n    let scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n\n    // if we found an exact match, scroll to match and return index of match for focus\n    if (scrollIndex !== -1) {\n      this.scrollToIndex(scrollIndex);\n      focusedIndex = scrollIndex;\n    } else if (splitTime.length === 2) {\n      // no exact match, scroll to closest hour but don't return index for focus\n      let amPm = '';\n      if (!is24Hour) {\n        if (splitTime[1].toUpperCase().includes('P')) {\n          amPm = pmSuffix;\n        } else if (splitTime[1].toUpperCase().includes('A')) {\n          amPm = amSuffix;\n        }\n      }\n      time = `${splitTime[0]}${delimiter}00${amPm}`;\n      scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n      }\n    }\n    this.setState({\n      focusedIndex,\n      scrollIndex\n    });\n  };\n\n  getRegExp = (includeSeconds: boolean = true) => {\n    const { is24Hour, delimiter } = this.props;\n    let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n\n    if (includeSeconds) {\n      baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n    }\n\n    return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n  };\n\n  getOptions = () =>\n    (this.menuRef?.current\n      ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`))\n      : []) as HTMLElement[];\n\n  isValidFormat = (time: string) => {\n    if (this.props.validateTime) {\n      return this.props.validateTime(time);\n    }\n\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n  };\n\n  isValidTime = (time: string) => {\n    const { delimiter, includeSeconds } = this.props;\n    const { minTimeState, maxTimeState } = this.state;\n\n    return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n  };\n\n  isValid = (time: string) => this.isValidFormat(time) && this.isValidTime(time);\n\n  onToggle = (isOpen: boolean) => {\n    // on close, parse and validate input\n    this.setState(prevState => {\n      const { timeRegex, isInvalid } = prevState;\n      const { delimiter, is24Hour, includeSeconds } = this.props;\n      const time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      return {\n        isOpen,\n        timeState: time,\n        isInvalid: isOpen ? isInvalid : !this.isValid(time)\n      };\n    });\n  };\n\n  onSelect = (e: any) => {\n    const { timeRegex, timeState } = this.state;\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n    if (time !== timeState) {\n      this.onInputChange(time);\n    }\n\n    this.inputRef.current.focus();\n    this.setState({\n      isOpen: false,\n      isInvalid: false\n    });\n  };\n\n  onInputClick = (e: any) => {\n    if (!this.state.isOpen) {\n      this.onToggle(true);\n    }\n    e.stopPropagation();\n  };\n\n  onInputChange = (newTime: string) => {\n    const { onChange } = this.props;\n    const { timeRegex } = this.state;\n\n    if (onChange) {\n      onChange(\n        newTime,\n        getHours(newTime, timeRegex),\n        getMinutes(newTime, timeRegex),\n        getSeconds(newTime, timeRegex),\n        this.isValid(newTime)\n      );\n    }\n    this.scrollToSelection(newTime);\n    this.setState({\n      timeState: newTime\n    });\n  };\n\n  onBlur = (event: React.FocusEvent<HTMLInputElement>) => {\n    const { timeRegex } = this.state;\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    const time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n    this.setState({\n      isInvalid: !this.isValid(time)\n    });\n  };\n\n  render() {\n    const {\n      'aria-label': ariaLabel,\n      isDisabled,\n      className,\n      placeholder,\n      id,\n      menuAppendTo,\n      is24Hour,\n      invalidFormatErrorMessage,\n      invalidMinMaxErrorMessage,\n      stepMinutes,\n      width,\n      delimiter,\n      inputProps,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      onChange,\n      time,\n      validateTime,\n      minTime,\n      maxTime,\n      includeSeconds,\n      /* eslint-enable @typescript-eslint/no-unused-vars */\n      ...props\n    } = this.props;\n    const { timeState, isOpen, isInvalid, minTimeState, maxTimeState } = this.state;\n    const style = { '--pf-c-date-picker__input--c-form-control--Width': width } as React.CSSProperties;\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n      return null;\n    };\n\n    const menuContainer = (\n      <Menu ref={this.menuRef} isScrollable>\n        <MenuContent maxMenuHeight=\"200px\">\n          <MenuList aria-label={ariaLabel}>\n            {options.map((option, index) => (\n              <MenuItem onClick={this.onSelect} key={option} id={`${randomId}-option-${index}`}>\n                {option}\n              </MenuItem>\n            ))}\n          </MenuList>\n        </MenuContent>\n      </Menu>\n    );\n\n    const textInput = (\n      <TextInput\n        aria-haspopup=\"menu\"\n        className={css(formStyles.formControl)}\n        id={`${randomId}-input`}\n        aria-label={ariaLabel}\n        validated={isInvalid ? 'error' : 'default'}\n        placeholder={placeholder}\n        value={timeState || ''}\n        type=\"text\"\n        iconVariant=\"clock\"\n        onClick={this.onInputClick}\n        onChange={this.onInputChange}\n        onBlur={this.onBlur}\n        autoComplete=\"off\"\n        isDisabled={isDisabled}\n        ref={this.inputRef}\n        {...inputProps}\n      />\n    );\n\n    return (\n      <div ref={this.baseComponentRef} className={css(datePickerStyles.datePicker, className)}>\n        <div className={css(datePickerStyles.datePickerInput)} style={style} {...props}>\n          <InputGroup>\n            <div id={randomId}>\n              <div ref={this.toggleRef} style={{ paddingLeft: '0' }}>\n                {menuAppendTo !== 'inline' ? (\n                  <Popper\n                    appendTo={menuAppendTo === 'parent' ? getParentElement() : menuAppendTo}\n                    trigger={textInput}\n                    popper={menuContainer}\n                    isVisible={isOpen}\n                  />\n                ) : (\n                  textInput\n                )}\n              </div>\n              {isOpen && menuAppendTo === 'inline' && menuContainer}\n            </div>\n          </InputGroup>\n          {isInvalid && (\n            <div className={css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)}>\n              {!isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}