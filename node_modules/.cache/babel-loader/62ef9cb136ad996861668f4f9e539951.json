{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport styles from '@patternfly/react-styles/css/components/DragDrop/drag-drop';\nimport { DroppableContext } from './DroppableContext';\nimport { DragDropContext } from './DragDrop'; // Browsers really like being different from each other.\n\nfunction getDefaultBackground() {\n  const div = document.createElement('div');\n  document.head.appendChild(div);\n  const bg = window.getComputedStyle(div).backgroundColor;\n  document.head.removeChild(div);\n  return bg;\n}\n\nfunction getInheritedBackgroundColor(el) {\n  const defaultStyle = getDefaultBackground();\n  const backgroundColor = window.getComputedStyle(el).backgroundColor;\n\n  if (backgroundColor !== defaultStyle) {\n    return backgroundColor;\n  } else if (!el.parentElement) {\n    return defaultStyle;\n  }\n\n  return getInheritedBackgroundColor(el.parentElement);\n}\n\nfunction removeBlankDiv(node) {\n  if (node.getAttribute('blankDiv') === 'true') {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n\n      if (child.getAttribute('blankDiv') === 'true') {\n        node.removeChild(child);\n        node.setAttribute('blankDiv', 'false');\n        break;\n      }\n    }\n  }\n} // Reset per-element state\n\n\nfunction resetDroppableItem(droppableItem) {\n  removeBlankDiv(droppableItem.node);\n  droppableItem.node.classList.remove(styles.modifiers.dragging);\n  droppableItem.node.classList.remove(styles.modifiers.dragOutside);\n  droppableItem.draggableNodes.forEach((n, i) => {\n    n.style.transform = '';\n    n.style.transition = '';\n    droppableItem.draggableNodesRects[i] = n.getBoundingClientRect();\n  });\n}\n\nfunction overlaps(ev, rect) {\n  return ev.clientX > rect.x && ev.clientX < rect.x + rect.width && ev.clientY > rect.y && ev.clientY < rect.y + rect.height;\n}\n\nexport const Draggable = _a => {\n  var {\n    className,\n    children,\n    style: styleProp = {},\n    hasNoWrapper = false\n  } = _a,\n      props = __rest(_a, [\"className\", \"children\", \"style\", \"hasNoWrapper\"]);\n  /* eslint-disable prefer-const */\n\n\n  let [style, setStyle] = React.useState(styleProp);\n  /* eslint-enable prefer-const */\n\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [isValidDrag, setIsValidDrag] = React.useState(true);\n  const {\n    zone,\n    droppableId\n  } = React.useContext(DroppableContext);\n  const {\n    onDrag,\n    onDragMove,\n    onDrop\n  } = React.useContext(DragDropContext); // Some state is better just to leave as vars passed around between various callbacks\n  // You can only drag around one item at a time anyways...\n\n  let startX = 0;\n  let startY = 0;\n  let index = null; // Index of this draggable\n\n  let hoveringDroppable;\n  let hoveringIndex = null;\n  let mouseMoveListener;\n  let mouseUpListener; // Makes it so dragging the _bottom_ of the item over the halfway of another moves it\n\n  let startYOffset = 0; // After item returning to where it started animation completes\n\n  const onTransitionEnd = _ev => {\n    if (isDragging) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    }\n  };\n\n  function getSourceAndDest() {\n    const hoveringDroppableId = hoveringDroppable ? hoveringDroppable.getAttribute('data-pf-droppableid') : null;\n    const source = {\n      droppableId,\n      index\n    };\n    const dest = hoveringDroppableId !== null && hoveringIndex !== null ? {\n      droppableId: hoveringDroppableId,\n      index: hoveringIndex\n    } : undefined;\n    return {\n      source,\n      dest,\n      hoveringDroppableId\n    };\n  }\n\n  const onMouseUpWhileDragging = droppableItems => {\n    droppableItems.forEach(resetDroppableItem);\n    document.removeEventListener('mousemove', mouseMoveListener);\n    document.removeEventListener('mouseup', mouseUpListener);\n    document.removeEventListener('contextmenu', mouseUpListener);\n    const {\n      source,\n      dest,\n      hoveringDroppableId\n    } = getSourceAndDest();\n    const consumerReordered = onDrop(source, dest);\n\n    if (consumerReordered && droppableId === hoveringDroppableId) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    } else if (!consumerReordered) {\n      // Animate item returning to where it started\n      setStyle(Object.assign(Object.assign({}, style), {\n        transition: 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s',\n        transform: '',\n        background: styleProp.background,\n        boxShadow: styleProp.boxShadow\n      }));\n    }\n  }; // This is where the magic happens\n\n\n  const onMouseMoveWhileDragging = (ev, droppableItems, blankDivRect) => {\n    // Compute each time what droppable node we are hovering over\n    hoveringDroppable = null;\n    droppableItems.forEach(droppableItem => {\n      const {\n        node,\n        rect,\n        isDraggingHost,\n        draggableNodes,\n        draggableNodesRects\n      } = droppableItem;\n\n      if (overlaps(ev, rect)) {\n        // Add valid dropzone style\n        node.classList.remove(styles.modifiers.dragOutside);\n        hoveringDroppable = node; // Check if we need to add a blank div row\n\n        if (node.getAttribute('blankDiv') !== 'true' && !isDraggingHost) {\n          const blankDiv = document.createElement('div');\n          blankDiv.setAttribute('blankDiv', 'true'); // Makes removing easier\n\n          let blankDivPos = -1;\n\n          for (let i = 0; i < draggableNodes.length; i++) {\n            const childRect = draggableNodesRects[i];\n            const isLast = i === draggableNodes.length - 1;\n            const startOverlaps = childRect.y >= startY - startYOffset;\n\n            if ((startOverlaps || isLast) && blankDivPos === -1) {\n              if (isLast && !startOverlaps) {\n                draggableNodes[i].after(blankDiv);\n              } else {\n                draggableNodes[i].before(blankDiv);\n              }\n\n              blankDiv.style.height = `${blankDivRect.height}px`;\n              blankDiv.style.width = `${blankDivRect.width}px`;\n              node.setAttribute('blankDiv', 'true'); // Makes removing easier\n\n              blankDivPos = i;\n            }\n\n            if (blankDivPos !== -1) {\n              childRect.y += blankDivRect.height;\n            }\n          } // Insert so drag + drop behavior matches single-list case\n\n\n          draggableNodes.splice(blankDivPos, 0, blankDiv);\n          draggableNodesRects.splice(blankDivPos, 0, blankDivRect); // Extend hitbox of droppable zone\n\n          rect.height += blankDivRect.height;\n        }\n      } else {\n        resetDroppableItem(droppableItem);\n        node.classList.add(styles.modifiers.dragging);\n        node.classList.add(styles.modifiers.dragOutside);\n      }\n    }); // Move hovering draggable and style it based on cursor position\n\n    setStyle(Object.assign(Object.assign({}, style), {\n      transform: `translate(${ev.pageX - startX}px, ${ev.pageY - startY}px)`\n    }));\n    setIsValidDrag(Boolean(hoveringDroppable)); // Iterate through sibling draggable nodes to reposition them and store correct hoveringIndex for onDrop\n\n    hoveringIndex = null;\n\n    if (hoveringDroppable) {\n      const {\n        draggableNodes,\n        draggableNodesRects\n      } = droppableItems.find(item => item.node === hoveringDroppable);\n      let lastTranslate = 0;\n      draggableNodes.forEach((n, i) => {\n        n.style.transition = 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s';\n        const rect = draggableNodesRects[i];\n        const halfway = rect.y + rect.height / 2;\n        let translateY = 0; // Use offset for more interactive translations\n\n        if (startY < halfway && ev.pageY + (blankDivRect.height - startYOffset) > halfway) {\n          translateY -= blankDivRect.height;\n        } else if (startY >= halfway && ev.pageY - startYOffset <= halfway) {\n          translateY += blankDivRect.height;\n        } // Clever way to find item currently hovering over\n\n\n        if (translateY <= lastTranslate && translateY < 0 || translateY > lastTranslate && translateY > 0) {\n          hoveringIndex = i;\n        }\n\n        n.style.transform = `translate(0, ${translateY}px`;\n        lastTranslate = translateY;\n      });\n    }\n\n    const {\n      source,\n      dest\n    } = getSourceAndDest();\n    onDragMove(source, dest);\n  };\n\n  const onDragStart = ev => {\n    // Default HTML drag and drop doesn't allow us to change what the thing\n    // being dragged looks like. Because of this we'll use prevent the default\n    // and use `mouseMove` and `mouseUp` instead\n    ev.preventDefault();\n\n    if (isDragging) {\n      // still in animation\n      return;\n    } // Cache droppable and draggable nodes and their bounding rects\n\n\n    const dragging = ev.target;\n    const rect = dragging.getBoundingClientRect();\n    const droppableNodes = Array.from(document.querySelectorAll(`[data-pf-droppable=\"${zone}\"]`));\n    const droppableItems = droppableNodes.reduce((acc, cur) => {\n      cur.classList.add(styles.modifiers.dragging);\n      const draggableNodes = Array.from(cur.querySelectorAll(`[data-pf-draggable-zone=\"${zone}\"]`));\n      const isDraggingHost = cur.contains(dragging);\n\n      if (isDraggingHost) {\n        index = draggableNodes.indexOf(dragging);\n      }\n\n      const droppableItem = {\n        node: cur,\n        rect: cur.getBoundingClientRect(),\n        isDraggingHost,\n        // We don't want styles to apply to the left behind div in onMouseMoveWhileDragging\n        draggableNodes: draggableNodes.map(node => node === dragging ? node.cloneNode(false) : node),\n        draggableNodesRects: draggableNodes.map(node => node.getBoundingClientRect())\n      };\n      acc.push(droppableItem);\n      return acc;\n    }, []);\n\n    if (!onDrag({\n      droppableId,\n      index\n    })) {\n      // Consumer disallowed drag\n      return;\n    } // Set initial style so future style mods take effect\n\n\n    style = Object.assign(Object.assign({}, style), {\n      top: rect.y,\n      left: rect.x,\n      width: rect.width,\n      height: rect.height,\n      '--pf-c-draggable--m-dragging--BackgroundColor': getInheritedBackgroundColor(dragging),\n      position: 'fixed',\n      zIndex: 5000\n    });\n    setStyle(style); // Store event details\n\n    startX = ev.pageX;\n    startY = ev.pageY;\n    startYOffset = startY - rect.y;\n    setIsDragging(true);\n\n    mouseMoveListener = ev => onMouseMoveWhileDragging(ev, droppableItems, rect);\n\n    mouseUpListener = () => onMouseUpWhileDragging(droppableItems);\n\n    document.addEventListener('mousemove', mouseMoveListener);\n    document.addEventListener('mouseup', mouseUpListener); // Comment out this line to debug while dragging by right clicking\n    // document.addEventListener('contextmenu', mouseUpListener);\n  };\n\n  const childProps = Object.assign({\n    'data-pf-draggable-zone': isDragging ? null : zone,\n    draggable: true,\n    className: css(styles.draggable, isDragging && styles.modifiers.dragging, !isValidDrag && styles.modifiers.dragOutside, className),\n    onDragStart,\n    onTransitionEnd,\n    style\n  }, props);\n  return React.createElement(React.Fragment, null, isDragging && React.createElement(\"div\", Object.assign({\n    draggable: true\n  }, props, {\n    style: Object.assign(Object.assign({}, styleProp), {\n      visibility: 'hidden'\n    })\n  }), children), hasNoWrapper ? React.cloneElement(children, childProps) : React.createElement(\"div\", Object.assign({}, childProps), children));\n};\nDraggable.displayName = 'Draggable';","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,GAAT,QAAoB,0BAApB;AACA,OAAOC,MAAP,MAAmB,4DAAnB;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,eAAT,QAAgC,YAAhC,C,CAWA;;AACA,SAASC,oBAAT,GAA6B;EAC3B,MAAMC,GAAG,GAAGC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAZ;EACAD,QAAQ,CAACE,IAAT,CAAcC,WAAd,CAA0BJ,GAA1B;EACA,MAAMK,EAAE,GAAGC,MAAM,CAACC,gBAAP,CAAwBP,GAAxB,EAA6BQ,eAAxC;EACAP,QAAQ,CAACE,IAAT,CAAcM,WAAd,CAA0BT,GAA1B;EACA,OAAOK,EAAP;AACD;;AAED,SAASK,2BAAT,CAAqCC,EAArC,EAAoD;EAClD,MAAMC,YAAY,GAAGb,oBAAoB,EAAzC;EACA,MAAMS,eAAe,GAAGF,MAAM,CAACC,gBAAP,CAAwBI,EAAxB,EAA4BH,eAApD;;EAEA,IAAIA,eAAe,KAAKI,YAAxB,EAAsC;IACpC,OAAOJ,eAAP;EACD,CAFD,MAEO,IAAI,CAACG,EAAE,CAACE,aAAR,EAAuB;IAC5B,OAAOD,YAAP;EACD;;EAED,OAAOF,2BAA2B,CAACC,EAAE,CAACE,aAAJ,CAAlC;AACD;;AAED,SAASC,cAAT,CAAwBC,IAAxB,EAAyC;EACvC,IAAIA,IAAI,CAACC,YAAL,CAAkB,UAAlB,MAAkC,MAAtC,EAA8C;IAC5C;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,QAAL,CAAcC,MAAlC,EAA0CF,CAAC,EAA3C,EAA+C;MAC7C,MAAMG,KAAK,GAAGL,IAAI,CAACG,QAAL,CAAcD,CAAd,CAAd;;MACA,IAAIG,KAAK,CAACJ,YAAN,CAAmB,UAAnB,MAAmC,MAAvC,EAA+C;QAC7CD,IAAI,CAACN,WAAL,CAAiBW,KAAjB;QACAL,IAAI,CAACM,YAAL,CAAkB,UAAlB,EAA8B,OAA9B;QACA;MACD;IACF;EACF;AACF,C,CAUD;;;AACA,SAASC,kBAAT,CAA4BC,aAA5B,EAAwD;EACtDT,cAAc,CAACS,aAAa,CAACR,IAAf,CAAd;EACAQ,aAAa,CAACR,IAAd,CAAmBS,SAAnB,CAA6BC,MAA7B,CAAoC7B,MAAM,CAAC8B,SAAP,CAAiBC,QAArD;EACAJ,aAAa,CAACR,IAAd,CAAmBS,SAAnB,CAA6BC,MAA7B,CAAoC7B,MAAM,CAAC8B,SAAP,CAAiBE,WAArD;EACAL,aAAa,CAACM,cAAd,CAA6BC,OAA7B,CAAqC,CAACC,CAAD,EAAId,CAAJ,KAAS;IAC5Cc,CAAC,CAACC,KAAF,CAAQC,SAAR,GAAoB,EAApB;IACAF,CAAC,CAACC,KAAF,CAAQE,UAAR,GAAqB,EAArB;IACAX,aAAa,CAACY,mBAAd,CAAkClB,CAAlC,IAAuCc,CAAC,CAACK,qBAAF,EAAvC;EACD,CAJD;AAKD;;AAED,SAASC,QAAT,CAAkBC,EAAlB,EAAkCC,IAAlC,EAA+C;EAC7C,OACED,EAAE,CAACE,OAAH,GAAaD,IAAI,CAACE,CAAlB,IAAuBH,EAAE,CAACE,OAAH,GAAaD,IAAI,CAACE,CAAL,GAASF,IAAI,CAACG,KAAlD,IAA2DJ,EAAE,CAACK,OAAH,GAAaJ,IAAI,CAACK,CAA7E,IAAkFN,EAAE,CAACK,OAAH,GAAaJ,IAAI,CAACK,CAAL,GAASL,IAAI,CAACM,MAD/G;AAGD;;AAED,OAAO,MAAMC,SAAS,GAA6CC,EAAD,IAM7C;MAN8C;IACjEC,SADiE;IAEjE9B,QAFiE;IAGjEc,KAAK,EAAEiB,SAAS,GAAG,EAH8C;IAIjEC,YAAY,GAAG;EAJkD,IAI7CH;MACjBI,KAAK,cALyD,kDAKzD;EAER;;;EACA,IAAI,CAACnB,KAAD,EAAQoB,QAAR,IAAoB1D,KAAK,CAAC2D,QAAN,CAAeJ,SAAf,CAAxB;EACA;;EACA,MAAM,CAACK,UAAD,EAAaC,aAAb,IAA8B7D,KAAK,CAAC2D,QAAN,CAAe,KAAf,CAApC;EACA,MAAM,CAACG,WAAD,EAAcC,cAAd,IAAgC/D,KAAK,CAAC2D,QAAN,CAAe,IAAf,CAAtC;EACA,MAAM;IAAEK,IAAF;IAAQC;EAAR,IAAwBjE,KAAK,CAACkE,UAAN,CAAiB/D,gBAAjB,CAA9B;EACA,MAAM;IAAEgE,MAAF;IAAUC,UAAV;IAAsBC;EAAtB,IAAiCrE,KAAK,CAACkE,UAAN,CAAiB9D,eAAjB,CAAvC,CAPmB,CAQnB;EACA;;EACA,IAAIkE,MAAM,GAAG,CAAb;EACA,IAAIC,MAAM,GAAG,CAAb;EACA,IAAIC,KAAK,GAAW,IAApB,CAZmB,CAYO;;EAC1B,IAAIC,iBAAJ;EACA,IAAIC,aAAa,GAAW,IAA5B;EACA,IAAIC,iBAAJ;EACA,IAAIC,eAAJ,CAhBmB,CAiBnB;;EACA,IAAIC,YAAY,GAAG,CAAnB,CAlBmB,CAoBnB;;EACA,MAAMC,eAAe,GAAIC,GAAD,IAA4C;IAClE,IAAInB,UAAJ,EAAgB;MACdC,aAAa,CAAC,KAAD,CAAb;MACAH,QAAQ,CAACH,SAAD,CAAR;IACD;EACF,CALD;;EAOA,SAASyB,gBAAT,GAAyB;IACvB,MAAMC,mBAAmB,GAAGR,iBAAiB,GAAGA,iBAAiB,CAACnD,YAAlB,CAA+B,qBAA/B,CAAH,GAA2D,IAAxG;IACA,MAAM4D,MAAM,GAAG;MACbjB,WADa;MAEbO;IAFa,CAAf;IAIA,MAAMW,IAAI,GACRF,mBAAmB,KAAK,IAAxB,IAAgCP,aAAa,KAAK,IAAlD,GACI;MACET,WAAW,EAAEgB,mBADf;MAEET,KAAK,EAAEE;IAFT,CADJ,GAKIU,SANN;IAOA,OAAO;MAAEF,MAAF;MAAUC,IAAV;MAAgBF;IAAhB,CAAP;EACD;;EAED,MAAMI,sBAAsB,GAAIC,cAAD,IAAoC;IACjEA,cAAc,CAAClD,OAAf,CAAuBR,kBAAvB;IACArB,QAAQ,CAACgF,mBAAT,CAA6B,WAA7B,EAA0CZ,iBAA1C;IACApE,QAAQ,CAACgF,mBAAT,CAA6B,SAA7B,EAAwCX,eAAxC;IACArE,QAAQ,CAACgF,mBAAT,CAA6B,aAA7B,EAA4CX,eAA5C;IACA,MAAM;MAAEM,MAAF;MAAUC,IAAV;MAAgBF;IAAhB,IAAwCD,gBAAgB,EAA9D;IACA,MAAMQ,iBAAiB,GAAGnB,MAAM,CAACa,MAAD,EAASC,IAAT,CAAhC;;IACA,IAAIK,iBAAiB,IAAIvB,WAAW,KAAKgB,mBAAzC,EAA8D;MAC5DpB,aAAa,CAAC,KAAD,CAAb;MACAH,QAAQ,CAACH,SAAD,CAAR;IACD,CAHD,MAGO,IAAI,CAACiC,iBAAL,EAAwB;MAC7B;MACA9B,QAAQ,iCACHpB,KADG,GACE;QACRE,UAAU,EAAE,gDADJ;QAERD,SAAS,EAAE,EAFH;QAGRkD,UAAU,EAAElC,SAAS,CAACkC,UAHd;QAIRC,SAAS,EAAEnC,SAAS,CAACmC;MAJb,CADF,EAAR;IAOD;EACF,CApBD,CA5CmB,CAkEnB;;;EACA,MAAMC,wBAAwB,GAAG,CAAC/C,EAAD,EAAiB0C,cAAjB,EAAkDM,YAAlD,KAA2E;IAC1G;IACAnB,iBAAiB,GAAG,IAApB;IACAa,cAAc,CAAClD,OAAf,CAAuBP,aAAa,IAAG;MACrC,MAAM;QAAER,IAAF;QAAQwB,IAAR;QAAcgD,cAAd;QAA8B1D,cAA9B;QAA8CM;MAA9C,IAAsEZ,aAA5E;;MACA,IAAIc,QAAQ,CAACC,EAAD,EAAKC,IAAL,CAAZ,EAAwB;QACtB;QACAxB,IAAI,CAACS,SAAL,CAAeC,MAAf,CAAsB7B,MAAM,CAAC8B,SAAP,CAAiBE,WAAvC;QACAuC,iBAAiB,GAAGpD,IAApB,CAHsB,CAItB;;QACA,IAAIA,IAAI,CAACC,YAAL,CAAkB,UAAlB,MAAkC,MAAlC,IAA4C,CAACuE,cAAjD,EAAiE;UAC/D,MAAMC,QAAQ,GAAGvF,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAjB;UACAsF,QAAQ,CAACnE,YAAT,CAAsB,UAAtB,EAAkC,MAAlC,EAF+D,CAEpB;;UAC3C,IAAIoE,WAAW,GAAG,CAAC,CAAnB;;UACA,KAAK,IAAIxE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,cAAc,CAACV,MAAnC,EAA2CF,CAAC,EAA5C,EAAgD;YAC9C,MAAMyE,SAAS,GAAGvD,mBAAmB,CAAClB,CAAD,CAArC;YACA,MAAM0E,MAAM,GAAG1E,CAAC,KAAKY,cAAc,CAACV,MAAf,GAAwB,CAA7C;YACA,MAAMyE,aAAa,GAAGF,SAAS,CAAC9C,CAAV,IAAeqB,MAAM,GAAGM,YAA9C;;YACA,IAAI,CAACqB,aAAa,IAAID,MAAlB,KAA6BF,WAAW,KAAK,CAAC,CAAlD,EAAqD;cACnD,IAAIE,MAAM,IAAI,CAACC,aAAf,EAA8B;gBAC5B/D,cAAc,CAACZ,CAAD,CAAd,CAAkB4E,KAAlB,CAAwBL,QAAxB;cACD,CAFD,MAEO;gBACL3D,cAAc,CAACZ,CAAD,CAAd,CAAkB6E,MAAlB,CAAyBN,QAAzB;cACD;;cACDA,QAAQ,CAACxD,KAAT,CAAea,MAAf,GAAwB,GAAGyC,YAAY,CAACzC,MAAM,IAA9C;cACA2C,QAAQ,CAACxD,KAAT,CAAeU,KAAf,GAAuB,GAAG4C,YAAY,CAAC5C,KAAK,IAA5C;cACA3B,IAAI,CAACM,YAAL,CAAkB,UAAlB,EAA8B,MAA9B,EARmD,CAQZ;;cACvCoE,WAAW,GAAGxE,CAAd;YACD;;YACD,IAAIwE,WAAW,KAAK,CAAC,CAArB,EAAwB;cACtBC,SAAS,CAAC9C,CAAV,IAAe0C,YAAY,CAACzC,MAA5B;YACD;UACF,CAtB8D,CAuB/D;;;UACAhB,cAAc,CAACkE,MAAf,CAAsBN,WAAtB,EAAmC,CAAnC,EAAsCD,QAAtC;UACArD,mBAAmB,CAAC4D,MAApB,CAA2BN,WAA3B,EAAwC,CAAxC,EAA2CH,YAA3C,EAzB+D,CA0B/D;;UACA/C,IAAI,CAACM,MAAL,IAAeyC,YAAY,CAACzC,MAA5B;QACD;MACF,CAlCD,MAkCO;QACLvB,kBAAkB,CAACC,aAAD,CAAlB;QACAR,IAAI,CAACS,SAAL,CAAewE,GAAf,CAAmBpG,MAAM,CAAC8B,SAAP,CAAiBC,QAApC;QACAZ,IAAI,CAACS,SAAL,CAAewE,GAAf,CAAmBpG,MAAM,CAAC8B,SAAP,CAAiBE,WAApC;MACD;IACF,CAzCD,EAH0G,CA8C1G;;IACAwB,QAAQ,iCACHpB,KADG,GACE;MACRC,SAAS,EAAE,aAAaK,EAAE,CAAC2D,KAAH,GAAWjC,MAAM,OAAO1B,EAAE,CAAC4D,KAAH,GAAWjC,MAAM;IADzD,CADF,EAAR;IAIAR,cAAc,CAAC0C,OAAO,CAAChC,iBAAD,CAAR,CAAd,CAnD0G,CAqD1G;;IACAC,aAAa,GAAG,IAAhB;;IACA,IAAID,iBAAJ,EAAuB;MACrB,MAAM;QAAEtC,cAAF;QAAkBM;MAAlB,IAA0C6C,cAAc,CAACoB,IAAf,CAAoBC,IAAI,IAAIA,IAAI,CAACtF,IAAL,KAAcoD,iBAA1C,CAAhD;MACA,IAAImC,aAAa,GAAG,CAApB;MACAzE,cAAc,CAACC,OAAf,CAAuB,CAACC,CAAD,EAAId,CAAJ,KAAS;QAC9Bc,CAAC,CAACC,KAAF,CAAQE,UAAR,GAAqB,gDAArB;QACA,MAAMK,IAAI,GAAGJ,mBAAmB,CAAClB,CAAD,CAAhC;QACA,MAAMsF,OAAO,GAAGhE,IAAI,CAACK,CAAL,GAASL,IAAI,CAACM,MAAL,GAAc,CAAvC;QACA,IAAI2D,UAAU,GAAG,CAAjB,CAJ8B,CAK9B;;QACA,IAAIvC,MAAM,GAAGsC,OAAT,IAAoBjE,EAAE,CAAC4D,KAAH,IAAYZ,YAAY,CAACzC,MAAb,GAAsB0B,YAAlC,IAAkDgC,OAA1E,EAAmF;UACjFC,UAAU,IAAIlB,YAAY,CAACzC,MAA3B;QACD,CAFD,MAEO,IAAIoB,MAAM,IAAIsC,OAAV,IAAqBjE,EAAE,CAAC4D,KAAH,GAAW3B,YAAX,IAA2BgC,OAApD,EAA6D;UAClEC,UAAU,IAAIlB,YAAY,CAACzC,MAA3B;QACD,CAV6B,CAW9B;;;QACA,IAAK2D,UAAU,IAAIF,aAAd,IAA+BE,UAAU,GAAG,CAA7C,IAAoDA,UAAU,GAAGF,aAAb,IAA8BE,UAAU,GAAG,CAAnG,EAAuG;UACrGpC,aAAa,GAAGnD,CAAhB;QACD;;QACDc,CAAC,CAACC,KAAF,CAAQC,SAAR,GAAoB,gBAAgBuE,UAAU,IAA9C;QACAF,aAAa,GAAGE,UAAhB;MACD,CAjBD;IAkBD;;IAED,MAAM;MAAE5B,MAAF;MAAUC;IAAV,IAAmBH,gBAAgB,EAAzC;IACAZ,UAAU,CAACc,MAAD,EAASC,IAAT,CAAV;EACD,CAhFD;;EAkFA,MAAM4B,WAAW,GAAInE,EAAD,IAAqC;IACvD;IACA;IACA;IACAA,EAAE,CAACoE,cAAH;;IACA,IAAIpD,UAAJ,EAAgB;MACd;MACA;IACD,CARsD,CAUvD;;;IACA,MAAM3B,QAAQ,GAAGW,EAAE,CAACqE,MAApB;IACA,MAAMpE,IAAI,GAAGZ,QAAQ,CAACS,qBAAT,EAAb;IACA,MAAMwE,cAAc,GAAGC,KAAK,CAACC,IAAN,CAAW7G,QAAQ,CAAC8G,gBAAT,CAA0B,uBAAuBrD,IAAI,IAArD,CAAX,CAAvB;IACA,MAAMsB,cAAc,GAAG4B,cAAc,CAACI,MAAf,CAAsB,CAACC,GAAD,EAAMC,GAAN,KAAa;MACxDA,GAAG,CAAC1F,SAAJ,CAAcwE,GAAd,CAAkBpG,MAAM,CAAC8B,SAAP,CAAiBC,QAAnC;MACA,MAAME,cAAc,GAAGgF,KAAK,CAACC,IAAN,CAAWI,GAAG,CAACH,gBAAJ,CAAqB,4BAA4BrD,IAAI,IAArD,CAAX,CAAvB;MACA,MAAM6B,cAAc,GAAG2B,GAAG,CAACC,QAAJ,CAAaxF,QAAb,CAAvB;;MACA,IAAI4D,cAAJ,EAAoB;QAClBrB,KAAK,GAAGrC,cAAc,CAACuF,OAAf,CAAuBzF,QAAvB,CAAR;MACD;;MACD,MAAMJ,aAAa,GAAG;QACpBR,IAAI,EAAEmG,GADc;QAEpB3E,IAAI,EAAE2E,GAAG,CAAC9E,qBAAJ,EAFc;QAGpBmD,cAHoB;QAIpB;QACA1D,cAAc,EAAEA,cAAc,CAACwF,GAAf,CAAmBtG,IAAI,IAAKA,IAAI,KAAKY,QAAT,GAAoBZ,IAAI,CAACuG,SAAL,CAAe,KAAf,CAApB,GAA4CvG,IAAxE,CALI;QAMpBoB,mBAAmB,EAAEN,cAAc,CAACwF,GAAf,CAAmBtG,IAAI,IAAIA,IAAI,CAACqB,qBAAL,EAA3B;MAND,CAAtB;MAQA6E,GAAG,CAACM,IAAJ,CAAShG,aAAT;MACA,OAAO0F,GAAP;IACD,CAjBsB,EAiBpB,EAjBoB,CAAvB;;IAmBA,IAAI,CAACpD,MAAM,CAAC;MAAEF,WAAF;MAAeO;IAAf,CAAD,CAAX,EAAqC;MACnC;MACA;IACD,CApCsD,CAsCvD;;;IACAlC,KAAK,GAAGwF,gCACHxF,KADG,GACE;MACRyF,GAAG,EAAElF,IAAI,CAACK,CADF;MAER8E,IAAI,EAAEnF,IAAI,CAACE,CAFH;MAGRC,KAAK,EAAEH,IAAI,CAACG,KAHJ;MAIRG,MAAM,EAAEN,IAAI,CAACM,MAJL;MAKR,iDAAiDnC,2BAA2B,CAACiB,QAAD,CALpE;MAMRgG,QAAQ,EAAE,OANF;MAORC,MAAM,EAAE;IAPA,CADF,CAAR;IAUAxE,QAAQ,CAACpB,KAAD,CAAR,CAjDuD,CAkDvD;;IACAgC,MAAM,GAAG1B,EAAE,CAAC2D,KAAZ;IACAhC,MAAM,GAAG3B,EAAE,CAAC4D,KAAZ;IACA3B,YAAY,GAAGN,MAAM,GAAG1B,IAAI,CAACK,CAA7B;IACAW,aAAa,CAAC,IAAD,CAAb;;IACAc,iBAAiB,GAAG/B,EAAE,IAAI+C,wBAAwB,CAAC/C,EAAD,EAAmB0C,cAAnB,EAAmCzC,IAAnC,CAAlD;;IACA+B,eAAe,GAAG,MAAMS,sBAAsB,CAACC,cAAD,CAA9C;;IACA/E,QAAQ,CAAC4H,gBAAT,CAA0B,WAA1B,EAAuCxD,iBAAvC;IACApE,QAAQ,CAAC4H,gBAAT,CAA0B,SAA1B,EAAqCvD,eAArC,EA1DuD,CA2DvD;IACA;EACD,CA7DD;;EA+DA,MAAMwD,UAAU;IACd,0BAA0BxE,UAAU,GAAG,IAAH,GAAUI,IADhC;IAEdqE,SAAS,EAAE,IAFG;IAGd/E,SAAS,EAAErD,GAAG,CACZC,MAAM,CAACmI,SADK,EAEZzE,UAAU,IAAI1D,MAAM,CAAC8B,SAAP,CAAiBC,QAFnB,EAGZ,CAAC6B,WAAD,IAAgB5D,MAAM,CAAC8B,SAAP,CAAiBE,WAHrB,EAIZoB,SAJY,CAHA;IASdyD,WATc;IAUdjC,eAVc;IAWdxC;EAXc,GAYXmB,KAZW,CAAhB;EAeA,OACEzD,oBAACA,KAAK,CAACsI,QAAP,EAAe,IAAf,EAEG1E,UAAU,IACT5D;IAAKqI,SAAS;EAAd,GAAmB5E,KAAnB,EAAwB;IAAEnB,KAAK,kCAAOiB,SAAP,GAAgB;MAAEgF,UAAU,EAAE;IAAd,CAAhB;EAAP,CAAxB,GACG/G,QADH,CAHJ,EAOGgC,YAAY,GACXxD,KAAK,CAACwI,YAAN,CAAmBhH,QAAnB,EAAmD4G,UAAnD,CADW,GAGXpI,6CAASoI,UAAT,GAAsB5G,QAAtB,CAVJ,CADF;AAeD,CAxPM;AAyPP4B,SAAS,CAACqF,WAAV,GAAwB,WAAxB","names":["React","css","styles","DroppableContext","DragDropContext","getDefaultBackground","div","document","createElement","head","appendChild","bg","window","getComputedStyle","backgroundColor","removeChild","getInheritedBackgroundColor","el","defaultStyle","parentElement","removeBlankDiv","node","getAttribute","i","children","length","child","setAttribute","resetDroppableItem","droppableItem","classList","remove","modifiers","dragging","dragOutside","draggableNodes","forEach","n","style","transform","transition","draggableNodesRects","getBoundingClientRect","overlaps","ev","rect","clientX","x","width","clientY","y","height","Draggable","_a","className","styleProp","hasNoWrapper","props","setStyle","useState","isDragging","setIsDragging","isValidDrag","setIsValidDrag","zone","droppableId","useContext","onDrag","onDragMove","onDrop","startX","startY","index","hoveringDroppable","hoveringIndex","mouseMoveListener","mouseUpListener","startYOffset","onTransitionEnd","_ev","getSourceAndDest","hoveringDroppableId","source","dest","undefined","onMouseUpWhileDragging","droppableItems","removeEventListener","consumerReordered","background","boxShadow","onMouseMoveWhileDragging","blankDivRect","isDraggingHost","blankDiv","blankDivPos","childRect","isLast","startOverlaps","after","before","splice","add","pageX","pageY","Boolean","find","item","lastTranslate","halfway","translateY","onDragStart","preventDefault","target","droppableNodes","Array","from","querySelectorAll","reduce","acc","cur","contains","indexOf","map","cloneNode","push","Object","top","left","position","zIndex","addEventListener","childProps","draggable","Fragment","visibility","cloneElement","displayName"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/components/DragDrop/Draggable.tsx"],"sourcesContent":["import * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport styles from '@patternfly/react-styles/css/components/DragDrop/drag-drop';\nimport { DroppableContext } from './DroppableContext';\nimport { DragDropContext } from './DragDrop';\n\nexport interface DraggableProps extends React.HTMLProps<HTMLDivElement> {\n  /** Content rendered inside DragDrop */\n  children?: React.ReactNode;\n  /** Don't wrap the component in a div. Requires passing a single child. */\n  hasNoWrapper?: boolean;\n  /** Class to add to outer div */\n  className?: string;\n}\n\n// Browsers really like being different from each other.\nfunction getDefaultBackground() {\n  const div = document.createElement('div');\n  document.head.appendChild(div);\n  const bg = window.getComputedStyle(div).backgroundColor;\n  document.head.removeChild(div);\n  return bg;\n}\n\nfunction getInheritedBackgroundColor(el: HTMLElement): string {\n  const defaultStyle = getDefaultBackground();\n  const backgroundColor = window.getComputedStyle(el).backgroundColor;\n\n  if (backgroundColor !== defaultStyle) {\n    return backgroundColor;\n  } else if (!el.parentElement) {\n    return defaultStyle;\n  }\n\n  return getInheritedBackgroundColor(el.parentElement);\n}\n\nfunction removeBlankDiv(node: HTMLElement) {\n  if (node.getAttribute('blankDiv') === 'true') {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      if (child.getAttribute('blankDiv') === 'true') {\n        node.removeChild(child);\n        node.setAttribute('blankDiv', 'false');\n        break;\n      }\n    }\n  }\n}\n\ninterface DroppableItem {\n  node: HTMLElement;\n  rect: DOMRect;\n  isDraggingHost: boolean;\n  draggableNodes: HTMLElement[];\n  draggableNodesRects: DOMRect[];\n}\n\n// Reset per-element state\nfunction resetDroppableItem(droppableItem: DroppableItem) {\n  removeBlankDiv(droppableItem.node);\n  droppableItem.node.classList.remove(styles.modifiers.dragging);\n  droppableItem.node.classList.remove(styles.modifiers.dragOutside);\n  droppableItem.draggableNodes.forEach((n, i) => {\n    n.style.transform = '';\n    n.style.transition = '';\n    droppableItem.draggableNodesRects[i] = n.getBoundingClientRect();\n  });\n}\n\nfunction overlaps(ev: MouseEvent, rect: DOMRect) {\n  return (\n    ev.clientX > rect.x && ev.clientX < rect.x + rect.width && ev.clientY > rect.y && ev.clientY < rect.y + rect.height\n  );\n}\n\nexport const Draggable: React.FunctionComponent<DraggableProps> = ({\n  className,\n  children,\n  style: styleProp = {},\n  hasNoWrapper = false,\n  ...props\n}: DraggableProps) => {\n  /* eslint-disable prefer-const */\n  let [style, setStyle] = React.useState(styleProp);\n  /* eslint-enable prefer-const */\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [isValidDrag, setIsValidDrag] = React.useState(true);\n  const { zone, droppableId } = React.useContext(DroppableContext);\n  const { onDrag, onDragMove, onDrop } = React.useContext(DragDropContext);\n  // Some state is better just to leave as vars passed around between various callbacks\n  // You can only drag around one item at a time anyways...\n  let startX = 0;\n  let startY = 0;\n  let index: number = null; // Index of this draggable\n  let hoveringDroppable: HTMLElement;\n  let hoveringIndex: number = null;\n  let mouseMoveListener: EventListener;\n  let mouseUpListener: EventListener;\n  // Makes it so dragging the _bottom_ of the item over the halfway of another moves it\n  let startYOffset = 0;\n\n  // After item returning to where it started animation completes\n  const onTransitionEnd = (_ev: React.TransitionEvent<HTMLElement>) => {\n    if (isDragging) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    }\n  };\n\n  function getSourceAndDest() {\n    const hoveringDroppableId = hoveringDroppable ? hoveringDroppable.getAttribute('data-pf-droppableid') : null;\n    const source = {\n      droppableId,\n      index\n    };\n    const dest =\n      hoveringDroppableId !== null && hoveringIndex !== null\n        ? {\n            droppableId: hoveringDroppableId,\n            index: hoveringIndex\n          }\n        : undefined;\n    return { source, dest, hoveringDroppableId };\n  }\n\n  const onMouseUpWhileDragging = (droppableItems: DroppableItem[]) => {\n    droppableItems.forEach(resetDroppableItem);\n    document.removeEventListener('mousemove', mouseMoveListener);\n    document.removeEventListener('mouseup', mouseUpListener);\n    document.removeEventListener('contextmenu', mouseUpListener);\n    const { source, dest, hoveringDroppableId } = getSourceAndDest();\n    const consumerReordered = onDrop(source, dest);\n    if (consumerReordered && droppableId === hoveringDroppableId) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    } else if (!consumerReordered) {\n      // Animate item returning to where it started\n      setStyle({\n        ...style,\n        transition: 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s',\n        transform: '',\n        background: styleProp.background,\n        boxShadow: styleProp.boxShadow\n      });\n    }\n  };\n\n  // This is where the magic happens\n  const onMouseMoveWhileDragging = (ev: MouseEvent, droppableItems: DroppableItem[], blankDivRect: DOMRect) => {\n    // Compute each time what droppable node we are hovering over\n    hoveringDroppable = null;\n    droppableItems.forEach(droppableItem => {\n      const { node, rect, isDraggingHost, draggableNodes, draggableNodesRects } = droppableItem;\n      if (overlaps(ev, rect)) {\n        // Add valid dropzone style\n        node.classList.remove(styles.modifiers.dragOutside);\n        hoveringDroppable = node;\n        // Check if we need to add a blank div row\n        if (node.getAttribute('blankDiv') !== 'true' && !isDraggingHost) {\n          const blankDiv = document.createElement('div');\n          blankDiv.setAttribute('blankDiv', 'true'); // Makes removing easier\n          let blankDivPos = -1;\n          for (let i = 0; i < draggableNodes.length; i++) {\n            const childRect = draggableNodesRects[i];\n            const isLast = i === draggableNodes.length - 1;\n            const startOverlaps = childRect.y >= startY - startYOffset;\n            if ((startOverlaps || isLast) && blankDivPos === -1) {\n              if (isLast && !startOverlaps) {\n                draggableNodes[i].after(blankDiv);\n              } else {\n                draggableNodes[i].before(blankDiv);\n              }\n              blankDiv.style.height = `${blankDivRect.height}px`;\n              blankDiv.style.width = `${blankDivRect.width}px`;\n              node.setAttribute('blankDiv', 'true'); // Makes removing easier\n              blankDivPos = i;\n            }\n            if (blankDivPos !== -1) {\n              childRect.y += blankDivRect.height;\n            }\n          }\n          // Insert so drag + drop behavior matches single-list case\n          draggableNodes.splice(blankDivPos, 0, blankDiv);\n          draggableNodesRects.splice(blankDivPos, 0, blankDivRect);\n          // Extend hitbox of droppable zone\n          rect.height += blankDivRect.height;\n        }\n      } else {\n        resetDroppableItem(droppableItem);\n        node.classList.add(styles.modifiers.dragging);\n        node.classList.add(styles.modifiers.dragOutside);\n      }\n    });\n\n    // Move hovering draggable and style it based on cursor position\n    setStyle({\n      ...style,\n      transform: `translate(${ev.pageX - startX}px, ${ev.pageY - startY}px)`\n    });\n    setIsValidDrag(Boolean(hoveringDroppable));\n\n    // Iterate through sibling draggable nodes to reposition them and store correct hoveringIndex for onDrop\n    hoveringIndex = null;\n    if (hoveringDroppable) {\n      const { draggableNodes, draggableNodesRects } = droppableItems.find(item => item.node === hoveringDroppable);\n      let lastTranslate = 0;\n      draggableNodes.forEach((n, i) => {\n        n.style.transition = 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s';\n        const rect = draggableNodesRects[i];\n        const halfway = rect.y + rect.height / 2;\n        let translateY = 0;\n        // Use offset for more interactive translations\n        if (startY < halfway && ev.pageY + (blankDivRect.height - startYOffset) > halfway) {\n          translateY -= blankDivRect.height;\n        } else if (startY >= halfway && ev.pageY - startYOffset <= halfway) {\n          translateY += blankDivRect.height;\n        }\n        // Clever way to find item currently hovering over\n        if ((translateY <= lastTranslate && translateY < 0) || (translateY > lastTranslate && translateY > 0)) {\n          hoveringIndex = i;\n        }\n        n.style.transform = `translate(0, ${translateY}px`;\n        lastTranslate = translateY;\n      });\n    }\n\n    const { source, dest } = getSourceAndDest();\n    onDragMove(source, dest);\n  };\n\n  const onDragStart = (ev: React.DragEvent<HTMLElement>) => {\n    // Default HTML drag and drop doesn't allow us to change what the thing\n    // being dragged looks like. Because of this we'll use prevent the default\n    // and use `mouseMove` and `mouseUp` instead\n    ev.preventDefault();\n    if (isDragging) {\n      // still in animation\n      return;\n    }\n\n    // Cache droppable and draggable nodes and their bounding rects\n    const dragging = ev.target as HTMLElement;\n    const rect = dragging.getBoundingClientRect();\n    const droppableNodes = Array.from(document.querySelectorAll(`[data-pf-droppable=\"${zone}\"]`)) as HTMLElement[];\n    const droppableItems = droppableNodes.reduce((acc, cur) => {\n      cur.classList.add(styles.modifiers.dragging);\n      const draggableNodes = Array.from(cur.querySelectorAll(`[data-pf-draggable-zone=\"${zone}\"]`)) as HTMLElement[];\n      const isDraggingHost = cur.contains(dragging);\n      if (isDraggingHost) {\n        index = draggableNodes.indexOf(dragging);\n      }\n      const droppableItem = {\n        node: cur,\n        rect: cur.getBoundingClientRect(),\n        isDraggingHost,\n        // We don't want styles to apply to the left behind div in onMouseMoveWhileDragging\n        draggableNodes: draggableNodes.map(node => (node === dragging ? node.cloneNode(false) : node)),\n        draggableNodesRects: draggableNodes.map(node => node.getBoundingClientRect())\n      };\n      acc.push(droppableItem);\n      return acc;\n    }, []);\n\n    if (!onDrag({ droppableId, index })) {\n      // Consumer disallowed drag\n      return;\n    }\n\n    // Set initial style so future style mods take effect\n    style = {\n      ...style,\n      top: rect.y,\n      left: rect.x,\n      width: rect.width,\n      height: rect.height,\n      '--pf-c-draggable--m-dragging--BackgroundColor': getInheritedBackgroundColor(dragging),\n      position: 'fixed',\n      zIndex: 5000\n    } as any;\n    setStyle(style);\n    // Store event details\n    startX = ev.pageX;\n    startY = ev.pageY;\n    startYOffset = startY - rect.y;\n    setIsDragging(true);\n    mouseMoveListener = ev => onMouseMoveWhileDragging(ev as MouseEvent, droppableItems, rect);\n    mouseUpListener = () => onMouseUpWhileDragging(droppableItems);\n    document.addEventListener('mousemove', mouseMoveListener);\n    document.addEventListener('mouseup', mouseUpListener);\n    // Comment out this line to debug while dragging by right clicking\n    // document.addEventListener('contextmenu', mouseUpListener);\n  };\n\n  const childProps = {\n    'data-pf-draggable-zone': isDragging ? null : zone,\n    draggable: true,\n    className: css(\n      styles.draggable,\n      isDragging && styles.modifiers.dragging,\n      !isValidDrag && styles.modifiers.dragOutside,\n      className\n    ),\n    onDragStart,\n    onTransitionEnd,\n    style,\n    ...props\n  };\n\n  return (\n    <React.Fragment>\n      {/* Leave behind blank spot per-design */}\n      {isDragging && (\n        <div draggable {...props} style={{ ...styleProp, visibility: 'hidden' }}>\n          {children}\n        </div>\n      )}\n      {hasNoWrapper ? (\n        React.cloneElement(children as React.ReactElement, childProps)\n      ) : (\n        <div {...childProps}>{children}</div>\n      )}\n    </React.Fragment>\n  );\n};\nDraggable.displayName = 'Draggable';\n"]},"metadata":{},"sourceType":"module"}