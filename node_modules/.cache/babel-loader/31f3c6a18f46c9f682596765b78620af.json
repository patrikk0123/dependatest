{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { getUniqueId } from '../../helpers';\nimport { flattenTree, flattenTreeWithFolders, filterFolders, filterTreeItems, filterTreeItemsWithoutFolders, filterRestTreeItems } from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\nexport class DualListSelector extends React.Component {\n  constructor(props) {\n    super(props);\n    this.addAllButtonRef = React.createRef();\n    this.addSelectedButtonRef = React.createRef();\n    this.removeSelectedButtonRef = React.createRef();\n    this.removeAllButtonRef = React.createRef();\n\n    this.onFilterUpdate = (newFilteredOptions, paneType, isSearchReset) => {\n      const {\n        isTree\n      } = this.props;\n\n      if (paneType === 'available') {\n        if (isSearchReset) {\n          this.setState({\n            availableFilteredOptions: null,\n            availableTreeFilteredOptions: null\n          });\n          return;\n        }\n\n        if (isTree) {\n          this.setState({\n            availableTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            availableFilteredOptions: newFilteredOptions\n          });\n        }\n      } else if (paneType === 'chosen') {\n        if (isSearchReset) {\n          this.setState({\n            chosenFilteredOptions: null,\n            chosenTreeFilteredOptions: null\n          });\n          return;\n        }\n\n        if (isTree) {\n          this.setState({\n            chosenTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            chosenFilteredOptions: newFilteredOptions\n          });\n        }\n      }\n    };\n\n    this.addAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n        prevState.availableOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n\n    this.addAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.availableTreeFilteredOptions || flattenTreeWithFolders(prevState.availableOptions);\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(movedOptions);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n\n    this.addSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        prevState.availableOptions.forEach((value, index) => {\n          if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          availableOptions: newAvailable\n        };\n      });\n    };\n\n    this.addTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected available nodes from current available nodes\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.availableTreeOptionsChecked)); // Get next chosen options from current + new nodes and remap from base\n\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n\n    this.removeAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n        prevState.chosenOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n\n    this.removeAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.chosenTreeFilteredOptions || flattenTreeWithFolders(prevState.chosenOptions);\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(movedOptions);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n\n    this.removeSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        prevState.chosenOptions.forEach((value, index) => {\n          if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          availableOptions: newAvailable\n        };\n      });\n    };\n\n    this.removeTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected chosen nodes from current chosen nodes\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.chosenTreeOptionsChecked)); // Get next chosen options from current and remap from base\n\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n\n    this.onOptionSelect = (e, index, isChosen,\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    id, itemData, parentData\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    ) => {\n      this.setState(prevState => {\n        const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n        let updatedArray = null;\n\n        if (originalArray.indexOf(index) !== -1) {\n          updatedArray = originalArray.filter(value => value !== index);\n        } else {\n          updatedArray = [...originalArray, index];\n        }\n\n        return {\n          chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n          availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n        };\n      });\n      this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n    };\n\n    this.isChecked = (treeItem, isChosen) => isChosen ? this.state.chosenTreeOptionsChecked.includes(treeItem.id) : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n\n    this.areAllDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n\n    this.areSomeDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n\n    this.mapChecked = (item, isChosen) => {\n      const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n      item.isChecked = false;\n\n      if (hasCheck) {\n        item.isChecked = true;\n      } else {\n        const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n\n        if (hasPartialCheck) {\n          item.isChecked = null;\n        }\n      }\n\n      if (item.children) {\n        return Object.assign(Object.assign({}, item), {\n          children: item.children.map(child => this.mapChecked(child, isChosen))\n        });\n      }\n\n      return item;\n    };\n\n    this.onTreeOptionCheck = (evt, isChecked, itemData, isChosen) => {\n      const {\n        availableOptions,\n        availableTreeFilteredOptions,\n        chosenOptions,\n        chosenTreeFilteredOptions\n      } = this.state;\n      let panelOptions;\n\n      if (isChosen) {\n        if (chosenTreeFilteredOptions) {\n          panelOptions = chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, chosenTreeFilteredOptions));\n        } else {\n          panelOptions = chosenOptions;\n        }\n      } else {\n        if (availableTreeFilteredOptions) {\n          panelOptions = availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, availableTreeFilteredOptions));\n        } else {\n          panelOptions = availableOptions;\n        }\n      }\n\n      const checkedOptionTree = panelOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItems(item, [itemData.id]));\n      const flatTree = flattenTreeWithFolders(checkedOptionTree);\n      const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n      let updatedChecked = [];\n\n      if (isChecked) {\n        updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n      } else {\n        updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n      }\n\n      this.setState(prevState => ({\n        availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n        chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n      }), () => {\n        this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n      });\n    };\n\n    this.state = {\n      availableOptions: [...this.props.availableOptions],\n      availableOptionsSelected: [],\n      availableFilteredOptions: null,\n      availableTreeFilteredOptions: null,\n      chosenOptions: [...this.props.chosenOptions],\n      chosenOptionsSelected: [],\n      chosenFilteredOptions: null,\n      chosenTreeFilteredOptions: null,\n      availableTreeOptionsChecked: [],\n      chosenTreeOptionsChecked: []\n    };\n  } // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n\n\n  createMergedCopy() {\n    const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n    const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n    return this.props.isTree ? Object.values(copyOfAvailable.concat(copyOfChosen).reduce((mapObj, item) => {\n      const key = item.id;\n\n      if (mapObj[key]) {\n        // If map already has an item ID, add the dupe ID's children to the existing map\n        mapObj[key].children.push(...item.children);\n      } else {\n        // Else clone the item data\n        mapObj[key] = Object.assign({}, item);\n      }\n\n      return mapObj;\n    }, {})) : null;\n  }\n\n  componentDidUpdate() {\n    if (JSON.stringify(this.props.availableOptions) !== JSON.stringify(this.state.availableOptions) || JSON.stringify(this.props.chosenOptions) !== JSON.stringify(this.state.chosenOptions)) {\n      this.setState({\n        availableOptions: [...this.props.availableOptions],\n        chosenOptions: [...this.props.chosenOptions]\n      });\n    }\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      availableOptionsTitle,\n      availableOptionsActions,\n      availableOptionsSearchAriaLabel,\n      className,\n      children,\n      chosenOptionsTitle,\n      chosenOptionsActions,\n      chosenOptionsSearchAriaLabel,\n      filterOption,\n      isSearchable,\n      chosenOptionsStatus,\n      availableOptionsStatus,\n      controlsAriaLabel,\n      addAllAriaLabel,\n      addSelectedAriaLabel,\n      removeSelectedAriaLabel,\n      removeAllAriaLabel,\n\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      availableOptions: consumerPassedAvailableOptions,\n      chosenOptions: consumerPassedChosenOptions,\n      removeSelected,\n      addAll,\n      removeAll,\n      addSelected,\n      onListChange,\n      onAvailableOptionsSearchInputChanged,\n      onChosenOptionsSearchInputChanged,\n      onOptionSelect,\n      onOptionCheck,\n      id,\n      isTree,\n      isDisabled,\n      addAllTooltip,\n      addAllTooltipProps,\n      addSelectedTooltip,\n      addSelectedTooltipProps,\n      removeAllTooltip,\n      removeAllTooltipProps,\n      removeSelectedTooltip,\n      removeSelectedTooltipProps\n    } = _a,\n          props = __rest(_a, [\"availableOptionsTitle\", \"availableOptionsActions\", \"availableOptionsSearchAriaLabel\", \"className\", \"children\", \"chosenOptionsTitle\", \"chosenOptionsActions\", \"chosenOptionsSearchAriaLabel\", \"filterOption\", \"isSearchable\", \"chosenOptionsStatus\", \"availableOptionsStatus\", \"controlsAriaLabel\", \"addAllAriaLabel\", \"addSelectedAriaLabel\", \"removeSelectedAriaLabel\", \"removeAllAriaLabel\", \"availableOptions\", \"chosenOptions\", \"removeSelected\", \"addAll\", \"removeAll\", \"addSelected\", \"onListChange\", \"onAvailableOptionsSearchInputChanged\", \"onChosenOptionsSearchInputChanged\", \"onOptionSelect\", \"onOptionCheck\", \"id\", \"isTree\", \"isDisabled\", \"addAllTooltip\", \"addAllTooltipProps\", \"addSelectedTooltip\", \"addSelectedTooltipProps\", \"removeAllTooltip\", \"removeAllTooltipProps\", \"removeSelectedTooltip\", \"removeSelectedTooltipProps\"]);\n\n    const {\n      availableOptions,\n      chosenOptions,\n      chosenOptionsSelected,\n      availableOptionsSelected,\n      chosenTreeOptionsChecked,\n      availableTreeOptionsChecked\n    } = this.state;\n    const availableOptionsStatusToDisplay = availableOptionsStatus || (isTree ? `${filterFolders(availableOptions, availableTreeOptionsChecked).length} of ${flattenTree(availableOptions).length} items selected` : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n    const chosenOptionsStatusToDisplay = chosenOptionsStatus || (isTree ? `${filterFolders(chosenOptions, chosenTreeOptionsChecked).length} of ${flattenTree(chosenOptions).length} items selected` : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n    const available = isTree ? availableOptions.map(item => this.mapChecked(item, false)) : availableOptions;\n    const chosen = isTree ? chosenOptions.map(item => this.mapChecked(item, true)) : chosenOptions;\n    return React.createElement(DualListSelectorContext.Provider, {\n      value: {\n        isTree\n      }\n    }, React.createElement(\"div\", Object.assign({\n      className: css(styles.dualListSelector, className),\n      id: id\n    }, props), children === '' ? React.createElement(React.Fragment, null, React.createElement(DualListSelectorPane, {\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: availableOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onAvailableOptionsSearchInputChanged,\n      status: availableOptionsStatusToDisplay,\n      title: availableOptionsTitle,\n      options: available,\n      selectedOptions: isTree ? availableTreeOptionsChecked : availableOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false),\n      actions: availableOptionsActions,\n      id: `${id}-available-pane`,\n      isDisabled: isDisabled\n    }), React.createElement(DualListSelectorControlsWrapper, {\n      \"aria-label\": controlsAriaLabel\n    }, React.createElement(DualListSelectorControl, {\n      isDisabled: (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) || isDisabled,\n      onClick: isTree ? this.addTreeSelected : this.addSelected,\n      ref: this.addSelectedButtonRef,\n      \"aria-label\": addSelectedAriaLabel,\n      tooltipContent: addSelectedTooltip,\n      tooltipProps: addSelectedTooltipProps\n    }, React.createElement(AngleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: availableOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.addAllTreeVisible : this.addAllVisible,\n      ref: this.addAllButtonRef,\n      \"aria-label\": addAllAriaLabel,\n      tooltipContent: addAllTooltip,\n      tooltipProps: addAllTooltipProps\n    }, React.createElement(AngleDoubleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: chosenOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.removeAllTreeVisible : this.removeAllVisible,\n      \"aria-label\": removeAllAriaLabel,\n      ref: this.removeAllButtonRef,\n      tooltipContent: removeAllTooltip,\n      tooltipProps: removeAllTooltipProps\n    }, React.createElement(AngleDoubleLeftIcon, null)), React.createElement(DualListSelectorControl, {\n      onClick: isTree ? this.removeTreeSelected : this.removeSelected,\n      isDisabled: (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) || isDisabled,\n      ref: this.removeSelectedButtonRef,\n      \"aria-label\": removeSelectedAriaLabel,\n      tooltipContent: removeSelectedTooltip,\n      tooltipProps: removeSelectedTooltipProps\n    }, React.createElement(AngleLeftIcon, null))), React.createElement(DualListSelectorPane, {\n      isChosen: true,\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: chosenOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onChosenOptionsSearchInputChanged,\n      title: chosenOptionsTitle,\n      status: chosenOptionsStatusToDisplay,\n      options: chosen,\n      selectedOptions: isTree ? chosenTreeOptionsChecked : chosenOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true),\n      actions: chosenOptionsActions,\n      id: `${id}-chosen-pane`,\n      isDisabled: isDisabled\n    })) : children));\n  }\n\n}\nDualListSelector.displayName = 'DualListSelector';\nDualListSelector.defaultProps = {\n  children: '',\n  availableOptions: [],\n  availableOptionsTitle: 'Available options',\n  availableOptionsSearchAriaLabel: 'Available search input',\n  chosenOptions: [],\n  chosenOptionsTitle: 'Chosen options',\n  chosenOptionsSearchAriaLabel: 'Chosen search input',\n  id: getUniqueId('dual-list-selector'),\n  controlsAriaLabel: 'Selector controls',\n  addAllAriaLabel: 'Add all',\n  addSelectedAriaLabel: 'Add selected',\n  removeSelectedAriaLabel: 'Remove selected',\n  removeAllAriaLabel: 'Remove all',\n  isTree: false,\n  isDisabled: false\n};","map":{"version":3,"mappings":"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","names":["React","styles","css","AngleDoubleLeftIcon","AngleLeftIcon","AngleDoubleRightIcon","AngleRightIcon","DualListSelectorPane","getUniqueId","flattenTree","flattenTreeWithFolders","filterFolders","filterTreeItems","filterTreeItemsWithoutFolders","filterRestTreeItems","DualListSelectorControlsWrapper","DualListSelectorControl","DualListSelectorContext","DualListSelector","Component","constructor","props","createRef","newFilteredOptions","paneType","isSearchReset","isTree","setState","availableFilteredOptions","availableTreeFilteredOptions","chosenFilteredOptions","chosenTreeFilteredOptions","prevState","itemsToRemove","newAvailable","movedOptions","availableOptions","forEach","value","indexOf","push","newChosen","chosenOptions","addAll","onListChange","chosenOptionsSelected","availableOptionsSelected","map","opt","Object","assign","filter","item","currChosen","nextChosenOptions","concat","createMergedCopy","availableTreeOptionsChecked","chosenTreeOptionsChecked","index","addSelected","removeAll","currAvailable","nextAvailableOptions","removeSelected","e","isChosen","id","itemData","parentData","originalArray","updatedArray","onOptionSelect","treeItem","state","includes","children","every","child","areAllDescendantsChecked","isChecked","some","areSomeDescendantsChecked","hasCheck","hasPartialCheck","mapChecked","evt","panelOptions","checkedOptionTree","flatTree","prevChecked","updatedChecked","onOptionCheck","copyOfAvailable","JSON","parse","stringify","copyOfChosen","values","reduce","mapObj","key","componentDidUpdate","render","_a","availableOptionsTitle","availableOptionsActions","availableOptionsSearchAriaLabel","className","chosenOptionsTitle","chosenOptionsActions","chosenOptionsSearchAriaLabel","filterOption","isSearchable","chosenOptionsStatus","availableOptionsStatus","controlsAriaLabel","addAllAriaLabel","addSelectedAriaLabel","removeSelectedAriaLabel","removeAllAriaLabel","consumerPassedAvailableOptions","consumerPassedChosenOptions","onAvailableOptionsSearchInputChanged","onChosenOptionsSearchInputChanged","isDisabled","addAllTooltip","addAllTooltipProps","addSelectedTooltip","addSelectedTooltipProps","removeAllTooltip","removeAllTooltipProps","removeSelectedTooltip","removeSelectedTooltipProps","availableOptionsStatusToDisplay","length","chosenOptionsStatusToDisplay","available","chosen","Provider","dualListSelector","onFilterUpdate","searchInputAriaLabel","onSearchInputChanged","status","title","options","selectedOptions","onTreeOptionCheck","actions","onClick","addTreeSelected","ref","addSelectedButtonRef","tooltipContent","tooltipProps","addAllTreeVisible","addAllVisible","addAllButtonRef","removeAllTreeVisible","removeAllVisible","removeAllButtonRef","removeTreeSelected","removeSelectedButtonRef"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/components/DualListSelector/DualListSelector.tsx"],"sourcesContent":["import * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { getUniqueId, PickOptional } from '../../helpers';\nimport { DualListSelectorTreeItemData } from './DualListSelectorTree';\nimport {\n  flattenTree,\n  flattenTreeWithFolders,\n  filterFolders,\n  filterTreeItems,\n  filterTreeItemsWithoutFolders,\n  filterRestTreeItems\n} from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\n\nexport interface DualListSelectorProps {\n  /** Additional classes applied to the dual list selector. */\n  className?: string;\n  /** Id of the dual list selector. */\n  id?: string;\n  /** Flag indicating if the dual list selector uses trees instead of simple lists */\n  isTree?: boolean;\n  /** Flag indicating if the dual list selector is in a disabled state */\n  isDisabled?: boolean;\n  /** Content to be rendered in the dual list selector. Panes & controls will not be built dynamically when children are provided. */\n  children?: React.ReactNode;\n  /** Title applied to the dynamically built available options pane. */\n  availableOptionsTitle?: string;\n  /** Options to display in the dynamically built available options pane. When using trees, the options should be in the DualListSelectorTreeItemData[] format. */\n  availableOptions?: React.ReactNode[] | DualListSelectorTreeItemData[];\n  /** Status message to display above the dynamically built available options pane. */\n  availableOptionsStatus?: string;\n  /** Actions to be displayed above the dynamically built available options pane. */\n  availableOptionsActions?: React.ReactNode[];\n  /** Title applied to the dynamically built chosen options pane. */\n  chosenOptionsTitle?: string;\n  /** Options to display in the dynamically built chosen options pane. When using trees, the options should be in the DualListSelectorTreeItemData[] format. */\n  chosenOptions?: React.ReactNode[] | DualListSelectorTreeItemData[];\n  /** Status message to display above the dynamically built chosen options pane.*/\n  chosenOptionsStatus?: string;\n  /** Actions to be displayed above the dynamically built chosen options pane. */\n  chosenOptionsActions?: React.ReactNode[];\n  /** Accessible label for the dynamically built controls between the two panes. */\n  controlsAriaLabel?: string;\n  /** Optional callback for the dynamically built add selected button */\n  addSelected?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built add selected button */\n  addSelectedAriaLabel?: string;\n  /** Tooltip content for the dynamically built add selected button */\n  addSelectedTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built add selected tooltip */\n  addSelectedTooltipProps?: any;\n  /** Callback fired every time dynamically built options are chosen or removed */\n  onListChange?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Optional callback for the dynamically built add all button */\n  addAll?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built add all button */\n  addAllAriaLabel?: string;\n  /** Tooltip content for the dynamically built add all button */\n  addAllTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built add all tooltip */\n  addAllTooltipProps?: any;\n  /** Optional callback for the dynamically built remove selected button */\n  removeSelected?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built remove selected button */\n  removeSelectedAriaLabel?: string;\n  /** Tooltip content for the dynamically built remove selected button */\n  removeSelectedTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built remove selected tooltip  */\n  removeSelectedTooltipProps?: any;\n  /** Optional callback for the dynamically built remove all button */\n  removeAll?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built remove all button */\n  removeAllAriaLabel?: string;\n  /** Tooltip content for the dynamically built remove all button */\n  removeAllTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built remove all tooltip */\n  removeAllTooltipProps?: any;\n  /** Optional callback fired when a dynamically built option is selected */\n  onOptionSelect?: (\n    e: React.MouseEvent | React.ChangeEvent | React.KeyboardEvent,\n    index: number,\n    isChosen: boolean,\n    id: string,\n    itemData: any,\n    parentData: any\n  ) => void;\n  /** Optional callback fired when a dynamically built option is checked */\n  onOptionCheck?: (\n    e: React.MouseEvent | React.ChangeEvent<HTMLInputElement> | React.KeyboardEvent,\n    checked: boolean,\n    checkedId: string,\n    newCheckedItems: string[]\n  ) => void;\n  /** Flag indicating a search bar should be included above both the dynamically built available and chosen panes. */\n  isSearchable?: boolean;\n  /** Accessible label for the search input on the dynamically built available options pane. */\n  availableOptionsSearchAriaLabel?: string;\n  /** A callback for when the search input value for the dynamically built available options changes. */\n  onAvailableOptionsSearchInputChanged?: (value: string, event: React.FormEvent<HTMLInputElement>) => void;\n  /** Accessible label for the search input on the dynamically built chosen options pane. */\n  chosenOptionsSearchAriaLabel?: string;\n  /** A callback for when the search input value for the dynamically built chosen options changes. */\n  onChosenOptionsSearchInputChanged?: (value: string, event: React.FormEvent<HTMLInputElement>) => void;\n  /** Optional filter function for custom filtering based on search string. Used with a dynamically built search input. */\n  filterOption?: (option: React.ReactNode, input: string) => boolean;\n}\n\ninterface DualListSelectorState {\n  availableOptions: React.ReactNode[];\n  availableOptionsSelected: number[];\n  availableFilteredOptions: React.ReactNode[];\n  chosenOptions: React.ReactNode[];\n  chosenOptionsSelected: number[];\n  chosenFilteredOptions: React.ReactNode[];\n  availableTreeFilteredOptions: string[];\n  availableTreeOptionsChecked: string[];\n  chosenTreeOptionsChecked: string[];\n  chosenTreeFilteredOptions: string[];\n}\n\nexport class DualListSelector extends React.Component<DualListSelectorProps, DualListSelectorState> {\n  static displayName = 'DualListSelector';\n  private addAllButtonRef = React.createRef<HTMLButtonElement>();\n  private addSelectedButtonRef = React.createRef<HTMLButtonElement>();\n  private removeSelectedButtonRef = React.createRef<HTMLButtonElement>();\n  private removeAllButtonRef = React.createRef<HTMLButtonElement>();\n  static defaultProps: PickOptional<DualListSelectorProps> = {\n    children: '',\n    availableOptions: [] as React.ReactNode[],\n    availableOptionsTitle: 'Available options',\n    availableOptionsSearchAriaLabel: 'Available search input',\n    chosenOptions: [] as React.ReactNode[],\n    chosenOptionsTitle: 'Chosen options',\n    chosenOptionsSearchAriaLabel: 'Chosen search input',\n    id: getUniqueId('dual-list-selector'),\n    controlsAriaLabel: 'Selector controls',\n    addAllAriaLabel: 'Add all',\n    addSelectedAriaLabel: 'Add selected',\n    removeSelectedAriaLabel: 'Remove selected',\n    removeAllAriaLabel: 'Remove all',\n    isTree: false,\n    isDisabled: false\n  };\n\n  // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n  private createMergedCopy() {\n    const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n    const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n\n    return this.props.isTree\n      ? Object.values(\n          (copyOfAvailable as DualListSelectorTreeItemData[])\n            .concat(copyOfChosen as DualListSelectorTreeItemData[])\n            .reduce((mapObj: any, item: DualListSelectorTreeItemData) => {\n              const key = item.id;\n              if (mapObj[key]) {\n                // If map already has an item ID, add the dupe ID's children to the existing map\n                mapObj[key].children.push(...item.children);\n              } else {\n                // Else clone the item data\n                mapObj[key] = { ...item };\n              }\n              return mapObj;\n            }, {})\n        )\n      : null;\n  }\n\n  constructor(props: DualListSelectorProps) {\n    super(props);\n    this.state = {\n      availableOptions: [...this.props.availableOptions],\n      availableOptionsSelected: [],\n      availableFilteredOptions: null,\n      availableTreeFilteredOptions: null,\n      chosenOptions: [...this.props.chosenOptions],\n      chosenOptionsSelected: [],\n      chosenFilteredOptions: null,\n      chosenTreeFilteredOptions: null,\n      availableTreeOptionsChecked: [],\n      chosenTreeOptionsChecked: []\n    };\n  }\n\n  componentDidUpdate() {\n    if (\n      JSON.stringify(this.props.availableOptions) !== JSON.stringify(this.state.availableOptions) ||\n      JSON.stringify(this.props.chosenOptions) !== JSON.stringify(this.state.chosenOptions)\n    ) {\n      this.setState({\n        availableOptions: [...this.props.availableOptions],\n        chosenOptions: [...this.props.chosenOptions]\n      });\n    }\n  }\n\n  onFilterUpdate = (newFilteredOptions: React.ReactNode[], paneType: string, isSearchReset: boolean) => {\n    const { isTree } = this.props;\n    if (paneType === 'available') {\n      if (isSearchReset) {\n        this.setState({\n          availableFilteredOptions: null,\n          availableTreeFilteredOptions: null\n        });\n        return;\n      }\n      if (isTree) {\n        this.setState({\n          availableTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions as DualListSelectorTreeItemData[])\n        });\n      } else {\n        this.setState({\n          availableFilteredOptions: newFilteredOptions as React.ReactNode[]\n        });\n      }\n    } else if (paneType === 'chosen') {\n      if (isSearchReset) {\n        this.setState({\n          chosenFilteredOptions: null,\n          chosenTreeFilteredOptions: null\n        });\n        return;\n      }\n      if (isTree) {\n        this.setState({\n          chosenTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions as DualListSelectorTreeItemData[])\n        });\n      } else {\n        this.setState({\n          chosenFilteredOptions: newFilteredOptions as React.ReactNode[]\n        });\n      }\n    }\n  };\n\n  addAllVisible = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newAvailable = [] as React.ReactNode[];\n      const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n      prevState.availableOptions.forEach(value => {\n        if (movedOptions.indexOf(value) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newAvailable.push(value);\n        }\n      });\n\n      const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n      this.props.addAll && this.props.addAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        availableOptions: newAvailable,\n        chosenOptionsSelected: [],\n        availableOptionsSelected: []\n      };\n    });\n  };\n\n  addAllTreeVisible = () => {\n    this.setState(prevState => {\n      const movedOptions =\n        prevState.availableTreeFilteredOptions ||\n        flattenTreeWithFolders(prevState.availableOptions as DualListSelectorTreeItemData[]);\n      const newAvailable = prevState.availableOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterRestTreeItems(item as DualListSelectorTreeItemData, movedOptions));\n\n      const currChosen = flattenTree(prevState.chosenOptions as DualListSelectorTreeItemData[]);\n      const nextChosenOptions = currChosen.concat(movedOptions);\n      const newChosen = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextChosenOptions));\n\n      this.props.addAll && this.props.addAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        chosenFilteredOptions: newChosen,\n        availableOptions: newAvailable,\n        availableFilteredOptions: newAvailable,\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: []\n      };\n    });\n  };\n\n  addSelected = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newAvailable = [] as React.ReactNode[];\n      prevState.availableOptions.forEach((value, index) => {\n        if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newAvailable.push(value);\n        }\n      });\n\n      const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n      this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptionsSelected: [],\n        availableOptionsSelected: [],\n        chosenOptions: newChosen,\n        availableOptions: newAvailable\n      };\n    });\n  };\n\n  addTreeSelected = () => {\n    this.setState(prevState => {\n      // Remove selected available nodes from current available nodes\n      const newAvailable = prevState.availableOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterRestTreeItems(item as DualListSelectorTreeItemData, prevState.availableTreeOptionsChecked)\n        );\n\n      // Get next chosen options from current + new nodes and remap from base\n      const currChosen = flattenTree(prevState.chosenOptions as DualListSelectorTreeItemData[]);\n      const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n      const newChosen = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextChosenOptions));\n\n      this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: [],\n        availableOptions: newAvailable,\n        chosenOptions: newChosen\n      };\n    });\n  };\n\n  removeAllVisible = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newChosen = [] as React.ReactNode[];\n      const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n      prevState.chosenOptions.forEach(value => {\n        if (movedOptions.indexOf(value) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newChosen.push(value);\n        }\n      });\n\n      const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n      this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        availableOptions: newAvailable,\n        chosenOptionsSelected: [],\n        availableOptionsSelected: []\n      };\n    });\n  };\n\n  removeAllTreeVisible = () => {\n    this.setState(prevState => {\n      const movedOptions =\n        prevState.chosenTreeFilteredOptions ||\n        flattenTreeWithFolders(prevState.chosenOptions as DualListSelectorTreeItemData[]);\n\n      const newChosen = prevState.chosenOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterRestTreeItems(item as DualListSelectorTreeItemData, movedOptions));\n      const currAvailable = flattenTree(prevState.availableOptions as DualListSelectorTreeItemData[]);\n      const nextAvailableOptions = currAvailable.concat(movedOptions);\n      const newAvailable = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextAvailableOptions));\n\n      this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        availableOptions: newAvailable,\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: []\n      };\n    });\n  };\n\n  removeSelected = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newChosen = [] as React.ReactNode[];\n      prevState.chosenOptions.forEach((value, index) => {\n        if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newChosen.push(value);\n        }\n      });\n\n      const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n      this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptionsSelected: [],\n        availableOptionsSelected: [],\n        chosenOptions: newChosen,\n        availableOptions: newAvailable\n      };\n    });\n  };\n\n  removeTreeSelected = () => {\n    this.setState(prevState => {\n      // Remove selected chosen nodes from current chosen nodes\n      const newChosen = prevState.chosenOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterRestTreeItems(item as DualListSelectorTreeItemData, prevState.chosenTreeOptionsChecked));\n\n      // Get next chosen options from current and remap from base\n      const currAvailable = flattenTree(prevState.availableOptions as DualListSelectorTreeItemData[]);\n      const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n      const newAvailable = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextAvailableOptions));\n\n      this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: [],\n        availableOptions: newAvailable,\n        chosenOptions: newChosen\n      };\n    });\n  };\n\n  onOptionSelect = (\n    e: React.MouseEvent | React.ChangeEvent | React.KeyboardEvent,\n    index: number,\n    isChosen: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    id?: string,\n    itemData?: any,\n    parentData?: any\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ) => {\n    this.setState(prevState => {\n      const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n\n      let updatedArray = null;\n      if (originalArray.indexOf(index) !== -1) {\n        updatedArray = originalArray.filter(value => value !== index);\n      } else {\n        updatedArray = [...originalArray, index];\n      }\n\n      return {\n        chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n        availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n      };\n    });\n\n    this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n  };\n\n  isChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean) =>\n    isChosen\n      ? this.state.chosenTreeOptionsChecked.includes(treeItem.id)\n      : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n  areAllDescendantsChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean): boolean =>\n    treeItem.children\n      ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen))\n      : this.isChecked(treeItem, isChosen);\n  areSomeDescendantsChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean): boolean =>\n    treeItem.children\n      ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen))\n      : this.isChecked(treeItem, isChosen);\n\n  mapChecked = (item: DualListSelectorTreeItemData, isChosen: boolean): DualListSelectorTreeItemData => {\n    const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n    item.isChecked = false;\n\n    if (hasCheck) {\n      item.isChecked = true;\n    } else {\n      const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n      if (hasPartialCheck) {\n        item.isChecked = null;\n      }\n    }\n\n    if (item.children) {\n      return {\n        ...item,\n        children: item.children.map(child => this.mapChecked(child, isChosen))\n      };\n    }\n    return item;\n  };\n\n  onTreeOptionCheck = (\n    evt: React.MouseEvent | React.ChangeEvent<HTMLInputElement> | React.KeyboardEvent,\n    isChecked: boolean,\n    itemData: DualListSelectorTreeItemData,\n    isChosen: boolean\n  ) => {\n    const { availableOptions, availableTreeFilteredOptions, chosenOptions, chosenTreeFilteredOptions } = this.state;\n    let panelOptions;\n    if (isChosen) {\n      if (chosenTreeFilteredOptions) {\n        panelOptions = chosenOptions\n          .map(opt => Object.assign({}, opt))\n          .filter(item =>\n            filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, chosenTreeFilteredOptions)\n          );\n      } else {\n        panelOptions = chosenOptions;\n      }\n    } else {\n      if (availableTreeFilteredOptions) {\n        panelOptions = availableOptions\n          .map(opt => Object.assign({}, opt))\n          .filter(item =>\n            filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, availableTreeFilteredOptions)\n          );\n      } else {\n        panelOptions = availableOptions;\n      }\n    }\n    const checkedOptionTree = panelOptions\n      .map(opt => Object.assign({}, opt))\n      .filter(item => filterTreeItems(item as DualListSelectorTreeItemData, [itemData.id]));\n    const flatTree = flattenTreeWithFolders(checkedOptionTree as DualListSelectorTreeItemData[]);\n\n    const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n    let updatedChecked = [] as string[];\n    if (isChecked) {\n      updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n    } else {\n      updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n    }\n\n    this.setState(\n      prevState => ({\n        availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n        chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n      }),\n      () => {\n        this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n      }\n    );\n  };\n\n  render() {\n    const {\n      availableOptionsTitle,\n      availableOptionsActions,\n      availableOptionsSearchAriaLabel,\n      className,\n      children,\n      chosenOptionsTitle,\n      chosenOptionsActions,\n      chosenOptionsSearchAriaLabel,\n      filterOption,\n      isSearchable,\n      chosenOptionsStatus,\n      availableOptionsStatus,\n      controlsAriaLabel,\n      addAllAriaLabel,\n      addSelectedAriaLabel,\n      removeSelectedAriaLabel,\n      removeAllAriaLabel,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      availableOptions: consumerPassedAvailableOptions,\n      chosenOptions: consumerPassedChosenOptions,\n      removeSelected,\n      addAll,\n      removeAll,\n      addSelected,\n      onListChange,\n      onAvailableOptionsSearchInputChanged,\n      onChosenOptionsSearchInputChanged,\n      onOptionSelect,\n      onOptionCheck,\n      id,\n      isTree,\n      isDisabled,\n      addAllTooltip,\n      addAllTooltipProps,\n      addSelectedTooltip,\n      addSelectedTooltipProps,\n      removeAllTooltip,\n      removeAllTooltipProps,\n      removeSelectedTooltip,\n      removeSelectedTooltipProps,\n      ...props\n    } = this.props;\n    const {\n      availableOptions,\n      chosenOptions,\n      chosenOptionsSelected,\n      availableOptionsSelected,\n      chosenTreeOptionsChecked,\n      availableTreeOptionsChecked\n    } = this.state;\n    const availableOptionsStatusToDisplay =\n      availableOptionsStatus ||\n      (isTree\n        ? `${\n            filterFolders(availableOptions as DualListSelectorTreeItemData[], availableTreeOptionsChecked).length\n          } of ${flattenTree(availableOptions as DualListSelectorTreeItemData[]).length} items selected`\n        : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n    const chosenOptionsStatusToDisplay =\n      chosenOptionsStatus ||\n      (isTree\n        ? `${filterFolders(chosenOptions as DualListSelectorTreeItemData[], chosenTreeOptionsChecked).length} of ${\n            flattenTree(chosenOptions as DualListSelectorTreeItemData[]).length\n          } items selected`\n        : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n\n    const available = isTree\n      ? availableOptions.map(item => this.mapChecked(item as DualListSelectorTreeItemData, false))\n      : availableOptions;\n    const chosen = isTree\n      ? chosenOptions.map(item => this.mapChecked(item as DualListSelectorTreeItemData, true))\n      : chosenOptions;\n\n    return (\n      <DualListSelectorContext.Provider value={{ isTree }}>\n        <div className={css(styles.dualListSelector, className)} id={id} {...props}>\n          {children === '' ? (\n            <>\n              <DualListSelectorPane\n                isSearchable={isSearchable}\n                onFilterUpdate={this.onFilterUpdate}\n                searchInputAriaLabel={availableOptionsSearchAriaLabel}\n                filterOption={filterOption}\n                onSearchInputChanged={onAvailableOptionsSearchInputChanged}\n                status={availableOptionsStatusToDisplay}\n                title={availableOptionsTitle}\n                options={available}\n                selectedOptions={isTree ? availableTreeOptionsChecked : availableOptionsSelected}\n                onOptionSelect={this.onOptionSelect}\n                onOptionCheck={(e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false)}\n                actions={availableOptionsActions}\n                id={`${id}-available-pane`}\n                isDisabled={isDisabled}\n              />\n              <DualListSelectorControlsWrapper aria-label={controlsAriaLabel}>\n                <DualListSelectorControl\n                  isDisabled={\n                    (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) ||\n                    isDisabled\n                  }\n                  onClick={isTree ? this.addTreeSelected : this.addSelected}\n                  ref={this.addSelectedButtonRef}\n                  aria-label={addSelectedAriaLabel}\n                  tooltipContent={addSelectedTooltip}\n                  tooltipProps={addSelectedTooltipProps}\n                >\n                  <AngleRightIcon />\n                </DualListSelectorControl>\n                <DualListSelectorControl\n                  isDisabled={availableOptions.length === 0 || isDisabled}\n                  onClick={isTree ? this.addAllTreeVisible : this.addAllVisible}\n                  ref={this.addAllButtonRef}\n                  aria-label={addAllAriaLabel}\n                  tooltipContent={addAllTooltip}\n                  tooltipProps={addAllTooltipProps}\n                >\n                  <AngleDoubleRightIcon />\n                </DualListSelectorControl>\n                <DualListSelectorControl\n                  isDisabled={chosenOptions.length === 0 || isDisabled}\n                  onClick={isTree ? this.removeAllTreeVisible : this.removeAllVisible}\n                  aria-label={removeAllAriaLabel}\n                  ref={this.removeAllButtonRef}\n                  tooltipContent={removeAllTooltip}\n                  tooltipProps={removeAllTooltipProps}\n                >\n                  <AngleDoubleLeftIcon />\n                </DualListSelectorControl>\n                <DualListSelectorControl\n                  onClick={isTree ? this.removeTreeSelected : this.removeSelected}\n                  isDisabled={\n                    (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) || isDisabled\n                  }\n                  ref={this.removeSelectedButtonRef}\n                  aria-label={removeSelectedAriaLabel}\n                  tooltipContent={removeSelectedTooltip}\n                  tooltipProps={removeSelectedTooltipProps}\n                >\n                  <AngleLeftIcon />\n                </DualListSelectorControl>\n              </DualListSelectorControlsWrapper>\n              <DualListSelectorPane\n                isChosen\n                isSearchable={isSearchable}\n                onFilterUpdate={this.onFilterUpdate}\n                searchInputAriaLabel={chosenOptionsSearchAriaLabel}\n                filterOption={filterOption}\n                onSearchInputChanged={onChosenOptionsSearchInputChanged}\n                title={chosenOptionsTitle}\n                status={chosenOptionsStatusToDisplay}\n                options={chosen}\n                selectedOptions={isTree ? chosenTreeOptionsChecked : chosenOptionsSelected}\n                onOptionSelect={this.onOptionSelect}\n                onOptionCheck={(e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true)}\n                actions={chosenOptionsActions}\n                id={`${id}-chosen-pane`}\n                isDisabled={isDisabled}\n              />\n            </>\n          ) : (\n            children\n          )}\n        </div>\n      </DualListSelectorContext.Provider>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}