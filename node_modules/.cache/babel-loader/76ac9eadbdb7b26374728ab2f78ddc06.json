{"ast":null,"code":"// @ts-nocheck\nimport getWindow from './getWindow';\nimport getNodeName from './getNodeName';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\nimport isTableElement from './isTableElement';\nimport getParentNode from './getParentNode';\nimport getDocumentElement from './getDocumentElement';\n/**\n * @param element\n */\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  var offsetParent = element.offsetParent;\n\n  if (offsetParent) {\n    var html = getDocumentElement(offsetParent);\n\n    if (getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && getComputedStyle(html).position !== 'static') {\n      return html;\n    }\n  }\n\n  return offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n/**\n * @param element\n */\n\n\nfunction getContainingBlock(element) {\n  var currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.willChange && css.willChange !== 'auto') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n/**\n * @param element\n */\n\n\nexport default function getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}","map":{"version":3,"mappings":"AAAA;AACA,OAAOA,SAAP,MAAsB,aAAtB;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,SAASC,aAAT,QAA8B,cAA9B;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,kBAAP,MAA+B,sBAA/B;AAEA;;;;AAGA,SAASC,mBAAT,CAA6BC,OAA7B,EAA6C;EAC3C,IACE,CAACL,aAAa,CAACK,OAAD,CAAd,IAA2B;EAC3BN,gBAAgB,CAACM,OAAD,CAAhB,CAA0BC,QAA1B,KAAuC,OAFzC,EAGE;IACA,OAAO,IAAP;EACD;;EAED,IAAMC,YAAY,GAAGF,OAAO,CAACE,YAA7B;;EAEA,IAAIA,YAAJ,EAAkB;IAChB,IAAMC,IAAI,GAAGL,kBAAkB,CAACI,YAAD,CAA/B;;IAEA,IACET,WAAW,CAACS,YAAD,CAAX,KAA8B,MAA9B,IACAR,gBAAgB,CAACQ,YAAD,CAAhB,CAA+BD,QAA/B,KAA4C,QAD5C,IAEAP,gBAAgB,CAACS,IAAD,CAAhB,CAAuBF,QAAvB,KAAoC,QAHtC,EAIE;MACA,OAAOE,IAAP;IACD;EACF;;EAED,OAAOD,YAAP;AACD,C,CAED;AACA;;AACA;;;;;AAGA,SAASE,kBAAT,CAA4BJ,OAA5B,EAA4C;EAC1C,IAAIK,WAAW,GAAGR,aAAa,CAACG,OAAD,CAA/B;;EAEA,OAAOL,aAAa,CAACU,WAAD,CAAb,IAA8B,CAAC,MAAD,EAAS,MAAT,EAAiBC,OAAjB,CAAyBb,WAAW,CAACY,WAAD,CAApC,IAAqD,CAA1F,EAA6F;IAC3F,IAAME,GAAG,GAAGb,gBAAgB,CAACW,WAAD,CAA5B,CAD2F,CAG3F;IACA;;IACA,IAAIE,GAAG,CAACC,SAAJ,KAAkB,MAAlB,IAA4BD,GAAG,CAACE,WAAJ,KAAoB,MAAhD,IAA2DF,GAAG,CAACG,UAAJ,IAAkBH,GAAG,CAACG,UAAJ,KAAmB,MAApG,EAA6G;MAC3G,OAAOL,WAAP;IACD,CAFD,MAEO;MACLA,WAAW,GAAGA,WAAW,CAACM,UAA1B;IACD;EACF;;EAED,OAAO,IAAP;AACD,C,CAED;AACA;;AACA;;;;;AAGA,eAAc,SAAUC,eAAV,CAA0BZ,OAA1B,EAA0C;EACtD,IAAMa,MAAM,GAAGrB,SAAS,CAACQ,OAAD,CAAxB;EAEA,IAAIE,YAAY,GAAGH,mBAAmB,CAACC,OAAD,CAAtC;;EAEA,OAAOE,YAAY,IAAIN,cAAc,CAACM,YAAD,CAA9B,IAAgDR,gBAAgB,CAACQ,YAAD,CAAhB,CAA+BD,QAA/B,KAA4C,QAAnG,EAA6G;IAC3GC,YAAY,GAAGH,mBAAmB,CAACG,YAAD,CAAlC;EACD;;EAED,IAAIA,YAAY,IAAIT,WAAW,CAACS,YAAD,CAAX,KAA8B,MAA9C,IAAwDR,gBAAgB,CAACQ,YAAD,CAAhB,CAA+BD,QAA/B,KAA4C,QAAxG,EAAkH;IAChH,OAAOY,MAAP;EACD;;EAED,OAAOX,YAAY,IAAIE,kBAAkB,CAACJ,OAAD,CAAlC,IAA+Ca,MAAtD;AACD","names":["getWindow","getNodeName","getComputedStyle","isHTMLElement","isTableElement","getParentNode","getDocumentElement","getTrueOffsetParent","element","position","offsetParent","html","getContainingBlock","currentNode","indexOf","css","transform","perspective","willChange","parentNode","getOffsetParent","window"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/dom-utils/getOffsetParent.ts"],"sourcesContent":["// @ts-nocheck\nimport getWindow from './getWindow';\nimport getNodeName from './getNodeName';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\nimport isTableElement from './isTableElement';\nimport getParentNode from './getParentNode';\nimport getDocumentElement from './getDocumentElement';\n\n/**\n * @param element\n */\nfunction getTrueOffsetParent(element: Element): Element | null | undefined {\n  if (\n    !isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed'\n  ) {\n    return null;\n  }\n\n  const offsetParent = element.offsetParent;\n\n  if (offsetParent) {\n    const html = getDocumentElement(offsetParent);\n\n    if (\n      getNodeName(offsetParent) === 'body' &&\n      getComputedStyle(offsetParent).position === 'static' &&\n      getComputedStyle(html).position !== 'static'\n    ) {\n      return html;\n    }\n  }\n\n  return offsetParent;\n}\n\n// `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n/**\n * @param element\n */\nfunction getContainingBlock(element: Element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    const css = getComputedStyle(currentNode);\n\n    // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    if (css.transform !== 'none' || css.perspective !== 'none' || (css.willChange && css.willChange !== 'auto')) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n/**\n * @param element\n */\nexport default function getOffsetParent(element: Element) {\n  const window = getWindow(element);\n\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n"]},"metadata":{},"sourceType":"module"}