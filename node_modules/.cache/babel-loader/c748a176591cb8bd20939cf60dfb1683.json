{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { getUniqueId } from '../../helpers';\nimport { flattenTree, flattenTreeWithFolders, filterFolders, filterTreeItems, filterTreeItemsWithoutFolders, filterRestTreeItems } from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\nexport class DualListSelector extends React.Component {\n  constructor(props) {\n    super(props);\n    this.addAllButtonRef = React.createRef();\n    this.addSelectedButtonRef = React.createRef();\n    this.removeSelectedButtonRef = React.createRef();\n    this.removeAllButtonRef = React.createRef();\n    /** In dev environment, prevents circular structure during JSON stringification when\n     * options passed in to the dual list selector include HTML elements.\n     */\n\n    this.replacer = (key, value) => {\n      if (key[0] === '_') {\n        return undefined;\n      }\n\n      return value;\n    };\n\n    this.onFilterUpdate = (newFilteredOptions, paneType, isSearchReset) => {\n      const {\n        isTree\n      } = this.props;\n\n      if (paneType === 'available') {\n        if (isSearchReset) {\n          this.setState({\n            availableFilteredOptions: null,\n            availableTreeFilteredOptions: null\n          });\n          return;\n        }\n\n        if (isTree) {\n          this.setState({\n            availableTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            availableFilteredOptions: newFilteredOptions\n          });\n        }\n      } else if (paneType === 'chosen') {\n        if (isSearchReset) {\n          this.setState({\n            chosenFilteredOptions: null,\n            chosenTreeFilteredOptions: null\n          });\n          return;\n        }\n\n        if (isTree) {\n          this.setState({\n            chosenTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            chosenFilteredOptions: newFilteredOptions\n          });\n        }\n      }\n    };\n\n    this.addAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n        prevState.availableOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n\n    this.addAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.availableTreeFilteredOptions || flattenTreeWithFolders(prevState.availableOptions);\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(movedOptions);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n\n    this.addSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        prevState.availableOptions.forEach((value, index) => {\n          if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          availableOptions: newAvailable\n        };\n      });\n    };\n\n    this.addTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected available nodes from current available nodes\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.availableTreeOptionsChecked)); // Get next chosen options from current + new nodes and remap from base\n\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n\n    this.removeAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n        prevState.chosenOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n\n    this.removeAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.chosenTreeFilteredOptions || flattenTreeWithFolders(prevState.chosenOptions);\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(movedOptions);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n\n    this.removeSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        prevState.chosenOptions.forEach((value, index) => {\n          if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          availableOptions: newAvailable\n        };\n      });\n    };\n\n    this.removeTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected chosen nodes from current chosen nodes\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.chosenTreeOptionsChecked)); // Get next chosen options from current and remap from base\n\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n\n    this.onOptionSelect = (e, index, isChosen,\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    id, itemData, parentData\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    ) => {\n      this.setState(prevState => {\n        const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n        let updatedArray = null;\n\n        if (originalArray.indexOf(index) !== -1) {\n          updatedArray = originalArray.filter(value => value !== index);\n        } else {\n          updatedArray = [...originalArray, index];\n        }\n\n        return {\n          chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n          availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n        };\n      });\n      this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n    };\n\n    this.isChecked = (treeItem, isChosen) => isChosen ? this.state.chosenTreeOptionsChecked.includes(treeItem.id) : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n\n    this.areAllDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n\n    this.areSomeDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n\n    this.mapChecked = (item, isChosen) => {\n      const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n      item.isChecked = false;\n\n      if (hasCheck) {\n        item.isChecked = true;\n      } else {\n        const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n\n        if (hasPartialCheck) {\n          item.isChecked = null;\n        }\n      }\n\n      if (item.children) {\n        return Object.assign(Object.assign({}, item), {\n          children: item.children.map(child => this.mapChecked(child, isChosen))\n        });\n      }\n\n      return item;\n    };\n\n    this.onTreeOptionCheck = (evt, isChecked, itemData, isChosen) => {\n      const {\n        availableOptions,\n        availableTreeFilteredOptions,\n        chosenOptions,\n        chosenTreeFilteredOptions\n      } = this.state;\n      let panelOptions;\n\n      if (isChosen) {\n        if (chosenTreeFilteredOptions) {\n          panelOptions = chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, chosenTreeFilteredOptions));\n        } else {\n          panelOptions = chosenOptions;\n        }\n      } else {\n        if (availableTreeFilteredOptions) {\n          panelOptions = availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, availableTreeFilteredOptions));\n        } else {\n          panelOptions = availableOptions;\n        }\n      }\n\n      const checkedOptionTree = panelOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItems(item, [itemData.id]));\n      const flatTree = flattenTreeWithFolders(checkedOptionTree);\n      const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n      let updatedChecked = [];\n\n      if (isChecked) {\n        updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n      } else {\n        updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n      }\n\n      this.setState(prevState => ({\n        availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n        chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n      }), () => {\n        this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n      });\n    };\n\n    this.state = {\n      availableOptions: [...this.props.availableOptions],\n      availableOptionsSelected: [],\n      availableFilteredOptions: null,\n      availableTreeFilteredOptions: null,\n      chosenOptions: [...this.props.chosenOptions],\n      chosenOptionsSelected: [],\n      chosenFilteredOptions: null,\n      chosenTreeFilteredOptions: null,\n      availableTreeOptionsChecked: [],\n      chosenTreeOptionsChecked: []\n    };\n  } // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n\n\n  createMergedCopy() {\n    const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n    const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n    return this.props.isTree ? Object.values(copyOfAvailable.concat(copyOfChosen).reduce((mapObj, item) => {\n      const key = item.id;\n\n      if (mapObj[key]) {\n        // If map already has an item ID, add the dupe ID's children to the existing map\n        mapObj[key].children.push(...item.children);\n      } else {\n        // Else clone the item data\n        mapObj[key] = Object.assign({}, item);\n      }\n\n      return mapObj;\n    }, {})) : null;\n  }\n\n  componentDidUpdate() {\n    if (JSON.stringify(this.props.availableOptions, this.replacer) !== JSON.stringify(this.state.availableOptions, this.replacer) || JSON.stringify(this.props.chosenOptions, this.replacer) !== JSON.stringify(this.state.chosenOptions, this.replacer)) {\n      this.setState({\n        availableOptions: [...this.props.availableOptions],\n        chosenOptions: [...this.props.chosenOptions]\n      });\n    }\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      availableOptionsTitle,\n      availableOptionsActions,\n      availableOptionsSearchAriaLabel,\n      className,\n      children,\n      chosenOptionsTitle,\n      chosenOptionsActions,\n      chosenOptionsSearchAriaLabel,\n      filterOption,\n      isSearchable,\n      chosenOptionsStatus,\n      availableOptionsStatus,\n      controlsAriaLabel,\n      addAllAriaLabel,\n      addSelectedAriaLabel,\n      removeSelectedAriaLabel,\n      removeAllAriaLabel,\n\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      availableOptions: consumerPassedAvailableOptions,\n      chosenOptions: consumerPassedChosenOptions,\n      removeSelected,\n      addAll,\n      removeAll,\n      addSelected,\n      onListChange,\n      onAvailableOptionsSearchInputChanged,\n      onChosenOptionsSearchInputChanged,\n      onOptionSelect,\n      onOptionCheck,\n      id,\n      isTree,\n      isDisabled,\n      addAllTooltip,\n      addAllTooltipProps,\n      addSelectedTooltip,\n      addSelectedTooltipProps,\n      removeAllTooltip,\n      removeAllTooltipProps,\n      removeSelectedTooltip,\n      removeSelectedTooltipProps\n    } = _a,\n          props = __rest(_a, [\"availableOptionsTitle\", \"availableOptionsActions\", \"availableOptionsSearchAriaLabel\", \"className\", \"children\", \"chosenOptionsTitle\", \"chosenOptionsActions\", \"chosenOptionsSearchAriaLabel\", \"filterOption\", \"isSearchable\", \"chosenOptionsStatus\", \"availableOptionsStatus\", \"controlsAriaLabel\", \"addAllAriaLabel\", \"addSelectedAriaLabel\", \"removeSelectedAriaLabel\", \"removeAllAriaLabel\", \"availableOptions\", \"chosenOptions\", \"removeSelected\", \"addAll\", \"removeAll\", \"addSelected\", \"onListChange\", \"onAvailableOptionsSearchInputChanged\", \"onChosenOptionsSearchInputChanged\", \"onOptionSelect\", \"onOptionCheck\", \"id\", \"isTree\", \"isDisabled\", \"addAllTooltip\", \"addAllTooltipProps\", \"addSelectedTooltip\", \"addSelectedTooltipProps\", \"removeAllTooltip\", \"removeAllTooltipProps\", \"removeSelectedTooltip\", \"removeSelectedTooltipProps\"]);\n\n    const {\n      availableOptions,\n      chosenOptions,\n      chosenOptionsSelected,\n      availableOptionsSelected,\n      chosenTreeOptionsChecked,\n      availableTreeOptionsChecked\n    } = this.state;\n    const availableOptionsStatusToDisplay = availableOptionsStatus || (isTree ? `${filterFolders(availableOptions, availableTreeOptionsChecked).length} of ${flattenTree(availableOptions).length} items selected` : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n    const chosenOptionsStatusToDisplay = chosenOptionsStatus || (isTree ? `${filterFolders(chosenOptions, chosenTreeOptionsChecked).length} of ${flattenTree(chosenOptions).length} items selected` : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n    const available = isTree ? availableOptions.map(item => this.mapChecked(item, false)) : availableOptions;\n    const chosen = isTree ? chosenOptions.map(item => this.mapChecked(item, true)) : chosenOptions;\n    return React.createElement(DualListSelectorContext.Provider, {\n      value: {\n        isTree\n      }\n    }, React.createElement(\"div\", Object.assign({\n      className: css(styles.dualListSelector, className),\n      id: id\n    }, props), children === '' ? React.createElement(React.Fragment, null, React.createElement(DualListSelectorPane, {\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: availableOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onAvailableOptionsSearchInputChanged,\n      status: availableOptionsStatusToDisplay,\n      title: availableOptionsTitle,\n      options: available,\n      selectedOptions: isTree ? availableTreeOptionsChecked : availableOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false),\n      actions: availableOptionsActions,\n      id: `${id}-available-pane`,\n      isDisabled: isDisabled\n    }), React.createElement(DualListSelectorControlsWrapper, {\n      \"aria-label\": controlsAriaLabel\n    }, React.createElement(DualListSelectorControl, {\n      isDisabled: (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) || isDisabled,\n      onClick: isTree ? this.addTreeSelected : this.addSelected,\n      ref: this.addSelectedButtonRef,\n      \"aria-label\": addSelectedAriaLabel,\n      tooltipContent: addSelectedTooltip,\n      tooltipProps: addSelectedTooltipProps\n    }, React.createElement(AngleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: availableOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.addAllTreeVisible : this.addAllVisible,\n      ref: this.addAllButtonRef,\n      \"aria-label\": addAllAriaLabel,\n      tooltipContent: addAllTooltip,\n      tooltipProps: addAllTooltipProps\n    }, React.createElement(AngleDoubleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: chosenOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.removeAllTreeVisible : this.removeAllVisible,\n      \"aria-label\": removeAllAriaLabel,\n      ref: this.removeAllButtonRef,\n      tooltipContent: removeAllTooltip,\n      tooltipProps: removeAllTooltipProps\n    }, React.createElement(AngleDoubleLeftIcon, null)), React.createElement(DualListSelectorControl, {\n      onClick: isTree ? this.removeTreeSelected : this.removeSelected,\n      isDisabled: (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) || isDisabled,\n      ref: this.removeSelectedButtonRef,\n      \"aria-label\": removeSelectedAriaLabel,\n      tooltipContent: removeSelectedTooltip,\n      tooltipProps: removeSelectedTooltipProps\n    }, React.createElement(AngleLeftIcon, null))), React.createElement(DualListSelectorPane, {\n      isChosen: true,\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: chosenOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onChosenOptionsSearchInputChanged,\n      title: chosenOptionsTitle,\n      status: chosenOptionsStatusToDisplay,\n      options: chosen,\n      selectedOptions: isTree ? chosenTreeOptionsChecked : chosenOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true),\n      actions: chosenOptionsActions,\n      id: `${id}-chosen-pane`,\n      isDisabled: isDisabled\n    })) : children));\n  }\n\n}\nDualListSelector.displayName = 'DualListSelector';\nDualListSelector.defaultProps = {\n  children: '',\n  availableOptions: [],\n  availableOptionsTitle: 'Available options',\n  availableOptionsSearchAriaLabel: 'Available search input',\n  chosenOptions: [],\n  chosenOptionsTitle: 'Chosen options',\n  chosenOptionsSearchAriaLabel: 'Chosen search input',\n  id: getUniqueId('dual-list-selector'),\n  controlsAriaLabel: 'Selector controls',\n  addAllAriaLabel: 'Add all',\n  addSelectedAriaLabel: 'Add selected',\n  removeSelectedAriaLabel: 'Remove selected',\n  removeAllAriaLabel: 'Remove all',\n  isTree: false,\n  isDisabled: false\n};","map":{"version":3,"mappings":"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","names":["React","styles","css","AngleDoubleLeftIcon","AngleLeftIcon","AngleDoubleRightIcon","AngleRightIcon","DualListSelectorPane","getUniqueId","flattenTree","flattenTreeWithFolders","filterFolders","filterTreeItems","filterTreeItemsWithoutFolders","filterRestTreeItems","DualListSelectorControlsWrapper","DualListSelectorControl","DualListSelectorContext","DualListSelector","Component","constructor","props","createRef","key","value","undefined","newFilteredOptions","paneType","isSearchReset","isTree","setState","availableFilteredOptions","availableTreeFilteredOptions","chosenFilteredOptions","chosenTreeFilteredOptions","prevState","itemsToRemove","newAvailable","movedOptions","availableOptions","forEach","indexOf","push","newChosen","chosenOptions","addAll","onListChange","chosenOptionsSelected","availableOptionsSelected","map","opt","Object","assign","filter","item","currChosen","nextChosenOptions","concat","createMergedCopy","availableTreeOptionsChecked","chosenTreeOptionsChecked","index","addSelected","removeAll","currAvailable","nextAvailableOptions","removeSelected","e","isChosen","id","itemData","parentData","originalArray","updatedArray","onOptionSelect","treeItem","state","includes","children","every","child","areAllDescendantsChecked","isChecked","some","areSomeDescendantsChecked","hasCheck","hasPartialCheck","mapChecked","evt","panelOptions","checkedOptionTree","flatTree","prevChecked","updatedChecked","onOptionCheck","copyOfAvailable","JSON","parse","stringify","copyOfChosen","values","reduce","mapObj","componentDidUpdate","replacer","render","_a","availableOptionsTitle","availableOptionsActions","availableOptionsSearchAriaLabel","className","chosenOptionsTitle","chosenOptionsActions","chosenOptionsSearchAriaLabel","filterOption","isSearchable","chosenOptionsStatus","availableOptionsStatus","controlsAriaLabel","addAllAriaLabel","addSelectedAriaLabel","removeSelectedAriaLabel","removeAllAriaLabel","consumerPassedAvailableOptions","consumerPassedChosenOptions","onAvailableOptionsSearchInputChanged","onChosenOptionsSearchInputChanged","isDisabled","addAllTooltip","addAllTooltipProps","addSelectedTooltip","addSelectedTooltipProps","removeAllTooltip","removeAllTooltipProps","removeSelectedTooltip","removeSelectedTooltipProps","availableOptionsStatusToDisplay","length","chosenOptionsStatusToDisplay","available","chosen","Provider","dualListSelector","onFilterUpdate","searchInputAriaLabel","onSearchInputChanged","status","title","options","selectedOptions","onTreeOptionCheck","actions","onClick","addTreeSelected","ref","addSelectedButtonRef","tooltipContent","tooltipProps","addAllTreeVisible","addAllVisible","addAllButtonRef","removeAllTreeVisible","removeAllVisible","removeAllButtonRef","removeTreeSelected","removeSelectedButtonRef"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/components/DualListSelector/DualListSelector.tsx"],"sourcesContent":["import * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { getUniqueId, PickOptional } from '../../helpers';\nimport { DualListSelectorTreeItemData } from './DualListSelectorTree';\nimport {\n  flattenTree,\n  flattenTreeWithFolders,\n  filterFolders,\n  filterTreeItems,\n  filterTreeItemsWithoutFolders,\n  filterRestTreeItems\n} from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\n\nexport interface DualListSelectorProps {\n  /** Additional classes applied to the dual list selector. */\n  className?: string;\n  /** Id of the dual list selector. */\n  id?: string;\n  /** Flag indicating if the dual list selector uses trees instead of simple lists */\n  isTree?: boolean;\n  /** Flag indicating if the dual list selector is in a disabled state */\n  isDisabled?: boolean;\n  /** Content to be rendered in the dual list selector. Panes & controls will not be built dynamically when children are provided. */\n  children?: React.ReactNode;\n  /** Title applied to the dynamically built available options pane. */\n  availableOptionsTitle?: string;\n  /** Options to display in the dynamically built available options pane. When using trees, the options should be in the DualListSelectorTreeItemData[] format. */\n  availableOptions?: React.ReactNode[] | DualListSelectorTreeItemData[];\n  /** Status message to display above the dynamically built available options pane. */\n  availableOptionsStatus?: string;\n  /** Actions to be displayed above the dynamically built available options pane. */\n  availableOptionsActions?: React.ReactNode[];\n  /** Title applied to the dynamically built chosen options pane. */\n  chosenOptionsTitle?: string;\n  /** Options to display in the dynamically built chosen options pane. When using trees, the options should be in the DualListSelectorTreeItemData[] format. */\n  chosenOptions?: React.ReactNode[] | DualListSelectorTreeItemData[];\n  /** Status message to display above the dynamically built chosen options pane.*/\n  chosenOptionsStatus?: string;\n  /** Actions to be displayed above the dynamically built chosen options pane. */\n  chosenOptionsActions?: React.ReactNode[];\n  /** Accessible label for the dynamically built controls between the two panes. */\n  controlsAriaLabel?: string;\n  /** Optional callback for the dynamically built add selected button */\n  addSelected?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built add selected button */\n  addSelectedAriaLabel?: string;\n  /** Tooltip content for the dynamically built add selected button */\n  addSelectedTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built add selected tooltip */\n  addSelectedTooltipProps?: any;\n  /** Callback fired every time dynamically built options are chosen or removed */\n  onListChange?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Optional callback for the dynamically built add all button */\n  addAll?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built add all button */\n  addAllAriaLabel?: string;\n  /** Tooltip content for the dynamically built add all button */\n  addAllTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built add all tooltip */\n  addAllTooltipProps?: any;\n  /** Optional callback for the dynamically built remove selected button */\n  removeSelected?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built remove selected button */\n  removeSelectedAriaLabel?: string;\n  /** Tooltip content for the dynamically built remove selected button */\n  removeSelectedTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built remove selected tooltip  */\n  removeSelectedTooltipProps?: any;\n  /** Optional callback for the dynamically built remove all button */\n  removeAll?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built remove all button */\n  removeAllAriaLabel?: string;\n  /** Tooltip content for the dynamically built remove all button */\n  removeAllTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built remove all tooltip */\n  removeAllTooltipProps?: any;\n  /** Optional callback fired when a dynamically built option is selected */\n  onOptionSelect?: (\n    e: React.MouseEvent | React.ChangeEvent | React.KeyboardEvent,\n    index: number,\n    isChosen: boolean,\n    id: string,\n    itemData: any,\n    parentData: any\n  ) => void;\n  /** Optional callback fired when a dynamically built option is checked */\n  onOptionCheck?: (\n    e: React.MouseEvent | React.ChangeEvent<HTMLInputElement> | React.KeyboardEvent,\n    checked: boolean,\n    checkedId: string,\n    newCheckedItems: string[]\n  ) => void;\n  /** Flag indicating a search bar should be included above both the dynamically built available and chosen panes. */\n  isSearchable?: boolean;\n  /** Accessible label for the search input on the dynamically built available options pane. */\n  availableOptionsSearchAriaLabel?: string;\n  /** A callback for when the search input value for the dynamically built available options changes. */\n  onAvailableOptionsSearchInputChanged?: (value: string, event: React.FormEvent<HTMLInputElement>) => void;\n  /** Accessible label for the search input on the dynamically built chosen options pane. */\n  chosenOptionsSearchAriaLabel?: string;\n  /** A callback for when the search input value for the dynamically built chosen options changes. */\n  onChosenOptionsSearchInputChanged?: (value: string, event: React.FormEvent<HTMLInputElement>) => void;\n  /** Optional filter function for custom filtering based on search string. Used with a dynamically built search input. */\n  filterOption?: (option: React.ReactNode, input: string) => boolean;\n}\n\ninterface DualListSelectorState {\n  availableOptions: React.ReactNode[];\n  availableOptionsSelected: number[];\n  availableFilteredOptions: React.ReactNode[];\n  chosenOptions: React.ReactNode[];\n  chosenOptionsSelected: number[];\n  chosenFilteredOptions: React.ReactNode[];\n  availableTreeFilteredOptions: string[];\n  availableTreeOptionsChecked: string[];\n  chosenTreeOptionsChecked: string[];\n  chosenTreeFilteredOptions: string[];\n}\n\nexport class DualListSelector extends React.Component<DualListSelectorProps, DualListSelectorState> {\n  static displayName = 'DualListSelector';\n  private addAllButtonRef = React.createRef<HTMLButtonElement>();\n  private addSelectedButtonRef = React.createRef<HTMLButtonElement>();\n  private removeSelectedButtonRef = React.createRef<HTMLButtonElement>();\n  private removeAllButtonRef = React.createRef<HTMLButtonElement>();\n  static defaultProps: PickOptional<DualListSelectorProps> = {\n    children: '',\n    availableOptions: [],\n    availableOptionsTitle: 'Available options',\n    availableOptionsSearchAriaLabel: 'Available search input',\n    chosenOptions: [],\n    chosenOptionsTitle: 'Chosen options',\n    chosenOptionsSearchAriaLabel: 'Chosen search input',\n    id: getUniqueId('dual-list-selector'),\n    controlsAriaLabel: 'Selector controls',\n    addAllAriaLabel: 'Add all',\n    addSelectedAriaLabel: 'Add selected',\n    removeSelectedAriaLabel: 'Remove selected',\n    removeAllAriaLabel: 'Remove all',\n    isTree: false,\n    isDisabled: false\n  };\n\n  // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n  private createMergedCopy() {\n    const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n    const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n\n    return this.props.isTree\n      ? Object.values(\n          (copyOfAvailable as DualListSelectorTreeItemData[])\n            .concat(copyOfChosen as DualListSelectorTreeItemData[])\n            .reduce((mapObj: any, item: DualListSelectorTreeItemData) => {\n              const key = item.id;\n              if (mapObj[key]) {\n                // If map already has an item ID, add the dupe ID's children to the existing map\n                mapObj[key].children.push(...item.children);\n              } else {\n                // Else clone the item data\n                mapObj[key] = { ...item };\n              }\n              return mapObj;\n            }, {})\n        )\n      : null;\n  }\n\n  constructor(props: DualListSelectorProps) {\n    super(props);\n    this.state = {\n      availableOptions: [...this.props.availableOptions] as React.ReactNode[],\n      availableOptionsSelected: [],\n      availableFilteredOptions: null,\n      availableTreeFilteredOptions: null,\n      chosenOptions: [...this.props.chosenOptions] as React.ReactNode[],\n      chosenOptionsSelected: [],\n      chosenFilteredOptions: null,\n      chosenTreeFilteredOptions: null,\n      availableTreeOptionsChecked: [],\n      chosenTreeOptionsChecked: []\n    };\n  }\n\n  /** In dev environment, prevents circular structure during JSON stringification when\n   * options passed in to the dual list selector include HTML elements.\n   */\n  replacer = (key: string, value: any) => {\n    if (key[0] === '_') {\n      return undefined;\n    }\n    return value;\n  };\n\n  componentDidUpdate() {\n    if (\n      JSON.stringify(this.props.availableOptions, this.replacer) !==\n        JSON.stringify(this.state.availableOptions, this.replacer) ||\n      JSON.stringify(this.props.chosenOptions, this.replacer) !==\n        JSON.stringify(this.state.chosenOptions, this.replacer)\n    ) {\n      this.setState({\n        availableOptions: [...this.props.availableOptions] as React.ReactNode[],\n        chosenOptions: [...this.props.chosenOptions] as React.ReactNode[]\n      });\n    }\n  }\n\n  onFilterUpdate = (newFilteredOptions: React.ReactNode[], paneType: string, isSearchReset: boolean) => {\n    const { isTree } = this.props;\n    if (paneType === 'available') {\n      if (isSearchReset) {\n        this.setState({\n          availableFilteredOptions: null,\n          availableTreeFilteredOptions: null\n        });\n        return;\n      }\n      if (isTree) {\n        this.setState({\n          availableTreeFilteredOptions: flattenTreeWithFolders(\n            (newFilteredOptions as unknown) as DualListSelectorTreeItemData[]\n          )\n        });\n      } else {\n        this.setState({\n          availableFilteredOptions: newFilteredOptions as React.ReactNode[]\n        });\n      }\n    } else if (paneType === 'chosen') {\n      if (isSearchReset) {\n        this.setState({\n          chosenFilteredOptions: null,\n          chosenTreeFilteredOptions: null\n        });\n        return;\n      }\n      if (isTree) {\n        this.setState({\n          chosenTreeFilteredOptions: flattenTreeWithFolders(\n            (newFilteredOptions as unknown) as DualListSelectorTreeItemData[]\n          )\n        });\n      } else {\n        this.setState({\n          chosenFilteredOptions: newFilteredOptions as React.ReactNode[]\n        });\n      }\n    }\n  };\n\n  addAllVisible = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newAvailable = [] as React.ReactNode[];\n      const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n      prevState.availableOptions.forEach(value => {\n        if (movedOptions.indexOf(value) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newAvailable.push(value);\n        }\n      });\n\n      const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n      this.props.addAll && this.props.addAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        availableOptions: newAvailable,\n        chosenOptionsSelected: [],\n        availableOptionsSelected: []\n      };\n    });\n  };\n\n  addAllTreeVisible = () => {\n    this.setState(prevState => {\n      const movedOptions =\n        prevState.availableTreeFilteredOptions ||\n        flattenTreeWithFolders((prevState.availableOptions as unknown) as DualListSelectorTreeItemData[]);\n      const newAvailable = prevState.availableOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, movedOptions)\n        ) as React.ReactNode[];\n\n      const currChosen = flattenTree((prevState.chosenOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextChosenOptions = currChosen.concat(movedOptions);\n      const newChosen = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextChosenOptions)\n        ) as React.ReactNode[];\n\n      this.props.addAll && this.props.addAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        chosenFilteredOptions: newChosen,\n        availableOptions: newAvailable,\n        availableFilteredOptions: newAvailable,\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: []\n      };\n    });\n  };\n\n  addSelected = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newAvailable = [] as React.ReactNode[];\n      prevState.availableOptions.forEach((value, index) => {\n        if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newAvailable.push(value);\n        }\n      });\n\n      const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n      this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptionsSelected: [],\n        availableOptionsSelected: [],\n        chosenOptions: newChosen,\n        availableOptions: newAvailable\n      };\n    });\n  };\n\n  addTreeSelected = () => {\n    this.setState(prevState => {\n      // Remove selected available nodes from current available nodes\n      const newAvailable = prevState.availableOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, prevState.availableTreeOptionsChecked)\n        );\n\n      // Get next chosen options from current + new nodes and remap from base\n      const currChosen = flattenTree((prevState.chosenOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n      const newChosen = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextChosenOptions)\n        ) as React.ReactNode[];\n\n      this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: [],\n        availableOptions: newAvailable,\n        chosenOptions: newChosen\n      };\n    });\n  };\n\n  removeAllVisible = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newChosen = [] as React.ReactNode[];\n      const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n      prevState.chosenOptions.forEach(value => {\n        if (movedOptions.indexOf(value) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newChosen.push(value);\n        }\n      });\n\n      const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n      this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        availableOptions: newAvailable,\n        chosenOptionsSelected: [],\n        availableOptionsSelected: []\n      };\n    });\n  };\n\n  removeAllTreeVisible = () => {\n    this.setState(prevState => {\n      const movedOptions =\n        prevState.chosenTreeFilteredOptions ||\n        flattenTreeWithFolders((prevState.chosenOptions as unknown) as DualListSelectorTreeItemData[]);\n\n      const newChosen = prevState.chosenOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, movedOptions));\n      const currAvailable = flattenTree((prevState.availableOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextAvailableOptions = currAvailable.concat(movedOptions);\n      const newAvailable = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextAvailableOptions)\n        ) as React.ReactNode[];\n\n      this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        availableOptions: newAvailable,\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: []\n      };\n    });\n  };\n\n  removeSelected = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newChosen = [] as React.ReactNode[];\n      prevState.chosenOptions.forEach((value, index) => {\n        if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newChosen.push(value);\n        }\n      });\n\n      const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n      this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptionsSelected: [],\n        availableOptionsSelected: [],\n        chosenOptions: newChosen,\n        availableOptions: newAvailable\n      };\n    });\n  };\n\n  removeTreeSelected = () => {\n    this.setState(prevState => {\n      // Remove selected chosen nodes from current chosen nodes\n      const newChosen = prevState.chosenOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, prevState.chosenTreeOptionsChecked)\n        );\n\n      // Get next chosen options from current and remap from base\n      const currAvailable = flattenTree((prevState.availableOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n      const newAvailable = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextAvailableOptions)\n        ) as React.ReactNode[];\n\n      this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: [],\n        availableOptions: newAvailable,\n        chosenOptions: newChosen\n      };\n    });\n  };\n\n  onOptionSelect = (\n    e: React.MouseEvent | React.ChangeEvent | React.KeyboardEvent,\n    index: number,\n    isChosen: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    id?: string,\n    itemData?: any,\n    parentData?: any\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ) => {\n    this.setState(prevState => {\n      const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n\n      let updatedArray = null;\n      if (originalArray.indexOf(index) !== -1) {\n        updatedArray = originalArray.filter(value => value !== index);\n      } else {\n        updatedArray = [...originalArray, index];\n      }\n\n      return {\n        chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n        availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n      };\n    });\n\n    this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n  };\n\n  isChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean) =>\n    isChosen\n      ? this.state.chosenTreeOptionsChecked.includes(treeItem.id)\n      : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n  areAllDescendantsChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean): boolean =>\n    treeItem.children\n      ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen))\n      : this.isChecked(treeItem, isChosen);\n  areSomeDescendantsChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean): boolean =>\n    treeItem.children\n      ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen))\n      : this.isChecked(treeItem, isChosen);\n\n  mapChecked = (item: DualListSelectorTreeItemData, isChosen: boolean): DualListSelectorTreeItemData => {\n    const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n    item.isChecked = false;\n\n    if (hasCheck) {\n      item.isChecked = true;\n    } else {\n      const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n      if (hasPartialCheck) {\n        item.isChecked = null;\n      }\n    }\n\n    if (item.children) {\n      return {\n        ...item,\n        children: item.children.map(child => this.mapChecked(child, isChosen))\n      };\n    }\n    return item;\n  };\n\n  onTreeOptionCheck = (\n    evt: React.MouseEvent | React.ChangeEvent<HTMLInputElement> | React.KeyboardEvent,\n    isChecked: boolean,\n    itemData: DualListSelectorTreeItemData,\n    isChosen: boolean\n  ) => {\n    const { availableOptions, availableTreeFilteredOptions, chosenOptions, chosenTreeFilteredOptions } = this.state;\n    let panelOptions;\n    if (isChosen) {\n      if (chosenTreeFilteredOptions) {\n        panelOptions = chosenOptions\n          .map(opt => Object.assign({}, opt))\n          .filter(item =>\n            filterTreeItemsWithoutFolders((item as unknown) as DualListSelectorTreeItemData, chosenTreeFilteredOptions)\n          );\n      } else {\n        panelOptions = chosenOptions;\n      }\n    } else {\n      if (availableTreeFilteredOptions) {\n        panelOptions = availableOptions\n          .map(opt => Object.assign({}, opt))\n          .filter(item =>\n            filterTreeItemsWithoutFolders(\n              (item as unknown) as DualListSelectorTreeItemData,\n              availableTreeFilteredOptions\n            )\n          );\n      } else {\n        panelOptions = availableOptions;\n      }\n    }\n    const checkedOptionTree = panelOptions\n      .map(opt => Object.assign({}, opt))\n      .filter(item => filterTreeItems((item as unknown) as DualListSelectorTreeItemData, [itemData.id]));\n    const flatTree = flattenTreeWithFolders((checkedOptionTree as unknown) as DualListSelectorTreeItemData[]);\n\n    const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n    let updatedChecked = [] as string[];\n    if (isChecked) {\n      updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n    } else {\n      updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n    }\n\n    this.setState(\n      prevState => ({\n        availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n        chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n      }),\n      () => {\n        this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n      }\n    );\n  };\n\n  render() {\n    const {\n      availableOptionsTitle,\n      availableOptionsActions,\n      availableOptionsSearchAriaLabel,\n      className,\n      children,\n      chosenOptionsTitle,\n      chosenOptionsActions,\n      chosenOptionsSearchAriaLabel,\n      filterOption,\n      isSearchable,\n      chosenOptionsStatus,\n      availableOptionsStatus,\n      controlsAriaLabel,\n      addAllAriaLabel,\n      addSelectedAriaLabel,\n      removeSelectedAriaLabel,\n      removeAllAriaLabel,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      availableOptions: consumerPassedAvailableOptions,\n      chosenOptions: consumerPassedChosenOptions,\n      removeSelected,\n      addAll,\n      removeAll,\n      addSelected,\n      onListChange,\n      onAvailableOptionsSearchInputChanged,\n      onChosenOptionsSearchInputChanged,\n      onOptionSelect,\n      onOptionCheck,\n      id,\n      isTree,\n      isDisabled,\n      addAllTooltip,\n      addAllTooltipProps,\n      addSelectedTooltip,\n      addSelectedTooltipProps,\n      removeAllTooltip,\n      removeAllTooltipProps,\n      removeSelectedTooltip,\n      removeSelectedTooltipProps,\n      ...props\n    } = this.props;\n    const {\n      availableOptions,\n      chosenOptions,\n      chosenOptionsSelected,\n      availableOptionsSelected,\n      chosenTreeOptionsChecked,\n      availableTreeOptionsChecked\n    } = this.state;\n    const availableOptionsStatusToDisplay =\n      availableOptionsStatus ||\n      (isTree\n        ? `${\n            filterFolders((availableOptions as unknown) as DualListSelectorTreeItemData[], availableTreeOptionsChecked)\n              .length\n          } of ${flattenTree((availableOptions as unknown) as DualListSelectorTreeItemData[]).length} items selected`\n        : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n    const chosenOptionsStatusToDisplay =\n      chosenOptionsStatus ||\n      (isTree\n        ? `${\n            filterFolders((chosenOptions as unknown) as DualListSelectorTreeItemData[], chosenTreeOptionsChecked).length\n          } of ${flattenTree((chosenOptions as unknown) as DualListSelectorTreeItemData[]).length} items selected`\n        : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n\n    const available = (isTree\n      ? availableOptions.map(item => this.mapChecked((item as unknown) as DualListSelectorTreeItemData, false))\n      : availableOptions) as React.ReactNode[];\n    const chosen = (isTree\n      ? chosenOptions.map(item => this.mapChecked((item as unknown) as DualListSelectorTreeItemData, true))\n      : chosenOptions) as React.ReactNode[];\n\n    return (\n      <DualListSelectorContext.Provider value={{ isTree }}>\n        <div className={css(styles.dualListSelector, className)} id={id} {...props}>\n          {children === '' ? (\n            <>\n              <DualListSelectorPane\n                isSearchable={isSearchable}\n                onFilterUpdate={this.onFilterUpdate}\n                searchInputAriaLabel={availableOptionsSearchAriaLabel}\n                filterOption={filterOption}\n                onSearchInputChanged={onAvailableOptionsSearchInputChanged}\n                status={availableOptionsStatusToDisplay}\n                title={availableOptionsTitle}\n                options={available}\n                selectedOptions={isTree ? availableTreeOptionsChecked : availableOptionsSelected}\n                onOptionSelect={this.onOptionSelect}\n                onOptionCheck={(e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false)}\n                actions={availableOptionsActions}\n                id={`${id}-available-pane`}\n                isDisabled={isDisabled}\n              />\n              <DualListSelectorControlsWrapper aria-label={controlsAriaLabel}>\n                <DualListSelectorControl\n                  isDisabled={\n                    (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) ||\n                    isDisabled\n                  }\n                  onClick={isTree ? this.addTreeSelected : this.addSelected}\n                  ref={this.addSelectedButtonRef}\n                  aria-label={addSelectedAriaLabel}\n                  tooltipContent={addSelectedTooltip}\n                  tooltipProps={addSelectedTooltipProps}\n                >\n                  <AngleRightIcon />\n                </DualListSelectorControl>\n                <DualListSelectorControl\n                  isDisabled={availableOptions.length === 0 || isDisabled}\n                  onClick={isTree ? this.addAllTreeVisible : this.addAllVisible}\n                  ref={this.addAllButtonRef}\n                  aria-label={addAllAriaLabel}\n                  tooltipContent={addAllTooltip}\n                  tooltipProps={addAllTooltipProps}\n                >\n                  <AngleDoubleRightIcon />\n                </DualListSelectorControl>\n                <DualListSelectorControl\n                  isDisabled={chosenOptions.length === 0 || isDisabled}\n                  onClick={isTree ? this.removeAllTreeVisible : this.removeAllVisible}\n                  aria-label={removeAllAriaLabel}\n                  ref={this.removeAllButtonRef}\n                  tooltipContent={removeAllTooltip}\n                  tooltipProps={removeAllTooltipProps}\n                >\n                  <AngleDoubleLeftIcon />\n                </DualListSelectorControl>\n                <DualListSelectorControl\n                  onClick={isTree ? this.removeTreeSelected : this.removeSelected}\n                  isDisabled={\n                    (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) || isDisabled\n                  }\n                  ref={this.removeSelectedButtonRef}\n                  aria-label={removeSelectedAriaLabel}\n                  tooltipContent={removeSelectedTooltip}\n                  tooltipProps={removeSelectedTooltipProps}\n                >\n                  <AngleLeftIcon />\n                </DualListSelectorControl>\n              </DualListSelectorControlsWrapper>\n              <DualListSelectorPane\n                isChosen\n                isSearchable={isSearchable}\n                onFilterUpdate={this.onFilterUpdate}\n                searchInputAriaLabel={chosenOptionsSearchAriaLabel}\n                filterOption={filterOption}\n                onSearchInputChanged={onChosenOptionsSearchInputChanged}\n                title={chosenOptionsTitle}\n                status={chosenOptionsStatusToDisplay}\n                options={chosen}\n                selectedOptions={isTree ? chosenTreeOptionsChecked : chosenOptionsSelected}\n                onOptionSelect={this.onOptionSelect}\n                onOptionCheck={(e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true)}\n                actions={chosenOptionsActions}\n                id={`${id}-chosen-pane`}\n                isDisabled={isDisabled}\n              />\n            </>\n          ) : (\n            children\n          )}\n        </div>\n      </DualListSelectorContext.Provider>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}