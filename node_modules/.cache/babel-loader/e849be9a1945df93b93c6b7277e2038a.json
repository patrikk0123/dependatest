{"ast":null,"code":"import _toConsumableArray from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n/**\n * @param placement\n */\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n/**\n *\n */\n\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(_toConsumableArray(fallbackPlacements)).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","map":{"version":3,"mappings":"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","names":["getOppositePlacement","getBasePlacement","getOppositeVariationPlacement","detectOverflow","computeAutoPlacement","bottom","top","start","right","left","auto","getVariation","getExpandedFallbackPlacements","placement","oppositePlacement","flip","state","options","name","modifiersData","_skip","mainAxis","checkMainAxis","altAxis","checkAltAxis","specifiedFallbackPlacements","fallbackPlacements","padding","boundary","rootBoundary","altBoundary","flipVariations","allowedAutoPlacements","preferredPlacement","basePlacement","isBasePlacement","placements","reduce","acc","concat","referenceRect","rects","reference","popperRect","popper","checksMap","Map","makeFallbackChecks","firstFittingPlacement","i","length","isStartVariation","isVertical","indexOf","len","overflow","mainVariationSide","altVariationSide","checks","push","every","check","set","numberOfChecks","fittingPlacement","find","get","slice","reset","enabled","phase","fn","requiresIfExists","data"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/flip.ts"],"sourcesContent":["// @ts-nocheck\nimport { Placement, Boundary, RootBoundary } from '../enums';\nimport { ModifierArguments, Modifier, Padding } from '../types';\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  mainAxis: boolean;\n  altAxis: boolean;\n  fallbackPlacements: Placement[];\n  padding: Padding;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  altBoundary: boolean;\n  flipVariations: boolean;\n  allowedAutoPlacements: Placement[];\n}\n\n/**\n * @param placement\n */\nfunction getExpandedFallbackPlacements(placement: Placement): Placement[] {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  const oppositePlacement = getOppositePlacement(placement);\n\n  return [\n    getOppositeVariationPlacement(placement),\n    oppositePlacement,\n    getOppositeVariationPlacement(oppositePlacement)\n  ];\n}\n\n/**\n *\n */\nfunction flip({ state, options, name }: ModifierArguments<Options>) {\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = true,\n    fallbackPlacements: specifiedFallbackPlacements,\n    padding,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    flipVariations = true,\n    allowedAutoPlacements\n  } = options;\n\n  const preferredPlacement = state.options.placement;\n  const basePlacement = getBasePlacement(preferredPlacement);\n  const isBasePlacement = basePlacement === preferredPlacement;\n\n  const fallbackPlacements =\n    specifiedFallbackPlacements ||\n    (isBasePlacement || !flipVariations\n      ? [getOppositePlacement(preferredPlacement)]\n      : getExpandedFallbackPlacements(preferredPlacement));\n\n  const placements = [preferredPlacement, ...fallbackPlacements].reduce(\n    (acc, placement) =>\n      acc.concat(\n        getBasePlacement(placement) === auto\n          ? computeAutoPlacement(state, {\n              placement,\n              boundary,\n              rootBoundary,\n              padding,\n              flipVariations,\n              allowedAutoPlacements\n            })\n          : placement\n      ),\n    []\n  );\n\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n\n  const checksMap = new Map();\n  let makeFallbackChecks = true;\n  let firstFittingPlacement = placements[0];\n\n  for (let i = 0; i < placements.length; i++) {\n    const placement = placements[i];\n    const basePlacement = getBasePlacement(placement);\n    const isStartVariation = getVariation(placement) === start;\n    const isVertical = [top, bottom].indexOf(basePlacement) >= 0;\n    const len = isVertical ? 'width' : 'height';\n\n    const overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n\n    let mainVariationSide: any = isVertical ? (isStartVariation ? right : left) : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    const altVariationSide: any = getOppositePlacement(mainVariationSide);\n\n    const checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(check => check)) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    const numberOfChecks = flipVariations ? 3 : 1;\n\n    for (let i = numberOfChecks; i > 0; i--) {\n      const fittingPlacement = placements.find(placement => {\n        const checks = checksMap.get(placement);\n        if (checks) {\n          return checks.slice(0, i).every(check => check);\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        break;\n      }\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type FlipModifier = Modifier<'flip', Options>;\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: { _skip: false }\n} as FlipModifier;\n"]},"metadata":{},"sourceType":"module"}