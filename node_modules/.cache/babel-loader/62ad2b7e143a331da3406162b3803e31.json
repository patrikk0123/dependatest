{"ast":null,"code":"import _toConsumableArray from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport mergeByName from './utils/mergeByName';\nimport detectOverflow from './utils/detectOverflow';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\nexport * from './types';\nexport * from './enums';\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n/**\n * @param args\n */\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n/**\n * @param generatorOptions\n */\n\n\nexport function popperGenerator() {\n  var generatorOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _generatorOptions$def = generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(_toConsumableArray(defaultModifiers), _toConsumableArray(state.options.modifiers)))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (false\n        /* __DEV__*/\n        ) {\n          var modifiers = uniqueBy([].concat(_toConsumableArray(orderedModifiers), _toConsumableArray(state.options.modifiers)), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (false\n          /* __DEV__*/\n          ) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (false\n          /* __DEV__*/\n          ) {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (false\n      /* __DEV__*/\n      ) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    /**\n     *\n     */\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    /**\n     *\n     */\n\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };","map":{"version":3,"mappings":"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","names":["getCompositeRect","getLayoutRect","listScrollParents","getOffsetParent","getComputedStyle","orderModifiers","debounce","validateModifiers","uniqueBy","getBasePlacement","mergeByName","detectOverflow","isElement","auto","INVALID_ELEMENT_ERROR","INFINITE_LOOP_ERROR","DEFAULT_OPTIONS","placement","modifiers","strategy","areValidElements","args","some","element","getBoundingClientRect","popperGenerator","generatorOptions","defaultModifiers","defaultOptions","createPopper","reference","popper","options","state","orderedModifiers","modifiersData","elements","attributes","styles","effectCleanupFns","isDestroyed","instance","setOptions","cleanupModifierEffects","Object","scrollParents","contextElement","filter","m","enabled","name","flipModifier","find","console","error","join","marginTop","marginRight","marginBottom","marginLeft","parseFloat","margin","warn","runModifierEffects","update","forceUpdate","rects","reset","forEach","modifier","data","__debug_loops__","index","length","fn","Promise","resolve","destroy","then","onFirstUpdate","effect","cleanupFn","noopFn","push"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/index.ts"],"sourcesContent":["// @ts-nocheck\nimport { State, OptionsGeneric, Modifier, Instance, VirtualElement } from './types';\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport mergeByName from './utils/mergeByName';\nimport detectOverflow from './utils/detectOverflow';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\n\nexport * from './types';\nexport * from './enums';\n\nconst INVALID_ELEMENT_ERROR =\n  'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nconst INFINITE_LOOP_ERROR =\n  'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\n\nconst DEFAULT_OPTIONS: OptionsGeneric<any> = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\ninterface PopperGeneratorArgs {\n  defaultModifiers?: Modifier<any, any>[];\n  defaultOptions?: Partial<OptionsGeneric<any>>;\n}\n\n/**\n * @param args\n */\nfunction areValidElements(...args: any[]): boolean {\n  return !args.some(element => !(element && typeof element.getBoundingClientRect === 'function'));\n}\n\n/**\n * @param generatorOptions\n */\nexport function popperGenerator(generatorOptions: PopperGeneratorArgs = {}) {\n  const { defaultModifiers = [], defaultOptions = DEFAULT_OPTIONS } = generatorOptions;\n\n  return function createPopper<TModifier extends Partial<Modifier<any, any>>>(\n    reference: Element | VirtualElement,\n    popper: HTMLElement,\n    options: Partial<OptionsGeneric<TModifier>> = defaultOptions\n  ): Instance {\n    let state: Partial<State> = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: { ...DEFAULT_OPTIONS, ...defaultOptions },\n      modifiersData: {},\n      elements: {\n        reference,\n        popper\n      },\n      attributes: {},\n      styles: {}\n    };\n\n    let effectCleanupFns: (() => void)[] = [];\n    let isDestroyed = false;\n\n    const instance = {\n      state,\n      setOptions(options) {\n        cleanupModifierEffects();\n\n        state.options = {\n          // $FlowFixMe\n          ...defaultOptions,\n          ...state.options,\n          ...options\n        };\n\n        state.scrollParents = {\n          reference: isElement(reference)\n            ? listScrollParents(reference)\n            : reference.contextElement\n            ? listScrollParents(reference.contextElement)\n            : [],\n          popper: listScrollParents(popper)\n        };\n\n        // Orders the modifiers based on their dependencies and `phase`\n        // properties\n        const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers, ...state.options.modifiers]));\n\n        // Strip out disabled modifiers\n        state.orderedModifiers = orderedModifiers.filter(m => m.enabled);\n\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n        if (false /* __DEV__*/) {\n          const modifiers = uniqueBy([...orderedModifiers, ...state.options.modifiers], ({ name }) => name);\n\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            const flipModifier = state.orderedModifiers.find(({ name }) => name === 'flip');\n\n            if (!flipModifier) {\n              console.error(\n                ['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' ')\n              );\n            }\n          }\n\n          const { marginTop, marginRight, marginBottom, marginLeft } = getComputedStyle(popper);\n\n          // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(margin => parseFloat(margin))) {\n            console.warn(\n              [\n                'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                'between the popper and its reference element or boundary.',\n                'To replicate margin, use the `offset` modifier, as well as',\n                'the `padding` option in the `preventOverflow` and `flip`',\n                'modifiers.'\n              ].join(' ')\n            );\n          }\n        }\n\n        runModifierEffects();\n\n        return instance.update();\n      },\n\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        const { reference, popper } = state.elements;\n\n        // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n        if (!areValidElements(reference, popper)) {\n          if (false /* __DEV__*/) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n\n        // Store the reference and popper rects to be read by modifiers\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        };\n\n        // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n        state.reset = false;\n\n        state.placement = state.options.placement;\n\n        // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n        state.orderedModifiers.forEach(\n          modifier =>\n            (state.modifiersData[modifier.name] = {\n              ...modifier.data\n            })\n        );\n\n        let __debug_loops__ = 0;\n        for (let index = 0; index < state.orderedModifiers.length; index++) {\n          if (false /* __DEV__*/) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          const { fn, options = {}, name } = state.orderedModifiers[index];\n\n          if (typeof fn === 'function') {\n            state = fn({ state, options, name, instance }) || state;\n          }\n        }\n      },\n\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce<Partial<State>>(\n        () =>\n          new Promise<Partial<State>>(resolve => {\n            instance.forceUpdate();\n            resolve(state);\n          })\n      ),\n\n      destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (false /* __DEV__*/) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n\n    instance.setOptions(options).then(state => {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    });\n\n    // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n    /**\n     *\n     */\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(({ name, options = {}, effect }) => {\n        if (typeof effect === 'function') {\n          const cleanupFn = effect({ state, name, instance, options });\n          const noopFn = () => {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    /**\n     *\n     */\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(fn => fn());\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nexport const createPopper = popperGenerator();\n\n// eslint-disable-next-line import/no-unused-modules\nexport { detectOverflow };\n"]},"metadata":{},"sourceType":"module"}