{"ast":null,"code":"/**\n * body-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport isEqual from 'lodash/isEqual';\nimport * as React from 'react';\nimport { columnsAreEqual } from './columns-are-equal';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nexport class BodyRow extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    const {\n      columns,\n      rowData\n    } = this.props; // Check for row based override.\n\n    const {\n      renderers\n    } = nextProps;\n\n    if (renderers && renderers.row && renderers.row.shouldComponentUpdate) {\n      if (typeof renderers.row.shouldComponentUpdate === 'function') {\n        return renderers.row.shouldComponentUpdate.call(this, nextProps, {}, {});\n      }\n\n      return true;\n    }\n\n    return !(columnsAreEqual(columns, nextProps.columns) && isEqual(rowData, nextProps.rowData));\n  }\n\n  render() {\n    const {\n      columns,\n      renderers,\n      onRow,\n      rowKey,\n      rowIndex,\n      rowData\n    } = this.props;\n    return React.createElement(renderers.row, onRow(rowData, {\n      rowIndex,\n      rowKey\n    }), columns.map((column, columnIndex) => {\n      const {\n        property,\n        cell,\n        props\n      } = column;\n      const evaluatedProperty = property || cell && cell.property;\n      const {\n        transforms = [],\n        formatters = []\n      } = cell || {};\n      const extraParameters = {\n        columnIndex,\n        property: evaluatedProperty,\n        column,\n        rowData,\n        rowIndex,\n        rowKey\n      };\n      const transformed = evaluateTransforms(transforms, rowData[evaluatedProperty], extraParameters);\n\n      if (!transformed) {\n        // eslint-disable-next-line no-console\n        console.warn('Table.Body - Failed to receive a transformed result');\n      }\n\n      let additionalFormaters = [];\n\n      if (rowData[evaluatedProperty]) {\n        additionalFormaters = rowData[evaluatedProperty].formatters;\n      }\n\n      return React.createElement(renderers.cell, Object.assign({\n        key: `col-${columnIndex}-row-${rowIndex}`\n      }, mergeProps(props, cell && cell.props, transformed)), !rowData.fullWidth && transformed.children || evaluateFormatters([...formatters, ...additionalFormaters])(rowData[`_${evaluatedProperty}`] || rowData[evaluatedProperty], extraParameters));\n    }));\n  }\n\n}\nBodyRow.displayName = 'BodyRow';\nBodyRow.defaultProps = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onRow: function () {\n    return {};\n  }\n};","map":{"version":3,"mappings":"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","names":["isEqual","React","columnsAreEqual","evaluateFormatters","evaluateTransforms","mergeProps","BodyRow","Component","shouldComponentUpdate","nextProps","columns","rowData","props","renderers","row","call","render","onRow","rowKey","rowIndex","createElement","map","column","columnIndex","property","cell","evaluatedProperty","transforms","formatters","extraParameters","transformed","console","warn","additionalFormaters","Object","key","fullWidth","children"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-table/src/components/Table/base/body-row.tsx"],"sourcesContent":["/**\n * body-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport isEqual from 'lodash/isEqual';\nimport * as React from 'react';\nimport { columnsAreEqual } from './columns-are-equal';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { createElementType, formatterValueType, ColumnType, ColumnsType, RowType, RendererType } from './types';\n\nexport interface BodyRowProps {\n  columns: ColumnsType;\n  renderers: RendererType;\n  onRow?: Function;\n  rowIndex: number;\n  rowData: RowType;\n  rowKey: string;\n}\n\nexport class BodyRow extends React.Component<BodyRowProps, {}> {\n  static displayName = 'BodyRow';\n  static defaultProps = {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onRow: (...args: any) => ({})\n  };\n\n  shouldComponentUpdate(nextProps: BodyRowProps) {\n    const { columns, rowData } = this.props;\n\n    // Check for row based override.\n    const { renderers } = nextProps;\n\n    if (renderers && renderers.row && (renderers.row as React.Component).shouldComponentUpdate) {\n      if (typeof (renderers.row as React.Component).shouldComponentUpdate === 'function') {\n        return (renderers.row as React.Component).shouldComponentUpdate.call(this, nextProps, {}, {});\n      }\n\n      return true;\n    }\n\n    return !(columnsAreEqual(columns, nextProps.columns) && isEqual(rowData, nextProps.rowData));\n  }\n  render() {\n    const { columns, renderers, onRow, rowKey, rowIndex, rowData } = this.props;\n\n    return React.createElement(\n      renderers.row as createElementType,\n      onRow(rowData, { rowIndex, rowKey }),\n      (columns as []).map((column: ColumnType, columnIndex: number) => {\n        const { property, cell, props } = column;\n        const evaluatedProperty = (property || (cell && cell.property)) as string;\n        const { transforms = [], formatters = [] } = cell || {};\n        const extraParameters = {\n          columnIndex,\n          property: evaluatedProperty,\n          column,\n          rowData,\n          rowIndex,\n          rowKey\n        };\n        const transformed = evaluateTransforms(transforms, rowData[evaluatedProperty], extraParameters);\n\n        if (!transformed) {\n          // eslint-disable-next-line no-console\n          console.warn('Table.Body - Failed to receive a transformed result');\n        }\n\n        let additionalFormaters = [];\n        if (rowData[evaluatedProperty]) {\n          additionalFormaters = rowData[evaluatedProperty].formatters;\n        }\n\n        return React.createElement(\n          renderers.cell as createElementType,\n          {\n            key: `col-${columnIndex}-row-${rowIndex}`,\n            ...mergeProps(props, cell && cell.props, transformed)\n          },\n          (!rowData.fullWidth && transformed.children) ||\n            evaluateFormatters([...formatters, ...additionalFormaters])(\n              rowData[`_${evaluatedProperty}`] || (rowData[evaluatedProperty] as formatterValueType),\n              extraParameters\n            )\n        );\n      })\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}