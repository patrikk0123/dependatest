{"ast":null,"code":"/* ansi_up.js\n * author : Dru Nelson\n * license : MIT\n * http://github.com/drudru/ansi_up\n */\n// Used internally when breaking up the raw text into packets\nvar PacketKind;\n\n(function (PacketKind) {\n  PacketKind[PacketKind[\"EOS\"] = 0] = \"EOS\";\n  PacketKind[PacketKind[\"Text\"] = 1] = \"Text\";\n  PacketKind[PacketKind[\"Incomplete\"] = 2] = \"Incomplete\";\n  PacketKind[PacketKind[\"ESC\"] = 3] = \"ESC\";\n  PacketKind[PacketKind[\"Unknown\"] = 4] = \"Unknown\";\n  PacketKind[PacketKind[\"SGR\"] = 5] = \"SGR\";\n  PacketKind[PacketKind[\"OSCURL\"] = 6] = \"OSCURL\"; // Operating System Command\n})(PacketKind || (PacketKind = {})); //\n// MAIN CLASS\n//\n\n\nexport default class AnsiUp {\n  constructor() {\n    this.VERSION = '5.0.1';\n    this._url_whitelist = {}; // All construction occurs here\n\n    this.setup_palettes();\n    this.resetStyles();\n  }\n\n  set use_classes(arg) {\n    this._use_classes = arg;\n  }\n\n  get use_classes() {\n    return this._use_classes;\n  }\n\n  set url_whitelist(arg) {\n    this._url_whitelist = arg;\n  }\n\n  get url_whitelist() {\n    return this._url_whitelist;\n  }\n\n  setup_palettes() {\n    this.ansi_colors = [// Normal colors\n    [{\n      rgb: [0, 0, 0],\n      class_name: 'ansi-black'\n    }, {\n      rgb: [187, 0, 0],\n      class_name: 'ansi-red'\n    }, {\n      rgb: [0, 187, 0],\n      class_name: 'ansi-green'\n    }, {\n      rgb: [187, 187, 0],\n      class_name: 'ansi-yellow'\n    }, {\n      rgb: [0, 0, 187],\n      class_name: 'ansi-blue'\n    }, {\n      rgb: [187, 0, 187],\n      class_name: 'ansi-magenta'\n    }, {\n      rgb: [0, 187, 187],\n      class_name: 'ansi-cyan'\n    }, {\n      rgb: [255, 255, 255],\n      class_name: 'ansi-white'\n    }], // Bright colors\n    [{\n      rgb: [85, 85, 85],\n      class_name: 'ansi-bright-black'\n    }, {\n      rgb: [255, 85, 85],\n      class_name: 'ansi-bright-red'\n    }, {\n      rgb: [0, 255, 0],\n      class_name: 'ansi-bright-green'\n    }, {\n      rgb: [255, 255, 85],\n      class_name: 'ansi-bright-yellow'\n    }, {\n      rgb: [85, 85, 255],\n      class_name: 'ansi-bright-blue'\n    }, {\n      rgb: [255, 85, 255],\n      class_name: 'ansi-bright-magenta'\n    }, {\n      rgb: [85, 255, 255],\n      class_name: 'ansi-bright-cyan'\n    }, {\n      rgb: [255, 255, 255],\n      class_name: 'ansi-bright-white'\n    }]];\n    this.palette_256 = []; // Index 0..15 : Ansi-Colors\n\n    this.ansi_colors.forEach(palette => {\n      palette.forEach(rec => {\n        this.palette_256.push(rec);\n      });\n    }); // Index 16..231 : RGB 6x6x6\n    // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n\n    const levels = [0, 95, 135, 175, 215, 255];\n\n    for (let r = 0; r < 6; ++r) {\n      for (let g = 0; g < 6; ++g) {\n        for (let b = 0; b < 6; ++b) {\n          const col = {\n            rgb: [levels[r], levels[g], levels[b]],\n            class_name: 'truecolor'\n          };\n          this.palette_256.push(col);\n        }\n      }\n    } // Index 232..255 : Grayscale\n\n\n    let grey_level = 8;\n\n    for (let i = 0; i < 24; ++i, grey_level += 10) {\n      const gry = {\n        rgb: [grey_level, grey_level, grey_level],\n        class_name: 'truecolor'\n      };\n      this.palette_256.push(gry);\n    }\n  }\n\n  escape_txt_for_html(txt) {\n    return txt.replace(/[&<>\"']/gm, str => {\n      if (str === '&') {\n        return '&amp;';\n      }\n\n      if (str === '<') {\n        return '&lt;';\n      }\n\n      if (str === '>') {\n        return '&gt;';\n      }\n\n      if (str === '\"') {\n        return '&quot;';\n      }\n\n      if (str === \"'\") {\n        return '&#x27;';\n      }\n    });\n  }\n\n  append_buffer(txt) {\n    const str = this._buffer + txt;\n    this._buffer = str;\n  }\n\n  get_next_packet() {\n    const pkt = {\n      kind: PacketKind.EOS,\n      text: '',\n      url: ''\n    };\n    const len = this._buffer.length;\n\n    if (len == 0) {\n      return pkt;\n    }\n\n    const pos = this._buffer.indexOf('\\x1B'); // The most common case, no ESC codes\n\n\n    if (pos == -1) {\n      pkt.kind = PacketKind.Text;\n      pkt.text = this._buffer;\n      this._buffer = '';\n      return pkt;\n    }\n\n    if (pos > 0) {\n      pkt.kind = PacketKind.Text;\n      pkt.text = this._buffer.slice(0, pos);\n      this._buffer = this._buffer.slice(pos);\n      return pkt;\n    } // NOW WE HANDLE ESCAPES\n\n\n    if (pos == 0) {\n      if (len == 1) {\n        // Lone ESC in Buffer, We don't know yet\n        pkt.kind = PacketKind.Incomplete;\n        return pkt;\n      }\n\n      const next_char = this._buffer.charAt(1); // We treat this as a single ESC\n      // Which effecitvely shows\n\n\n      if (next_char != '[' && next_char != ']') {\n        // DeMorgan\n        pkt.kind = PacketKind.ESC;\n        pkt.text = this._buffer.slice(0, 1);\n        this._buffer = this._buffer.slice(1);\n        return pkt;\n      } // OK is this an SGR or OSC that we handle\n      // SGR CHECK\n\n\n      if (next_char == '[') {\n        // We do this regex initialization here so\n        // we can keep the regex close to its use (Readability)\n        // All ansi codes are typically in the following format.\n        // We parse it and focus specifically on the\n        // graphics commands (SGR)\n        //\n        // CONTROL-SEQUENCE-INTRODUCER CSI             (ESC, '[')\n        // PRIVATE-MODE-CHAR                           (!, <, >, ?)\n        // Numeric parameters separated by semicolons  ('0' - '9', ';')\n        // Intermediate-modifiers                      (0x20 - 0x2f)\n        // COMMAND-CHAR                                (0x40 - 0x7e)\n        //\n        if (!this._csi_regex) {\n          this._csi_regex = rgx`\n                        ^                           # beginning of line\n                                                    #\n                                                    # First attempt\n                        (?:                         # legal sequence\n                          \\x1b\\[                      # CSI\n                          ([\\x3c-\\x3f]?)              # private-mode char\n                          ([\\d;]*)                    # any digits or semicolons\n                          ([\\x20-\\x2f]?               # an intermediate modifier\n                          [\\x40-\\x7e])                # the command\n                        )\n                        |                           # alternate (second attempt)\n                        (?:                         # illegal sequence\n                          \\x1b\\[                      # CSI\n                          [\\x20-\\x7e]*                # anything legal\n                          ([\\x00-\\x1f:])              # anything illegal\n                        )\n                    `;\n        }\n\n        const match = this._buffer.match(this._csi_regex); // This match is guaranteed to terminate (even on\n        // invalid input). The key is to match on legal and\n        // illegal sequences.\n        // The first alternate matches everything legal and\n        // the second matches everything illegal.\n        //\n        // If it doesn't match, then we have not received\n        // either the full sequence or an illegal sequence.\n        // If it does match, the presence of field 4 tells\n        // us whether it was legal or illegal.\n\n\n        if (match === null) {\n          pkt.kind = PacketKind.Incomplete;\n          return pkt;\n        } // match is an array\n        // 0 - total match\n        // 1 - private mode chars group\n        // 2 - digits and semicolons group\n        // 3 - command\n        // 4 - illegal char\n\n\n        if (match[4]) {\n          // Illegal sequence, just remove the ESC\n          pkt.kind = PacketKind.ESC;\n          pkt.text = this._buffer.slice(0, 1);\n          this._buffer = this._buffer.slice(1);\n          return pkt;\n        } // If not a valid SGR, we don't handle\n\n\n        if (match[1] != '' || match[3] != 'm') {\n          pkt.kind = PacketKind.Unknown;\n        } else {\n          pkt.kind = PacketKind.SGR;\n        }\n\n        pkt.text = match[2]; // Just the parameters\n\n        var rpos = match[0].length;\n        this._buffer = this._buffer.slice(rpos);\n        return pkt;\n      } // OSC CHECK\n\n\n      if (next_char == ']') {\n        if (len < 4) {\n          pkt.kind = PacketKind.Incomplete;\n          return pkt;\n        }\n\n        if (this._buffer.charAt(2) != '8' || this._buffer.charAt(3) != ';') {\n          // This is not a match, so we'll just treat it as ESC\n          pkt.kind = PacketKind.ESC;\n          pkt.text = this._buffer.slice(0, 1);\n          this._buffer = this._buffer.slice(1);\n          return pkt;\n        } // We do this regex initialization here so\n        // we can keep the regex close to its use (Readability)\n        // Matching a Hyperlink OSC with a regex is difficult\n        // because Javascript's regex engine doesn't support\n        // 'partial match' support.\n        //\n        // Therefore, we require the system to match the\n        // string-terminator(ST) before attempting a match.\n        // Once we find it, we attempt the Hyperlink-Begin\n        // match.\n        // If that goes ok, we scan forward for the next\n        // ST.\n        // Finally, we try to match it all and return\n        // the sequence.\n        // Also, it is important to note that we consider\n        // certain control characters as an invalidation of\n        // the entire sequence.\n        // We do regex initializations here so\n        // we can keep the regex close to its use (Readability)\n        // STRING-TERMINATOR\n        // This is likely to terminate in most scenarios\n        // because it will terminate on a newline\n\n\n        if (!this._osc_st) {\n          this._osc_st = rgxG`\n                        (?:                         # legal sequence\n                          (\\x1b\\\\)                    # ESC \\\n                          |                           # alternate\n                          (\\x07)                      # BEL (what xterm did)\n                        )\n                        |                           # alternate (second attempt)\n                        (                           # illegal sequence\n                          [\\x00-\\x06]                 # anything illegal\n                          |                           # alternate\n                          [\\x08-\\x1a]                 # anything illegal\n                          |                           # alternate\n                          [\\x1c-\\x1f]                 # anything illegal\n                        )\n                    `;\n        } // VERY IMPORTANT\n        // We do a stateful regex match with exec.\n        // If the regex is global, and it used with 'exec',\n        // then it will search starting at the 'lastIndex'\n        // If it matches, the regex can be used again to\n        // find the next match.\n\n\n        this._osc_st.lastIndex = 0;\n        {\n          const match = this._osc_st.exec(this._buffer);\n\n          if (match === null) {\n            pkt.kind = PacketKind.Incomplete;\n            return pkt;\n          } // If an illegal character was found, bail on the match\n\n\n          if (match[3]) {\n            // Illegal sequence, just remove the ESC\n            pkt.kind = PacketKind.ESC;\n            pkt.text = this._buffer.slice(0, 1);\n            this._buffer = this._buffer.slice(1);\n            return pkt;\n          }\n        } // OK - we might have the prefix and URI\n        // Lets start our search for the next ST\n        // past this index\n\n        {\n          const match = this._osc_st.exec(this._buffer);\n\n          if (match === null) {\n            pkt.kind = PacketKind.Incomplete;\n            return pkt;\n          } // If an illegal character was found, bail on the match\n\n\n          if (match[3]) {\n            // Illegal sequence, just remove the ESC\n            pkt.kind = PacketKind.ESC;\n            pkt.text = this._buffer.slice(0, 1);\n            this._buffer = this._buffer.slice(1);\n            return pkt;\n          }\n        } // OK, at this point we should have a FULL match!\n        //\n        // Lets try to match that now\n\n        if (!this._osc_regex) {\n          this._osc_regex = rgx`\n                        ^                           # beginning of line\n                                                    #\n                        \\x1b\\]8;                    # OSC Hyperlink\n                        [\\x20-\\x3a\\x3c-\\x7e]*       # params (excluding ;)\n                        ;                           # end of params\n                        ([\\x21-\\x7e]{0,512})        # URL capture\n                        (?:                         # ST\n                          (?:\\x1b\\\\)                  # ESC \\\n                          |                           # alternate\n                          (?:\\x07)                    # BEL (what xterm did)\n                        )\n                        ([\\x20-\\x7e]+)              # TEXT capture\n                        \\x1b\\]8;;                   # OSC Hyperlink End\n                        (?:                         # ST\n                          (?:\\x1b\\\\)                  # ESC \\\n                          |                           # alternate\n                          (?:\\x07)                    # BEL (what xterm did)\n                        )\n                    `;\n        }\n\n        const match = this._buffer.match(this._osc_regex);\n\n        if (match === null) {\n          // Illegal sequence, just remove the ESC\n          pkt.kind = PacketKind.ESC;\n          pkt.text = this._buffer.slice(0, 1);\n          this._buffer = this._buffer.slice(1);\n          return pkt;\n        } // match is an array\n        // 0 - total match\n        // 1 - URL\n        // 2 - Text\n        // If a valid SGR\n\n\n        pkt.kind = PacketKind.OSCURL;\n        pkt.url = match[1];\n        pkt.text = match[2];\n        var rpos = match[0].length;\n        this._buffer = this._buffer.slice(rpos);\n        return pkt;\n      }\n    }\n  }\n\n  ansi_to_html(txt) {\n    this.append_buffer(txt);\n    const blocks = [];\n\n    while (true) {\n      const packet = this.get_next_packet();\n\n      if (packet.kind == PacketKind.EOS || packet.kind == PacketKind.Incomplete) {\n        break;\n      } // Drop single ESC or Unknown CSI\n\n\n      if (packet.kind == PacketKind.ESC || packet.kind == PacketKind.Unknown) {\n        continue;\n      }\n\n      if (packet.kind == PacketKind.Text) {\n        blocks.push(this.transform_to_html(this.with_state(packet)));\n      } else if (packet.kind == PacketKind.SGR) {\n        this.process_ansi(packet);\n      } else if (packet.kind == PacketKind.OSCURL) {\n        blocks.push(this.process_hyperlink(packet));\n      }\n    }\n\n    return blocks.join('');\n  }\n\n  resetStyles() {\n    this._use_classes = false;\n    this.bold = false;\n    this.italic = false;\n    this.underline = false;\n    this.fg = this.bg = null;\n    this._buffer = '';\n    this._url_whitelist = {\n      http: 1,\n      https: 1\n    };\n  }\n\n  with_state(pkt) {\n    return {\n      bold: this.bold,\n      italic: this.italic,\n      underline: this.underline,\n      fg: this.fg,\n      bg: this.bg,\n      text: pkt.text\n    };\n  }\n\n  process_ansi(pkt) {\n    // Ok - we have a valid \"SGR\" (Select Graphic Rendition)\n    const sgr_cmds = pkt.text.split(';'); // Each of these params affects the SGR state\n    // Why do we shift through the array instead of a forEach??\n    // ... because some commands consume the params that follow !\n\n    while (sgr_cmds.length > 0) {\n      const sgr_cmd_str = sgr_cmds.shift();\n      const num = parseInt(sgr_cmd_str, 10);\n\n      if (isNaN(num) || num === 0) {\n        this.fg = this.bg = null;\n        this.bold = false;\n        this.italic = false;\n        this.underline = false;\n      } else if (num === 1) {\n        this.bold = true;\n      } else if (num === 3) {\n        this.italic = true;\n      } else if (num === 4) {\n        this.underline = true;\n      } else if (num === 22) {\n        this.bold = false;\n      } else if (num === 23) {\n        this.italic = false;\n      } else if (num === 24) {\n        this.underline = false;\n      } else if (num === 39) {\n        this.fg = null;\n      } else if (num === 49) {\n        this.bg = null;\n      } else if (num >= 30 && num < 38) {\n        this.fg = this.ansi_colors[0][num - 30];\n      } else if (num >= 40 && num < 48) {\n        this.bg = this.ansi_colors[0][num - 40];\n      } else if (num >= 90 && num < 98) {\n        this.fg = this.ansi_colors[1][num - 90];\n      } else if (num >= 100 && num < 108) {\n        this.bg = this.ansi_colors[1][num - 100];\n      } else if (num === 38 || num === 48) {\n        // extended set foreground/background color\n        // validate that param exists\n        if (sgr_cmds.length > 0) {\n          // extend color (38=fg, 48=bg)\n          const is_foreground = num === 38;\n          const mode_cmd = sgr_cmds.shift(); // MODE '5' - 256 color palette\n\n          if (mode_cmd === '5' && sgr_cmds.length > 0) {\n            const palette_index = parseInt(sgr_cmds.shift(), 10);\n\n            if (palette_index >= 0 && palette_index <= 255) {\n              if (is_foreground) {\n                this.fg = this.palette_256[palette_index];\n              } else {\n                this.bg = this.palette_256[palette_index];\n              }\n            }\n          } // MODE '2' - True Color\n\n\n          if (mode_cmd === '2' && sgr_cmds.length > 2) {\n            const r = parseInt(sgr_cmds.shift(), 10);\n            const g = parseInt(sgr_cmds.shift(), 10);\n            const b = parseInt(sgr_cmds.shift(), 10);\n\n            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {\n              const c = {\n                rgb: [r, g, b],\n                class_name: 'truecolor'\n              };\n\n              if (is_foreground) {\n                this.fg = c;\n              } else {\n                this.bg = c;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  transform_to_html(fragment) {\n    const txt = fragment.text;\n\n    if (txt.length === 0) {\n      return txt;\n    } // txt = this.escape_txt_for_html(txt);\n    // If colors not set, default style is used\n\n\n    if (!fragment.bold && !fragment.italic && !fragment.underline && fragment.fg === null && fragment.bg === null) {\n      return txt;\n    }\n\n    const styles = [];\n    const classes = [];\n    const fg = fragment.fg;\n    const bg = fragment.bg; // Note on bold: https://stackoverflow.com/questions/6737005/what-are-some-advantages-to-using-span-style-font-weightbold-rather-than-b?rq=1\n\n    if (fragment.bold) {\n      styles.push('font-weight:bold');\n    }\n\n    if (fragment.italic) {\n      styles.push('font-style:italic');\n    }\n\n    if (fragment.underline) {\n      styles.push('text-decoration:underline');\n    }\n\n    if (!this._use_classes) {\n      // USE INLINE STYLES\n      if (fg) {\n        styles.push(`color:rgb(${fg.rgb.join(',')})`);\n      }\n\n      if (bg) {\n        styles.push(`background-color:rgb(${bg.rgb})`);\n      }\n    } else {\n      // USE CLASSES\n      if (fg) {\n        if (fg.class_name !== 'truecolor') {\n          classes.push(`${fg.class_name}-fg`);\n        } else {\n          styles.push(`color:rgb(${fg.rgb.join(',')})`);\n        }\n      }\n\n      if (bg) {\n        if (bg.class_name !== 'truecolor') {\n          classes.push(`${bg.class_name}-bg`);\n        } else {\n          styles.push(`background-color:rgb(${bg.rgb.join(',')})`);\n        }\n      }\n    }\n\n    let class_string = '';\n    let style_string = '';\n\n    if (classes.length) {\n      class_string = ` class=\"${classes.join(' ')}\"`;\n    }\n\n    if (styles.length) {\n      style_string = ` style=\"${styles.join(';')}\"`;\n    }\n\n    return `<span${style_string}${class_string}>${txt}</span>`;\n  }\n\n  process_hyperlink(pkt) {\n    // Check URL scheme\n    const parts = pkt.url.split(':');\n\n    if (parts.length < 1) {\n      return '';\n    }\n\n    if (!this._url_whitelist[parts[0]]) {\n      return '';\n    }\n\n    const result = `<a href=\"${this.escape_txt_for_html(pkt.url)}\">${this.escape_txt_for_html(pkt.text)}</a>`;\n    return result;\n  }\n\n} //\n// PRIVATE FUNCTIONS\n//\n// ES5 template string transformer\n\nfunction rgx(tmplObj) {\n  // Use the 'raw' value so we don't have to double backslash in a template string\n  const regexText = tmplObj.raw[0]; // Remove white-space and comments\n\n  const wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n  const txt2 = regexText.replace(wsrgx, '');\n  return new RegExp(txt2);\n} // ES5 template string transformer\n// Multi-Line On\n\n\nfunction rgxG(tmplObj) {\n  // Use the 'raw' value so we don't have to double backslash in a template string\n  const regexText = tmplObj.raw[0]; // Remove white-space and comments\n\n  const wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n  const txt2 = regexText.replace(wsrgx, '');\n  return new RegExp(txt2, 'g');\n}","map":{"version":3,"mappings":"AAAA;;;;;AA2BA;AAEA,IAAKA,UAAL;;AAAA,WAAKA,UAAL,EAAe;EACbA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA,gDAPa,CAON;AACR,CARD,EAAKA,UAAU,KAAVA,UAAU,MAAf,E,CAgBA;AACA;AACA;;;AAEA,eAAc,MAAOC,MAAP,CAAa;EA4BzBC;IA3BA,eAAU,OAAV;IAuBQ,sBAAsB,EAAtB,CAIR,CACE;;IACA,KAAKC,cAAL;IACA,KAAKC,WAAL;EACD;;EAEc,IAAXC,WAAW,CAACC,GAAD,EAAa;IAC1B,KAAKC,YAAL,GAAoBD,GAApB;EACD;;EAEc,IAAXD,WAAW;IACb,OAAO,KAAKE,YAAZ;EACD;;EAEgB,IAAbC,aAAa,CAACF,GAAD,EAAQ;IACvB,KAAKG,cAAL,GAAsBH,GAAtB;EACD;;EAEgB,IAAbE,aAAa;IACf,OAAO,KAAKC,cAAZ;EACD;;EAEON,cAAc;IACpB,KAAKO,WAAL,GAAmB,CACjB;IACA,CACE;MAAEC,GAAG,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAP;MAAkBC,UAAU,EAAE;IAA9B,CADF,EAEE;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,CAAP;MAAoBC,UAAU,EAAE;IAAhC,CAFF,EAGE;MAAED,GAAG,EAAE,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,CAAP;MAAoBC,UAAU,EAAE;IAAhC,CAHF,EAIE;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,CAAX,CAAP;MAAsBC,UAAU,EAAE;IAAlC,CAJF,EAKE;MAAED,GAAG,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,CAAP;MAAoBC,UAAU,EAAE;IAAhC,CALF,EAME;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,CAAN,EAAS,GAAT,CAAP;MAAsBC,UAAU,EAAE;IAAlC,CANF,EAOE;MAAED,GAAG,EAAE,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAP;MAAsBC,UAAU,EAAE;IAAlC,CAPF,EAQE;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAP;MAAwBC,UAAU,EAAE;IAApC,CARF,CAFiB,EAajB;IACA,CACE;MAAED,GAAG,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,CAAP;MAAqBC,UAAU,EAAE;IAAjC,CADF,EAEE;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,EAAN,EAAU,EAAV,CAAP;MAAsBC,UAAU,EAAE;IAAlC,CAFF,EAGE;MAAED,GAAG,EAAE,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,CAAP;MAAoBC,UAAU,EAAE;IAAhC,CAHF,EAIE;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,EAAX,CAAP;MAAuBC,UAAU,EAAE;IAAnC,CAJF,EAKE;MAAED,GAAG,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,GAAT,CAAP;MAAsBC,UAAU,EAAE;IAAlC,CALF,EAME;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,EAAN,EAAU,GAAV,CAAP;MAAuBC,UAAU,EAAE;IAAnC,CANF,EAOE;MAAED,GAAG,EAAE,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,CAAP;MAAuBC,UAAU,EAAE;IAAnC,CAPF,EAQE;MAAED,GAAG,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAP;MAAwBC,UAAU,EAAE;IAApC,CARF,CAdiB,CAAnB;IA0BA,KAAKC,WAAL,GAAmB,EAAnB,CA3BoB,CA6BpB;;IACA,KAAKH,WAAL,CAAiBI,OAAjB,CAAyBC,OAAO,IAAG;MACjCA,OAAO,CAACD,OAAR,CAAgBE,GAAG,IAAG;QACpB,KAAKH,WAAL,CAAiBI,IAAjB,CAAsBD,GAAtB;MACD,CAFD;IAGD,CAJD,EA9BoB,CAoCpB;IACA;;IACA,MAAME,MAAM,GAAG,CAAC,CAAD,EAAI,EAAJ,EAAQ,GAAR,EAAa,GAAb,EAAkB,GAAlB,EAAuB,GAAvB,CAAf;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;MAC1B,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;QAC1B,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;UAC1B,MAAMC,GAAG,GAAG;YAAEX,GAAG,EAAE,CAACO,MAAM,CAACC,CAAD,CAAP,EAAYD,MAAM,CAACE,CAAD,CAAlB,EAAuBF,MAAM,CAACG,CAAD,CAA7B,CAAP;YAA0CT,UAAU,EAAE;UAAtD,CAAZ;UACA,KAAKC,WAAL,CAAiBI,IAAjB,CAAsBK,GAAtB;QACD;MACF;IACF,CA9CmB,CAgDpB;;;IACA,IAAIC,UAAU,GAAG,CAAjB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwB,EAAEA,CAAF,EAAKD,UAAU,IAAI,EAA3C,EAA+C;MAC7C,MAAME,GAAG,GAAG;QAAEd,GAAG,EAAE,CAACY,UAAD,EAAaA,UAAb,EAAyBA,UAAzB,CAAP;QAA6CX,UAAU,EAAE;MAAzD,CAAZ;MACA,KAAKC,WAAL,CAAiBI,IAAjB,CAAsBQ,GAAtB;IACD;EACF;;EAEOC,mBAAmB,CAACC,GAAD,EAAY;IACrC,OAAOA,GAAG,CAACC,OAAJ,CAAY,WAAZ,EAAyBC,GAAG,IAAG;MACpC,IAAIA,GAAG,KAAK,GAAZ,EAAiB;QACf,OAAO,OAAP;MACD;;MACD,IAAIA,GAAG,KAAK,GAAZ,EAAiB;QACf,OAAO,MAAP;MACD;;MACD,IAAIA,GAAG,KAAK,GAAZ,EAAiB;QACf,OAAO,MAAP;MACD;;MACD,IAAIA,GAAG,KAAK,GAAZ,EAAiB;QACf,OAAO,QAAP;MACD;;MACD,IAAIA,GAAG,KAAK,GAAZ,EAAiB;QACf,OAAO,QAAP;MACD;IACF,CAhBM,CAAP;EAiBD;;EAEOC,aAAa,CAACH,GAAD,EAAY;IAC/B,MAAME,GAAG,GAAG,KAAKE,OAAL,GAAeJ,GAA3B;IACA,KAAKI,OAAL,GAAeF,GAAf;EACD;;EAEOG,eAAe;IACrB,MAAMC,GAAG,GAAG;MACVC,IAAI,EAAElC,UAAU,CAACmC,GADP;MAEVC,IAAI,EAAE,EAFI;MAGVC,GAAG,EAAE;IAHK,CAAZ;IAMA,MAAMC,GAAG,GAAG,KAAKP,OAAL,CAAaQ,MAAzB;;IACA,IAAID,GAAG,IAAI,CAAX,EAAc;MACZ,OAAOL,GAAP;IACD;;IAED,MAAMO,GAAG,GAAG,KAAKT,OAAL,CAAaU,OAAb,CAAqB,MAArB,CAAZ,CAZqB,CAcrB;;;IACA,IAAID,GAAG,IAAI,CAAC,CAAZ,EAAe;MACbP,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC0C,IAAtB;MACAT,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAhB;MACA,KAAKA,OAAL,GAAe,EAAf;MACA,OAAOE,GAAP;IACD;;IAED,IAAIO,GAAG,GAAG,CAAV,EAAa;MACXP,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC0C,IAAtB;MACAT,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAL,CAAaY,KAAb,CAAmB,CAAnB,EAAsBH,GAAtB,CAAX;MACA,KAAKT,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmBH,GAAnB,CAAf;MACA,OAAOP,GAAP;IACD,CA3BoB,CA6BrB;;;IACA,IAAIO,GAAG,IAAI,CAAX,EAAc;MACZ,IAAIF,GAAG,IAAI,CAAX,EAAc;QACZ;QACAL,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC4C,UAAtB;QACA,OAAOX,GAAP;MACD;;MAED,MAAMY,SAAS,GAAG,KAAKd,OAAL,CAAae,MAAb,CAAoB,CAApB,CAAlB,CAPY,CASZ;MACA;;;MACA,IAAID,SAAS,IAAI,GAAb,IAAoBA,SAAS,IAAI,GAArC,EAA0C;QACxC;QACAZ,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC+C,GAAtB;QACAd,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAL,CAAaY,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CAAX;QACA,KAAKZ,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmB,CAAnB,CAAf;QACA,OAAOV,GAAP;MACD,CAjBW,CAmBZ;MAEA;;;MACA,IAAIY,SAAS,IAAI,GAAjB,EAAsB;QACpB;QACA;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QAEA,IAAI,CAAC,KAAKG,UAAV,EAAsB;UACpB,KAAKA,UAAL,GAAkBC,GAAG;;;;;;;;;;;;;;;;;qBAArB;QAkBD;;QAED,MAAMC,KAAK,GAAG,KAAKnB,OAAL,CAAamB,KAAb,CAAmB,KAAKF,UAAxB,CAAd,CApCoB,CAsCpB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;;QAEA,IAAIE,KAAK,KAAK,IAAd,EAAoB;UAClBjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC4C,UAAtB;UACA,OAAOX,GAAP;QACD,CApDmB,CAsDpB;QACA;QACA;QACA;QACA;QACA;;;QAEA,IAAIiB,KAAK,CAAC,CAAD,CAAT,EAAc;UACZ;UACAjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC+C,GAAtB;UACAd,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAL,CAAaY,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CAAX;UACA,KAAKZ,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmB,CAAnB,CAAf;UACA,OAAOV,GAAP;QACD,CAnEmB,CAqEpB;;;QACA,IAAIiB,KAAK,CAAC,CAAD,CAAL,IAAY,EAAZ,IAAkBA,KAAK,CAAC,CAAD,CAAL,IAAY,GAAlC,EAAuC;UACrCjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAACmD,OAAtB;QACD,CAFD,MAEO;UACLlB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAACoD,GAAtB;QACD;;QAEDnB,GAAG,CAACG,IAAJ,GAAWc,KAAK,CAAC,CAAD,CAAhB,CA5EoB,CA4EC;;QAErB,IAAIG,IAAI,GAAGH,KAAK,CAAC,CAAD,CAAL,CAASX,MAApB;QACA,KAAKR,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmBU,IAAnB,CAAf;QACA,OAAOpB,GAAP;MACD,CAvGW,CAyGZ;;;MACA,IAAIY,SAAS,IAAI,GAAjB,EAAsB;QACpB,IAAIP,GAAG,GAAG,CAAV,EAAa;UACXL,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC4C,UAAtB;UACA,OAAOX,GAAP;QACD;;QAED,IAAI,KAAKF,OAAL,CAAae,MAAb,CAAoB,CAApB,KAA0B,GAA1B,IAAiC,KAAKf,OAAL,CAAae,MAAb,CAAoB,CAApB,KAA0B,GAA/D,EAAoE;UAClE;UACAb,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC+C,GAAtB;UACAd,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAL,CAAaY,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CAAX;UACA,KAAKZ,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmB,CAAnB,CAAf;UACA,OAAOV,GAAP;QACD,CAZmB,CAcpB;QACA;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QAEA;QACA;QAEA;QACA;QACA;;;QAEA,IAAI,CAAC,KAAKqB,OAAV,EAAmB;UACjB,KAAKA,OAAL,GAAeC,IAAI;;;;;;;;;;;;;;qBAAnB;QAeD,CAxDmB,CA0DpB;QACA;QACA;QACA;QACA;QACA;;;QACA,KAAKD,OAAL,CAAaE,SAAb,GAAyB,CAAzB;QAEA;UACE,MAAMN,KAAK,GAAG,KAAKI,OAAL,CAAaG,IAAb,CAAkB,KAAK1B,OAAvB,CAAd;;UAEA,IAAImB,KAAK,KAAK,IAAd,EAAoB;YAClBjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC4C,UAAtB;YACA,OAAOX,GAAP;UACD,CANH,CAQE;;;UACA,IAAIiB,KAAK,CAAC,CAAD,CAAT,EAAc;YACZ;YACAjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC+C,GAAtB;YACAd,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAL,CAAaY,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CAAX;YACA,KAAKZ,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmB,CAAnB,CAAf;YACA,OAAOV,GAAP;UACD;QACF,CAlFmB,CAoFpB;QACA;QACA;;QAEA;UACE,MAAMiB,KAAK,GAAG,KAAKI,OAAL,CAAaG,IAAb,CAAkB,KAAK1B,OAAvB,CAAd;;UAEA,IAAImB,KAAK,KAAK,IAAd,EAAoB;YAClBjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC4C,UAAtB;YACA,OAAOX,GAAP;UACD,CANH,CAQE;;;UACA,IAAIiB,KAAK,CAAC,CAAD,CAAT,EAAc;YACZ;YACAjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC+C,GAAtB;YACAd,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAL,CAAaY,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CAAX;YACA,KAAKZ,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmB,CAAnB,CAAf;YACA,OAAOV,GAAP;UACD;QACF,CAxGmB,CA0GpB;QACA;QACA;;QAEA,IAAI,CAAC,KAAKyB,UAAV,EAAsB;UACpB,KAAKA,UAAL,GAAkBT,GAAG;;;;;;;;;;;;;;;;;;;qBAArB;QAoBD;;QAED,MAAMC,KAAK,GAAG,KAAKnB,OAAL,CAAamB,KAAb,CAAmB,KAAKQ,UAAxB,CAAd;;QAEA,IAAIR,KAAK,KAAK,IAAd,EAAoB;UAClB;UACAjB,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC+C,GAAtB;UACAd,GAAG,CAACG,IAAJ,GAAW,KAAKL,OAAL,CAAaY,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CAAX;UACA,KAAKZ,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmB,CAAnB,CAAf;UACA,OAAOV,GAAP;QACD,CA7ImB,CA+IpB;QACA;QACA;QACA;QAEA;;;QACAA,GAAG,CAACC,IAAJ,GAAWlC,UAAU,CAAC2D,MAAtB;QACA1B,GAAG,CAACI,GAAJ,GAAUa,KAAK,CAAC,CAAD,CAAf;QACAjB,GAAG,CAACG,IAAJ,GAAWc,KAAK,CAAC,CAAD,CAAhB;QAEA,IAAIG,IAAI,GAAGH,KAAK,CAAC,CAAD,CAAL,CAASX,MAApB;QACA,KAAKR,OAAL,GAAe,KAAKA,OAAL,CAAaY,KAAb,CAAmBU,IAAnB,CAAf;QACA,OAAOpB,GAAP;MACD;IACF;EACF;;EAED2B,YAAY,CAACjC,GAAD,EAAY;IACtB,KAAKG,aAAL,CAAmBH,GAAnB;IAEA,MAAMkC,MAAM,GAAa,EAAzB;;IAEA,OAAO,IAAP,EAAa;MACX,MAAMC,MAAM,GAAG,KAAK9B,eAAL,EAAf;;MAEA,IAAI8B,MAAM,CAAC5B,IAAP,IAAelC,UAAU,CAACmC,GAA1B,IAAiC2B,MAAM,CAAC5B,IAAP,IAAelC,UAAU,CAAC4C,UAA/D,EAA2E;QACzE;MACD,CALU,CAOX;;;MACA,IAAIkB,MAAM,CAAC5B,IAAP,IAAelC,UAAU,CAAC+C,GAA1B,IAAiCe,MAAM,CAAC5B,IAAP,IAAelC,UAAU,CAACmD,OAA/D,EAAwE;QACtE;MACD;;MAED,IAAIW,MAAM,CAAC5B,IAAP,IAAelC,UAAU,CAAC0C,IAA9B,EAAoC;QAClCmB,MAAM,CAAC5C,IAAP,CAAY,KAAK8C,iBAAL,CAAuB,KAAKC,UAAL,CAAgBF,MAAhB,CAAvB,CAAZ;MACD,CAFD,MAEO,IAAIA,MAAM,CAAC5B,IAAP,IAAelC,UAAU,CAACoD,GAA9B,EAAmC;QACxC,KAAKa,YAAL,CAAkBH,MAAlB;MACD,CAFM,MAEA,IAAIA,MAAM,CAAC5B,IAAP,IAAelC,UAAU,CAAC2D,MAA9B,EAAsC;QAC3CE,MAAM,CAAC5C,IAAP,CAAY,KAAKiD,iBAAL,CAAuBJ,MAAvB,CAAZ;MACD;IACF;;IAED,OAAOD,MAAM,CAACM,IAAP,CAAY,EAAZ,CAAP;EACD;;EAED/D,WAAW;IACT,KAAKG,YAAL,GAAoB,KAApB;IAEA,KAAK6D,IAAL,GAAY,KAAZ;IACA,KAAKC,MAAL,GAAc,KAAd;IACA,KAAKC,SAAL,GAAiB,KAAjB;IACA,KAAKC,EAAL,GAAU,KAAKC,EAAL,GAAU,IAApB;IAEA,KAAKzC,OAAL,GAAe,EAAf;IAEA,KAAKtB,cAAL,GAAsB;MAAEgE,IAAI,EAAE,CAAR;MAAWC,KAAK,EAAE;IAAlB,CAAtB;EACD;;EAEOV,UAAU,CAAC/B,GAAD,EAAgB;IAChC,OAAO;MACLmC,IAAI,EAAE,KAAKA,IADN;MAELC,MAAM,EAAE,KAAKA,MAFR;MAGLC,SAAS,EAAE,KAAKA,SAHX;MAILC,EAAE,EAAE,KAAKA,EAJJ;MAKLC,EAAE,EAAE,KAAKA,EALJ;MAMLpC,IAAI,EAAEH,GAAG,CAACG;IANL,CAAP;EAQD;;EAEO6B,YAAY,CAAChC,GAAD,EAAgB;IAClC;IAEA,MAAM0C,QAAQ,GAAG1C,GAAG,CAACG,IAAJ,CAASwC,KAAT,CAAe,GAAf,CAAjB,CAHkC,CAKlC;IAEA;IACA;;IACA,OAAOD,QAAQ,CAACpC,MAAT,GAAkB,CAAzB,EAA4B;MAC1B,MAAMsC,WAAW,GAAGF,QAAQ,CAACG,KAAT,EAApB;MACA,MAAMC,GAAG,GAAGC,QAAQ,CAACH,WAAD,EAAc,EAAd,CAApB;;MAEA,IAAII,KAAK,CAACF,GAAD,CAAL,IAAcA,GAAG,KAAK,CAA1B,EAA6B;QAC3B,KAAKR,EAAL,GAAU,KAAKC,EAAL,GAAU,IAApB;QACA,KAAKJ,IAAL,GAAY,KAAZ;QACA,KAAKC,MAAL,GAAc,KAAd;QACA,KAAKC,SAAL,GAAiB,KAAjB;MACD,CALD,MAKO,IAAIS,GAAG,KAAK,CAAZ,EAAe;QACpB,KAAKX,IAAL,GAAY,IAAZ;MACD,CAFM,MAEA,IAAIW,GAAG,KAAK,CAAZ,EAAe;QACpB,KAAKV,MAAL,GAAc,IAAd;MACD,CAFM,MAEA,IAAIU,GAAG,KAAK,CAAZ,EAAe;QACpB,KAAKT,SAAL,GAAiB,IAAjB;MACD,CAFM,MAEA,IAAIS,GAAG,KAAK,EAAZ,EAAgB;QACrB,KAAKX,IAAL,GAAY,KAAZ;MACD,CAFM,MAEA,IAAIW,GAAG,KAAK,EAAZ,EAAgB;QACrB,KAAKV,MAAL,GAAc,KAAd;MACD,CAFM,MAEA,IAAIU,GAAG,KAAK,EAAZ,EAAgB;QACrB,KAAKT,SAAL,GAAiB,KAAjB;MACD,CAFM,MAEA,IAAIS,GAAG,KAAK,EAAZ,EAAgB;QACrB,KAAKR,EAAL,GAAU,IAAV;MACD,CAFM,MAEA,IAAIQ,GAAG,KAAK,EAAZ,EAAgB;QACrB,KAAKP,EAAL,GAAU,IAAV;MACD,CAFM,MAEA,IAAIO,GAAG,IAAI,EAAP,IAAaA,GAAG,GAAG,EAAvB,EAA2B;QAChC,KAAKR,EAAL,GAAU,KAAK7D,WAAL,CAAiB,CAAjB,EAAoBqE,GAAG,GAAG,EAA1B,CAAV;MACD,CAFM,MAEA,IAAIA,GAAG,IAAI,EAAP,IAAaA,GAAG,GAAG,EAAvB,EAA2B;QAChC,KAAKP,EAAL,GAAU,KAAK9D,WAAL,CAAiB,CAAjB,EAAoBqE,GAAG,GAAG,EAA1B,CAAV;MACD,CAFM,MAEA,IAAIA,GAAG,IAAI,EAAP,IAAaA,GAAG,GAAG,EAAvB,EAA2B;QAChC,KAAKR,EAAL,GAAU,KAAK7D,WAAL,CAAiB,CAAjB,EAAoBqE,GAAG,GAAG,EAA1B,CAAV;MACD,CAFM,MAEA,IAAIA,GAAG,IAAI,GAAP,IAAcA,GAAG,GAAG,GAAxB,EAA6B;QAClC,KAAKP,EAAL,GAAU,KAAK9D,WAAL,CAAiB,CAAjB,EAAoBqE,GAAG,GAAG,GAA1B,CAAV;MACD,CAFM,MAEA,IAAIA,GAAG,KAAK,EAAR,IAAcA,GAAG,KAAK,EAA1B,EAA8B;QACnC;QAEA;QACA,IAAIJ,QAAQ,CAACpC,MAAT,GAAkB,CAAtB,EAAyB;UACvB;UACA,MAAM2C,aAAa,GAAGH,GAAG,KAAK,EAA9B;UAEA,MAAMI,QAAQ,GAAGR,QAAQ,CAACG,KAAT,EAAjB,CAJuB,CAMvB;;UACA,IAAIK,QAAQ,KAAK,GAAb,IAAoBR,QAAQ,CAACpC,MAAT,GAAkB,CAA1C,EAA6C;YAC3C,MAAM6C,aAAa,GAAGJ,QAAQ,CAACL,QAAQ,CAACG,KAAT,EAAD,EAAmB,EAAnB,CAA9B;;YACA,IAAIM,aAAa,IAAI,CAAjB,IAAsBA,aAAa,IAAI,GAA3C,EAAgD;cAC9C,IAAIF,aAAJ,EAAmB;gBACjB,KAAKX,EAAL,GAAU,KAAK1D,WAAL,CAAiBuE,aAAjB,CAAV;cACD,CAFD,MAEO;gBACL,KAAKZ,EAAL,GAAU,KAAK3D,WAAL,CAAiBuE,aAAjB,CAAV;cACD;YACF;UACF,CAhBsB,CAkBvB;;;UACA,IAAID,QAAQ,KAAK,GAAb,IAAoBR,QAAQ,CAACpC,MAAT,GAAkB,CAA1C,EAA6C;YAC3C,MAAMpB,CAAC,GAAG6D,QAAQ,CAACL,QAAQ,CAACG,KAAT,EAAD,EAAmB,EAAnB,CAAlB;YACA,MAAM1D,CAAC,GAAG4D,QAAQ,CAACL,QAAQ,CAACG,KAAT,EAAD,EAAmB,EAAnB,CAAlB;YACA,MAAMzD,CAAC,GAAG2D,QAAQ,CAACL,QAAQ,CAACG,KAAT,EAAD,EAAmB,EAAnB,CAAlB;;YAEA,IAAI3D,CAAC,IAAI,CAAL,IAAUA,CAAC,IAAI,GAAf,IAAsBC,CAAC,IAAI,CAA3B,IAAgCA,CAAC,IAAI,GAArC,IAA4CC,CAAC,IAAI,CAAjD,IAAsDA,CAAC,IAAI,GAA/D,EAAoE;cAClE,MAAMgE,CAAC,GAAG;gBAAE1E,GAAG,EAAE,CAACQ,CAAD,EAAIC,CAAJ,EAAOC,CAAP,CAAP;gBAAkBT,UAAU,EAAE;cAA9B,CAAV;;cACA,IAAIsE,aAAJ,EAAmB;gBACjB,KAAKX,EAAL,GAAUc,CAAV;cACD,CAFD,MAEO;gBACL,KAAKb,EAAL,GAAUa,CAAV;cACD;YACF;UACF;QACF;MACF;IACF;EACF;;EAEOtB,iBAAiB,CAACuB,QAAD,EAAuB;IAC9C,MAAM3D,GAAG,GAAG2D,QAAQ,CAAClD,IAArB;;IAEA,IAAIT,GAAG,CAACY,MAAJ,KAAe,CAAnB,EAAsB;MACpB,OAAOZ,GAAP;IACD,CAL6C,CAO9C;IAEA;;;IACA,IAAI,CAAC2D,QAAQ,CAAClB,IAAV,IAAkB,CAACkB,QAAQ,CAACjB,MAA5B,IAAsC,CAACiB,QAAQ,CAAChB,SAAhD,IAA6DgB,QAAQ,CAACf,EAAT,KAAgB,IAA7E,IAAqFe,QAAQ,CAACd,EAAT,KAAgB,IAAzG,EAA+G;MAC7G,OAAO7C,GAAP;IACD;;IAED,MAAM4D,MAAM,GAAa,EAAzB;IACA,MAAMC,OAAO,GAAa,EAA1B;IAEA,MAAMjB,EAAE,GAAGe,QAAQ,CAACf,EAApB;IACA,MAAMC,EAAE,GAAGc,QAAQ,CAACd,EAApB,CAlB8C,CAoB9C;;IACA,IAAIc,QAAQ,CAAClB,IAAb,EAAmB;MACjBmB,MAAM,CAACtE,IAAP,CAAY,kBAAZ;IACD;;IAED,IAAIqE,QAAQ,CAACjB,MAAb,EAAqB;MACnBkB,MAAM,CAACtE,IAAP,CAAY,mBAAZ;IACD;;IAED,IAAIqE,QAAQ,CAAChB,SAAb,EAAwB;MACtBiB,MAAM,CAACtE,IAAP,CAAY,2BAAZ;IACD;;IAED,IAAI,CAAC,KAAKV,YAAV,EAAwB;MACtB;MACA,IAAIgE,EAAJ,EAAQ;QACNgB,MAAM,CAACtE,IAAP,CAAY,aAAasD,EAAE,CAAC5D,GAAH,CAAOwD,IAAP,CAAY,GAAZ,CAAgB,GAAzC;MACD;;MACD,IAAIK,EAAJ,EAAQ;QACNe,MAAM,CAACtE,IAAP,CAAY,wBAAwBuD,EAAE,CAAC7D,GAAG,GAA1C;MACD;IACF,CARD,MAQO;MACL;MACA,IAAI4D,EAAJ,EAAQ;QACN,IAAIA,EAAE,CAAC3D,UAAH,KAAkB,WAAtB,EAAmC;UACjC4E,OAAO,CAACvE,IAAR,CAAa,GAAGsD,EAAE,CAAC3D,UAAU,KAA7B;QACD,CAFD,MAEO;UACL2E,MAAM,CAACtE,IAAP,CAAY,aAAasD,EAAE,CAAC5D,GAAH,CAAOwD,IAAP,CAAY,GAAZ,CAAgB,GAAzC;QACD;MACF;;MACD,IAAIK,EAAJ,EAAQ;QACN,IAAIA,EAAE,CAAC5D,UAAH,KAAkB,WAAtB,EAAmC;UACjC4E,OAAO,CAACvE,IAAR,CAAa,GAAGuD,EAAE,CAAC5D,UAAU,KAA7B;QACD,CAFD,MAEO;UACL2E,MAAM,CAACtE,IAAP,CAAY,wBAAwBuD,EAAE,CAAC7D,GAAH,CAAOwD,IAAP,CAAY,GAAZ,CAAgB,GAApD;QACD;MACF;IACF;;IAED,IAAIsB,YAAY,GAAG,EAAnB;IACA,IAAIC,YAAY,GAAG,EAAnB;;IAEA,IAAIF,OAAO,CAACjD,MAAZ,EAAoB;MAClBkD,YAAY,GAAG,WAAWD,OAAO,CAACrB,IAAR,CAAa,GAAb,CAAiB,GAA3C;IACD;;IAED,IAAIoB,MAAM,CAAChD,MAAX,EAAmB;MACjBmD,YAAY,GAAG,WAAWH,MAAM,CAACpB,IAAP,CAAY,GAAZ,CAAgB,GAA1C;IACD;;IAED,OAAO,QAAQuB,YAAY,GAAGD,YAAY,IAAI9D,GAAG,SAAjD;EACD;;EAEOuC,iBAAiB,CAACjC,GAAD,EAAgB;IACvC;IACA,MAAM0D,KAAK,GAAG1D,GAAG,CAACI,GAAJ,CAAQuC,KAAR,CAAc,GAAd,CAAd;;IACA,IAAIe,KAAK,CAACpD,MAAN,GAAe,CAAnB,EAAsB;MACpB,OAAO,EAAP;IACD;;IAED,IAAI,CAAC,KAAK9B,cAAL,CAAoBkF,KAAK,CAAC,CAAD,CAAzB,CAAL,EAAoC;MAClC,OAAO,EAAP;IACD;;IAED,MAAMC,MAAM,GAAG,YAAY,KAAKlE,mBAAL,CAAyBO,GAAG,CAACI,GAA7B,CAAiC,KAAK,KAAKX,mBAAL,CAAyBO,GAAG,CAACG,IAA7B,CAAkC,MAAnG;IACA,OAAOwD,MAAP;EACD;;AA1oBwB,C,CA6oB3B;AACA;AACA;AAEA;;AACA,SAAS3C,GAAT,CAAa4C,OAAb,EAAwC;EACtC;EACA,MAAMC,SAAS,GAAWD,OAAO,CAACE,GAAR,CAAY,CAAZ,CAA1B,CAFsC,CAItC;;EACA,MAAMC,KAAK,GAAG,gCAAd;EACA,MAAMC,IAAI,GAAGH,SAAS,CAAClE,OAAV,CAAkBoE,KAAlB,EAAyB,EAAzB,CAAb;EACA,OAAO,IAAIE,MAAJ,CAAWD,IAAX,CAAP;AACD,C,CAED;AACA;;;AACA,SAAS1C,IAAT,CAAcsC,OAAd,EAAyC;EACvC;EACA,MAAMC,SAAS,GAAWD,OAAO,CAACE,GAAR,CAAY,CAAZ,CAA1B,CAFuC,CAIvC;;EACA,MAAMC,KAAK,GAAG,gCAAd;EACA,MAAMC,IAAI,GAAGH,SAAS,CAAClE,OAAV,CAAkBoE,KAAlB,EAAyB,EAAzB,CAAb;EACA,OAAO,IAAIE,MAAJ,CAAWD,IAAX,EAAiB,GAAjB,CAAP;AACD","names":["PacketKind","AnsiUp","constructor","setup_palettes","resetStyles","use_classes","arg","_use_classes","url_whitelist","_url_whitelist","ansi_colors","rgb","class_name","palette_256","forEach","palette","rec","push","levels","r","g","b","col","grey_level","i","gry","escape_txt_for_html","txt","replace","str","append_buffer","_buffer","get_next_packet","pkt","kind","EOS","text","url","len","length","pos","indexOf","Text","slice","Incomplete","next_char","charAt","ESC","_csi_regex","rgx","match","Unknown","SGR","rpos","_osc_st","rgxG","lastIndex","exec","_osc_regex","OSCURL","ansi_to_html","blocks","packet","transform_to_html","with_state","process_ansi","process_hyperlink","join","bold","italic","underline","fg","bg","http","https","sgr_cmds","split","sgr_cmd_str","shift","num","parseInt","isNaN","is_foreground","mode_cmd","palette_index","c","fragment","styles","classes","class_string","style_string","parts","result","tmplObj","regexText","raw","wsrgx","txt2","RegExp"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-log-viewer/src/ansi_up/ansi_up.ts"],"sourcesContent":["/* ansi_up.js\n * author : Dru Nelson\n * license : MIT\n * http://github.com/drudru/ansi_up\n */\n\n//\n// INTERFACES\n//\n/* eslint-disable */\ninterface AU_Color {\n  rgb: number[];\n  class_name: string;\n}\n\n// Represents the output of process_ansi(): a snapshot of the AnsiUp state machine\n// at a given point in time, which wraps a fragment of text. This would allow deferred\n// processing of text fragments and colors, if ever needed.\ninterface TextWithAttr {\n  fg: AU_Color;\n  bg: AU_Color;\n  bold: boolean;\n  italic: boolean;\n  underline: boolean;\n  text: string;\n}\n\n// Used internally when breaking up the raw text into packets\n\nenum PacketKind {\n  EOS,\n  Text,\n  Incomplete, // An Incomplete ESC sequence\n  ESC, // A single ESC char - random\n  Unknown, // A valid CSI but not an SGR code\n  SGR, // Select Graphic Rendition\n  OSCURL // Operating System Command\n}\n\ninterface TextPacket {\n  kind: PacketKind;\n  text: string;\n  url: string;\n}\n\n//\n// MAIN CLASS\n//\n\nexport default class AnsiUp {\n  VERSION = '5.0.1';\n\n  //\n  // *** SEE README ON GITHUB FOR PUBLIC API ***\n  //\n\n  // 256 Colors Palette\n  // CSS RGB strings - ex. \"255, 255, 255\"\n  private ansi_colors: AU_Color[][];\n  private palette_256: AU_Color[];\n\n  private fg: AU_Color;\n  private bg: AU_Color;\n  private bold: boolean;\n  private italic: boolean;\n  private underline: boolean;\n  private _use_classes: boolean;\n\n  private _csi_regex: RegExp;\n\n  private _osc_st: RegExp;\n  private _osc_regex: RegExp;\n\n  private _url_whitelist: any = {};\n\n  private _buffer: string;\n\n  constructor() {\n    // All construction occurs here\n    this.setup_palettes();\n    this.resetStyles();\n  }\n\n  set use_classes(arg: boolean) {\n    this._use_classes = arg;\n  }\n\n  get use_classes(): boolean {\n    return this._use_classes;\n  }\n\n  set url_whitelist(arg: {}) {\n    this._url_whitelist = arg;\n  }\n\n  get url_whitelist(): {} {\n    return this._url_whitelist;\n  }\n\n  private setup_palettes(): void {\n    this.ansi_colors = [\n      // Normal colors\n      [\n        { rgb: [0, 0, 0], class_name: 'ansi-black' },\n        { rgb: [187, 0, 0], class_name: 'ansi-red' },\n        { rgb: [0, 187, 0], class_name: 'ansi-green' },\n        { rgb: [187, 187, 0], class_name: 'ansi-yellow' },\n        { rgb: [0, 0, 187], class_name: 'ansi-blue' },\n        { rgb: [187, 0, 187], class_name: 'ansi-magenta' },\n        { rgb: [0, 187, 187], class_name: 'ansi-cyan' },\n        { rgb: [255, 255, 255], class_name: 'ansi-white' }\n      ],\n\n      // Bright colors\n      [\n        { rgb: [85, 85, 85], class_name: 'ansi-bright-black' },\n        { rgb: [255, 85, 85], class_name: 'ansi-bright-red' },\n        { rgb: [0, 255, 0], class_name: 'ansi-bright-green' },\n        { rgb: [255, 255, 85], class_name: 'ansi-bright-yellow' },\n        { rgb: [85, 85, 255], class_name: 'ansi-bright-blue' },\n        { rgb: [255, 85, 255], class_name: 'ansi-bright-magenta' },\n        { rgb: [85, 255, 255], class_name: 'ansi-bright-cyan' },\n        { rgb: [255, 255, 255], class_name: 'ansi-bright-white' }\n      ]\n    ];\n\n    this.palette_256 = [];\n\n    // Index 0..15 : Ansi-Colors\n    this.ansi_colors.forEach(palette => {\n      palette.forEach(rec => {\n        this.palette_256.push(rec);\n      });\n    });\n\n    // Index 16..231 : RGB 6x6x6\n    // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n    const levels = [0, 95, 135, 175, 215, 255];\n    for (let r = 0; r < 6; ++r) {\n      for (let g = 0; g < 6; ++g) {\n        for (let b = 0; b < 6; ++b) {\n          const col = { rgb: [levels[r], levels[g], levels[b]], class_name: 'truecolor' };\n          this.palette_256.push(col);\n        }\n      }\n    }\n\n    // Index 232..255 : Grayscale\n    let grey_level = 8;\n    for (let i = 0; i < 24; ++i, grey_level += 10) {\n      const gry = { rgb: [grey_level, grey_level, grey_level], class_name: 'truecolor' };\n      this.palette_256.push(gry);\n    }\n  }\n\n  private escape_txt_for_html(txt: string): string {\n    return txt.replace(/[&<>\"']/gm, str => {\n      if (str === '&') {\n        return '&amp;';\n      }\n      if (str === '<') {\n        return '&lt;';\n      }\n      if (str === '>') {\n        return '&gt;';\n      }\n      if (str === '\"') {\n        return '&quot;';\n      }\n      if (str === \"'\") {\n        return '&#x27;';\n      }\n    });\n  }\n\n  private append_buffer(txt: string) {\n    const str = this._buffer + txt;\n    this._buffer = str;\n  }\n\n  private get_next_packet(): TextPacket {\n    const pkt = {\n      kind: PacketKind.EOS,\n      text: '',\n      url: ''\n    };\n\n    const len = this._buffer.length;\n    if (len == 0) {\n      return pkt;\n    }\n\n    const pos = this._buffer.indexOf('\\x1B');\n\n    // The most common case, no ESC codes\n    if (pos == -1) {\n      pkt.kind = PacketKind.Text;\n      pkt.text = this._buffer;\n      this._buffer = '';\n      return pkt;\n    }\n\n    if (pos > 0) {\n      pkt.kind = PacketKind.Text;\n      pkt.text = this._buffer.slice(0, pos);\n      this._buffer = this._buffer.slice(pos);\n      return pkt;\n    }\n\n    // NOW WE HANDLE ESCAPES\n    if (pos == 0) {\n      if (len == 1) {\n        // Lone ESC in Buffer, We don't know yet\n        pkt.kind = PacketKind.Incomplete;\n        return pkt;\n      }\n\n      const next_char = this._buffer.charAt(1);\n\n      // We treat this as a single ESC\n      // Which effecitvely shows\n      if (next_char != '[' && next_char != ']') {\n        // DeMorgan\n        pkt.kind = PacketKind.ESC;\n        pkt.text = this._buffer.slice(0, 1);\n        this._buffer = this._buffer.slice(1);\n        return pkt;\n      }\n\n      // OK is this an SGR or OSC that we handle\n\n      // SGR CHECK\n      if (next_char == '[') {\n        // We do this regex initialization here so\n        // we can keep the regex close to its use (Readability)\n\n        // All ansi codes are typically in the following format.\n        // We parse it and focus specifically on the\n        // graphics commands (SGR)\n        //\n        // CONTROL-SEQUENCE-INTRODUCER CSI             (ESC, '[')\n        // PRIVATE-MODE-CHAR                           (!, <, >, ?)\n        // Numeric parameters separated by semicolons  ('0' - '9', ';')\n        // Intermediate-modifiers                      (0x20 - 0x2f)\n        // COMMAND-CHAR                                (0x40 - 0x7e)\n        //\n\n        if (!this._csi_regex) {\n          this._csi_regex = rgx`\n                        ^                           # beginning of line\n                                                    #\n                                                    # First attempt\n                        (?:                         # legal sequence\n                          \\x1b\\[                      # CSI\n                          ([\\x3c-\\x3f]?)              # private-mode char\n                          ([\\d;]*)                    # any digits or semicolons\n                          ([\\x20-\\x2f]?               # an intermediate modifier\n                          [\\x40-\\x7e])                # the command\n                        )\n                        |                           # alternate (second attempt)\n                        (?:                         # illegal sequence\n                          \\x1b\\[                      # CSI\n                          [\\x20-\\x7e]*                # anything legal\n                          ([\\x00-\\x1f:])              # anything illegal\n                        )\n                    `;\n        }\n\n        const match = this._buffer.match(this._csi_regex);\n\n        // This match is guaranteed to terminate (even on\n        // invalid input). The key is to match on legal and\n        // illegal sequences.\n        // The first alternate matches everything legal and\n        // the second matches everything illegal.\n        //\n        // If it doesn't match, then we have not received\n        // either the full sequence or an illegal sequence.\n        // If it does match, the presence of field 4 tells\n        // us whether it was legal or illegal.\n\n        if (match === null) {\n          pkt.kind = PacketKind.Incomplete;\n          return pkt;\n        }\n\n        // match is an array\n        // 0 - total match\n        // 1 - private mode chars group\n        // 2 - digits and semicolons group\n        // 3 - command\n        // 4 - illegal char\n\n        if (match[4]) {\n          // Illegal sequence, just remove the ESC\n          pkt.kind = PacketKind.ESC;\n          pkt.text = this._buffer.slice(0, 1);\n          this._buffer = this._buffer.slice(1);\n          return pkt;\n        }\n\n        // If not a valid SGR, we don't handle\n        if (match[1] != '' || match[3] != 'm') {\n          pkt.kind = PacketKind.Unknown;\n        } else {\n          pkt.kind = PacketKind.SGR;\n        }\n\n        pkt.text = match[2]; // Just the parameters\n\n        var rpos = match[0].length;\n        this._buffer = this._buffer.slice(rpos);\n        return pkt;\n      }\n\n      // OSC CHECK\n      if (next_char == ']') {\n        if (len < 4) {\n          pkt.kind = PacketKind.Incomplete;\n          return pkt;\n        }\n\n        if (this._buffer.charAt(2) != '8' || this._buffer.charAt(3) != ';') {\n          // This is not a match, so we'll just treat it as ESC\n          pkt.kind = PacketKind.ESC;\n          pkt.text = this._buffer.slice(0, 1);\n          this._buffer = this._buffer.slice(1);\n          return pkt;\n        }\n\n        // We do this regex initialization here so\n        // we can keep the regex close to its use (Readability)\n\n        // Matching a Hyperlink OSC with a regex is difficult\n        // because Javascript's regex engine doesn't support\n        // 'partial match' support.\n        //\n        // Therefore, we require the system to match the\n        // string-terminator(ST) before attempting a match.\n        // Once we find it, we attempt the Hyperlink-Begin\n        // match.\n        // If that goes ok, we scan forward for the next\n        // ST.\n        // Finally, we try to match it all and return\n        // the sequence.\n        // Also, it is important to note that we consider\n        // certain control characters as an invalidation of\n        // the entire sequence.\n\n        // We do regex initializations here so\n        // we can keep the regex close to its use (Readability)\n\n        // STRING-TERMINATOR\n        // This is likely to terminate in most scenarios\n        // because it will terminate on a newline\n\n        if (!this._osc_st) {\n          this._osc_st = rgxG`\n                        (?:                         # legal sequence\n                          (\\x1b\\\\)                    # ESC \\\n                          |                           # alternate\n                          (\\x07)                      # BEL (what xterm did)\n                        )\n                        |                           # alternate (second attempt)\n                        (                           # illegal sequence\n                          [\\x00-\\x06]                 # anything illegal\n                          |                           # alternate\n                          [\\x08-\\x1a]                 # anything illegal\n                          |                           # alternate\n                          [\\x1c-\\x1f]                 # anything illegal\n                        )\n                    `;\n        }\n\n        // VERY IMPORTANT\n        // We do a stateful regex match with exec.\n        // If the regex is global, and it used with 'exec',\n        // then it will search starting at the 'lastIndex'\n        // If it matches, the regex can be used again to\n        // find the next match.\n        this._osc_st.lastIndex = 0;\n\n        {\n          const match = this._osc_st.exec(this._buffer);\n\n          if (match === null) {\n            pkt.kind = PacketKind.Incomplete;\n            return pkt;\n          }\n\n          // If an illegal character was found, bail on the match\n          if (match[3]) {\n            // Illegal sequence, just remove the ESC\n            pkt.kind = PacketKind.ESC;\n            pkt.text = this._buffer.slice(0, 1);\n            this._buffer = this._buffer.slice(1);\n            return pkt;\n          }\n        }\n\n        // OK - we might have the prefix and URI\n        // Lets start our search for the next ST\n        // past this index\n\n        {\n          const match = this._osc_st.exec(this._buffer);\n\n          if (match === null) {\n            pkt.kind = PacketKind.Incomplete;\n            return pkt;\n          }\n\n          // If an illegal character was found, bail on the match\n          if (match[3]) {\n            // Illegal sequence, just remove the ESC\n            pkt.kind = PacketKind.ESC;\n            pkt.text = this._buffer.slice(0, 1);\n            this._buffer = this._buffer.slice(1);\n            return pkt;\n          }\n        }\n\n        // OK, at this point we should have a FULL match!\n        //\n        // Lets try to match that now\n\n        if (!this._osc_regex) {\n          this._osc_regex = rgx`\n                        ^                           # beginning of line\n                                                    #\n                        \\x1b\\]8;                    # OSC Hyperlink\n                        [\\x20-\\x3a\\x3c-\\x7e]*       # params (excluding ;)\n                        ;                           # end of params\n                        ([\\x21-\\x7e]{0,512})        # URL capture\n                        (?:                         # ST\n                          (?:\\x1b\\\\)                  # ESC \\\n                          |                           # alternate\n                          (?:\\x07)                    # BEL (what xterm did)\n                        )\n                        ([\\x20-\\x7e]+)              # TEXT capture\n                        \\x1b\\]8;;                   # OSC Hyperlink End\n                        (?:                         # ST\n                          (?:\\x1b\\\\)                  # ESC \\\n                          |                           # alternate\n                          (?:\\x07)                    # BEL (what xterm did)\n                        )\n                    `;\n        }\n\n        const match = this._buffer.match(this._osc_regex);\n\n        if (match === null) {\n          // Illegal sequence, just remove the ESC\n          pkt.kind = PacketKind.ESC;\n          pkt.text = this._buffer.slice(0, 1);\n          this._buffer = this._buffer.slice(1);\n          return pkt;\n        }\n\n        // match is an array\n        // 0 - total match\n        // 1 - URL\n        // 2 - Text\n\n        // If a valid SGR\n        pkt.kind = PacketKind.OSCURL;\n        pkt.url = match[1];\n        pkt.text = match[2];\n\n        var rpos = match[0].length;\n        this._buffer = this._buffer.slice(rpos);\n        return pkt;\n      }\n    }\n  }\n\n  ansi_to_html(txt: string): string {\n    this.append_buffer(txt);\n\n    const blocks: string[] = [];\n\n    while (true) {\n      const packet = this.get_next_packet();\n\n      if (packet.kind == PacketKind.EOS || packet.kind == PacketKind.Incomplete) {\n        break;\n      }\n\n      // Drop single ESC or Unknown CSI\n      if (packet.kind == PacketKind.ESC || packet.kind == PacketKind.Unknown) {\n        continue;\n      }\n\n      if (packet.kind == PacketKind.Text) {\n        blocks.push(this.transform_to_html(this.with_state(packet)));\n      } else if (packet.kind == PacketKind.SGR) {\n        this.process_ansi(packet);\n      } else if (packet.kind == PacketKind.OSCURL) {\n        blocks.push(this.process_hyperlink(packet));\n      }\n    }\n\n    return blocks.join('');\n  }\n\n  resetStyles() {\n    this._use_classes = false;\n\n    this.bold = false;\n    this.italic = false;\n    this.underline = false;\n    this.fg = this.bg = null;\n\n    this._buffer = '';\n\n    this._url_whitelist = { http: 1, https: 1 };\n  }\n\n  private with_state(pkt: TextPacket): TextWithAttr {\n    return {\n      bold: this.bold,\n      italic: this.italic,\n      underline: this.underline,\n      fg: this.fg,\n      bg: this.bg,\n      text: pkt.text\n    };\n  }\n\n  private process_ansi(pkt: TextPacket) {\n    // Ok - we have a valid \"SGR\" (Select Graphic Rendition)\n\n    const sgr_cmds = pkt.text.split(';');\n\n    // Each of these params affects the SGR state\n\n    // Why do we shift through the array instead of a forEach??\n    // ... because some commands consume the params that follow !\n    while (sgr_cmds.length > 0) {\n      const sgr_cmd_str = sgr_cmds.shift();\n      const num = parseInt(sgr_cmd_str, 10);\n\n      if (isNaN(num) || num === 0) {\n        this.fg = this.bg = null;\n        this.bold = false;\n        this.italic = false;\n        this.underline = false;\n      } else if (num === 1) {\n        this.bold = true;\n      } else if (num === 3) {\n        this.italic = true;\n      } else if (num === 4) {\n        this.underline = true;\n      } else if (num === 22) {\n        this.bold = false;\n      } else if (num === 23) {\n        this.italic = false;\n      } else if (num === 24) {\n        this.underline = false;\n      } else if (num === 39) {\n        this.fg = null;\n      } else if (num === 49) {\n        this.bg = null;\n      } else if (num >= 30 && num < 38) {\n        this.fg = this.ansi_colors[0][num - 30];\n      } else if (num >= 40 && num < 48) {\n        this.bg = this.ansi_colors[0][num - 40];\n      } else if (num >= 90 && num < 98) {\n        this.fg = this.ansi_colors[1][num - 90];\n      } else if (num >= 100 && num < 108) {\n        this.bg = this.ansi_colors[1][num - 100];\n      } else if (num === 38 || num === 48) {\n        // extended set foreground/background color\n\n        // validate that param exists\n        if (sgr_cmds.length > 0) {\n          // extend color (38=fg, 48=bg)\n          const is_foreground = num === 38;\n\n          const mode_cmd = sgr_cmds.shift();\n\n          // MODE '5' - 256 color palette\n          if (mode_cmd === '5' && sgr_cmds.length > 0) {\n            const palette_index = parseInt(sgr_cmds.shift(), 10);\n            if (palette_index >= 0 && palette_index <= 255) {\n              if (is_foreground) {\n                this.fg = this.palette_256[palette_index];\n              } else {\n                this.bg = this.palette_256[palette_index];\n              }\n            }\n          }\n\n          // MODE '2' - True Color\n          if (mode_cmd === '2' && sgr_cmds.length > 2) {\n            const r = parseInt(sgr_cmds.shift(), 10);\n            const g = parseInt(sgr_cmds.shift(), 10);\n            const b = parseInt(sgr_cmds.shift(), 10);\n\n            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {\n              const c = { rgb: [r, g, b], class_name: 'truecolor' };\n              if (is_foreground) {\n                this.fg = c;\n              } else {\n                this.bg = c;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  private transform_to_html(fragment: TextWithAttr): string {\n    const txt = fragment.text;\n\n    if (txt.length === 0) {\n      return txt;\n    }\n\n    // txt = this.escape_txt_for_html(txt);\n\n    // If colors not set, default style is used\n    if (!fragment.bold && !fragment.italic && !fragment.underline && fragment.fg === null && fragment.bg === null) {\n      return txt;\n    }\n\n    const styles: string[] = [];\n    const classes: string[] = [];\n\n    const fg = fragment.fg;\n    const bg = fragment.bg;\n\n    // Note on bold: https://stackoverflow.com/questions/6737005/what-are-some-advantages-to-using-span-style-font-weightbold-rather-than-b?rq=1\n    if (fragment.bold) {\n      styles.push('font-weight:bold');\n    }\n\n    if (fragment.italic) {\n      styles.push('font-style:italic');\n    }\n\n    if (fragment.underline) {\n      styles.push('text-decoration:underline');\n    }\n\n    if (!this._use_classes) {\n      // USE INLINE STYLES\n      if (fg) {\n        styles.push(`color:rgb(${fg.rgb.join(',')})`);\n      }\n      if (bg) {\n        styles.push(`background-color:rgb(${bg.rgb})`);\n      }\n    } else {\n      // USE CLASSES\n      if (fg) {\n        if (fg.class_name !== 'truecolor') {\n          classes.push(`${fg.class_name}-fg`);\n        } else {\n          styles.push(`color:rgb(${fg.rgb.join(',')})`);\n        }\n      }\n      if (bg) {\n        if (bg.class_name !== 'truecolor') {\n          classes.push(`${bg.class_name}-bg`);\n        } else {\n          styles.push(`background-color:rgb(${bg.rgb.join(',')})`);\n        }\n      }\n    }\n\n    let class_string = '';\n    let style_string = '';\n\n    if (classes.length) {\n      class_string = ` class=\"${classes.join(' ')}\"`;\n    }\n\n    if (styles.length) {\n      style_string = ` style=\"${styles.join(';')}\"`;\n    }\n\n    return `<span${style_string}${class_string}>${txt}</span>`;\n  }\n\n  private process_hyperlink(pkt: TextPacket): string {\n    // Check URL scheme\n    const parts = pkt.url.split(':');\n    if (parts.length < 1) {\n      return '';\n    }\n\n    if (!this._url_whitelist[parts[0]]) {\n      return '';\n    }\n\n    const result = `<a href=\"${this.escape_txt_for_html(pkt.url)}\">${this.escape_txt_for_html(pkt.text)}</a>`;\n    return result;\n  }\n}\n\n//\n// PRIVATE FUNCTIONS\n//\n\n// ES5 template string transformer\nfunction rgx(tmplObj: any, ...subst: any) {\n  // Use the 'raw' value so we don't have to double backslash in a template string\n  const regexText: string = tmplObj.raw[0];\n\n  // Remove white-space and comments\n  const wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n  const txt2 = regexText.replace(wsrgx, '');\n  return new RegExp(txt2);\n}\n\n// ES5 template string transformer\n// Multi-Line On\nfunction rgxG(tmplObj: any, ...subst: any) {\n  // Use the 'raw' value so we don't have to double backslash in a template string\n  const regexText: string = tmplObj.raw[0];\n\n  // Remove white-space and comments\n  const wsrgx = /^\\s+|\\s+\\n|\\s*#[\\s\\S]*?\\n|\\n/gm;\n  const txt2 = regexText.replace(wsrgx, '');\n  return new RegExp(txt2, 'g');\n}\n"]},"metadata":{},"sourceType":"module"}