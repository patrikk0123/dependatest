{"ast":null,"code":"export const isArrayOfString = array => {\n  for (const str in array) {\n    if (typeof str !== 'string') {\n      return false;\n    }\n  }\n\n  return true;\n};\n/*\n  Function responsible for searching throughout logger component, need to setup for proper use anywhere.\n  It should take an array, and return an array of indexes where the searchedInput is found throughout the data array.\n  Should always be searching an array of strings. Look into lazy log for ideas.\n*/\n\nexport const searchForKeyword = (searchedInput, parsedData, itemCount) => {\n  const searchResults = [];\n  const regex = new RegExp(searchedInput, 'ig');\n  parsedData.map((row, index) => {\n    const rawRow = stripAnsi(row);\n\n    if (regex.test(rawRow) && index < itemCount) {\n      const numMatches = rawRow.match(regex).length;\n\n      for (let i = 1; i <= numMatches; i++) {\n        searchResults.push({\n          rowIndex: index,\n          matchIndex: i\n        });\n      }\n    }\n  });\n\n  if (searchResults.length > 0) {\n    return [...searchResults];\n  } else if (searchResults.length <= 0) {\n    return [{\n      rowIndex: -1,\n      matchIndex: 0\n    }];\n  }\n};\nexport const parseConsoleOutput = data => {\n  const stringToSplitWith = '\\n';\n  const stringSplitting = data.toString();\n  const cleanString = stringSplitting.split(stringToSplitWith);\n  return cleanString;\n};\nexport const escapeString = inputString => inputString.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'); // eslint-disable-line\n\n/* eslint-disable-next-line no-control-regex */\n\nconst ansiRegexString = `[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]`;\nexport const ansiRegex = new RegExp(ansiRegexString, 'g');\nexport const isAnsi = inputString => inputString.match(ansiRegex);\nexport const stripAnsi = inputString => inputString.replace(ansiRegex, '');\nexport const splitAnsi = inputString => inputString.split(new RegExp(`(${ansiRegexString})`, 'g'));\nexport const escapeTextForHtml = inputString => inputString.replace(/[&<>\"']/gm, str => {\n  if (str === '&') {\n    return '&amp;';\n  }\n\n  if (str === '<') {\n    return '&lt;';\n  }\n\n  if (str === '>') {\n    return '&gt;';\n  }\n\n  if (str === '\"') {\n    return '&quot;';\n  }\n\n  if (str === \"'\") {\n    return '&#x27;';\n  }\n});","map":{"version":3,"mappings":"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","names":["isArrayOfString","array","str","searchForKeyword","searchedInput","parsedData","itemCount","searchResults","regex","RegExp","map","row","index","rawRow","stripAnsi","test","numMatches","match","length","i","push","rowIndex","matchIndex","parseConsoleOutput","data","stringToSplitWith","stringSplitting","toString","cleanString","split","escapeString","inputString","replace","ansiRegexString","ansiRegex","isAnsi","splitAnsi","escapeTextForHtml"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-log-viewer/src/LogViewer/utils/utils.tsx"],"sourcesContent":["export interface searchedKeyWordType {\n  rowIndex: number;\n  matchIndex: number;\n}\n\nexport const isArrayOfString = (array: string[]) => {\n  for (const str in array) {\n    if (typeof str !== 'string') {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* \n  Function responsible for searching throughout logger component, need to setup for proper use anywhere. \n  It should take an array, and return an array of indexes where the searchedInput is found throughout the data array. \n  Should always be searching an array of strings. Look into lazy log for ideas.\n*/\nexport const searchForKeyword = (searchedInput: string, parsedData: string[], itemCount: number) => {\n  const searchResults: searchedKeyWordType[] = [];\n\n  const regex = new RegExp(searchedInput, 'ig');\n  parsedData.map((row, index) => {\n    const rawRow = stripAnsi(row);\n    if (regex.test(rawRow) && index < itemCount) {\n      const numMatches = rawRow.match(regex).length;\n      for (let i = 1; i <= numMatches; i++) {\n        searchResults.push({ rowIndex: index, matchIndex: i });\n      }\n    }\n  });\n\n  if (searchResults.length > 0) {\n    return [...searchResults];\n  } else if (searchResults.length <= 0) {\n    return [{ rowIndex: -1, matchIndex: 0 }];\n  }\n};\n\nexport const parseConsoleOutput = (data: string) => {\n  const stringToSplitWith = '\\n';\n  const stringSplitting = data.toString();\n  const cleanString = stringSplitting.split(stringToSplitWith);\n\n  return cleanString;\n};\n\nexport const escapeString = (inputString: string): string => inputString.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'); // eslint-disable-line\n\n/* eslint-disable-next-line no-control-regex */\nconst ansiRegexString = `[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]`;\n\nexport const ansiRegex = new RegExp(ansiRegexString, 'g');\n\nexport const isAnsi = (inputString: string) => inputString.match(ansiRegex);\n\nexport const stripAnsi = (inputString: string): string => inputString.replace(ansiRegex, '');\n\nexport const splitAnsi = (inputString: string): string[] => inputString.split(new RegExp(`(${ansiRegexString})`, 'g'));\n\nexport const escapeTextForHtml = (inputString: string): string =>\n  inputString.replace(/[&<>\"']/gm, str => {\n    if (str === '&') {\n      return '&amp;';\n    }\n    if (str === '<') {\n      return '&lt;';\n    }\n    if (str === '>') {\n      return '&gt;';\n    }\n    if (str === '\"') {\n      return '&quot;';\n    }\n    if (str === \"'\") {\n      return '&#x27;';\n    }\n  });\n"]},"metadata":{},"sourceType":"module"}