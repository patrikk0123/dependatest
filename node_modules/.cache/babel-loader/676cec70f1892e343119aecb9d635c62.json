{"ast":null,"code":"import * as React from 'react';\nimport { canUseDOM } from './util';\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\n\nexport const handleArrows = function (event, navigableElements) {\n  let isActiveElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : element => document.activeElement.contains(element);\n  let getFocusableElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : element => element;\n  let validSiblingTags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['A', 'BUTTON', 'INPUT'];\n  let noVerticalArrowHandling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let noHorizontalArrowHandling = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let updateTabIndex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n  let onlyTraverseSiblings = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget = null; // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      // Traverse navigableElements to find the element which is currently active\n\n      let currentIndex = -1; // while (currentIndex === -1) {\n\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0; // keep increasing the increment until you've tried the whole navigableElement\n\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            } // Set the next target element (undefined if none found)\n\n\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      }); // }\n    }\n  } // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n\n\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement; // While a sibling exists, check each sibling to determine if it should be focussed\n\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                } // If the sibling's tag is not valid, skip to the next sibling if possible\n\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                } // Set the next target element\n\n\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      activeElement.tabIndex = -1;\n      moveTarget.tabIndex = 0;\n    } // If a move target has been set by either arrow handler, focus that target\n\n\n    moveTarget.focus();\n  }\n};\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\n\nexport const setTabIndex = options => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach(option => {\n      option.tabIndex = -1;\n    }); // Manually set the tabIndex of the first option to 0\n\n    options[0].tabIndex = 0;\n  }\n};\nexport class KeyboardHandler extends React.Component {\n  constructor() {\n    super(...arguments);\n\n    this.keyHandler = event => {\n      const {\n        isEventFromContainer\n      } = this.props; // If the passed keyboard event is not from the container, ignore the event by returning\n\n      if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n        return;\n      }\n\n      const {\n        isActiveElement,\n        getFocusableElement,\n        noVerticalArrowHandling,\n        noHorizontalArrowHandling,\n        noEnterHandling,\n        noSpaceHandling,\n        updateTabIndex,\n        validSiblingTags,\n        additionalKeyHandler,\n        createNavigableElements,\n        onlyTraverseSiblings\n      } = this.props; // Pass the event off to be handled by any custom handler\n\n      additionalKeyHandler && additionalKeyHandler(event); // Initalize navigableElements from the createNavigableElements callback\n\n      const navigableElements = createNavigableElements();\n\n      if (!navigableElements) {\n        // eslint-disable-next-line no-console\n        console.warn('No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.');\n        return;\n      }\n\n      const key = event.key; // Handle enter key. If noEnterHandling is passed, skip this block\n\n      if (!noEnterHandling) {\n        if (key === 'Enter') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n\n          document.activeElement.click();\n        }\n      } // Handle space key. If noSpaceHandling is passed, skip this block\n\n\n      if (!noSpaceHandling) {\n        if (key === ' ') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n\n          document.activeElement.click();\n        }\n      } // Inject helper handler for arrow navigation\n\n\n      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);\n    };\n\n    this._isEventFromContainer = event => {\n      const {\n        containerRef\n      } = this.props;\n      return containerRef.current && containerRef.current.contains(event.target);\n    };\n  }\n\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  render() {\n    return null;\n  }\n\n}\nKeyboardHandler.displayName = 'KeyboardHandler';\nKeyboardHandler.defaultProps = {\n  containerRef: null,\n  createNavigableElements: () => null,\n  isActiveElement: navigableElement => document.activeElement === navigableElement,\n  getFocusableElement: navigableElement => navigableElement,\n  validSiblingTags: ['BUTTON', 'A'],\n  onlyTraverseSiblings: true,\n  updateTabIndex: true,\n  noHorizontalArrowHandling: false,\n  noVerticalArrowHandling: false,\n  noEnterHandling: false,\n  noSpaceHandling: false\n};","map":{"version":3,"mappings":"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","names":["React","canUseDOM","handleArrows","event","navigableElements","isActiveElement","element","document","activeElement","contains","getFocusableElement","validSiblingTags","noVerticalArrowHandling","noHorizontalArrowHandling","updateTabIndex","onlyTraverseSiblings","key","moveTarget","includes","preventDefault","stopImmediatePropagation","currentIndex","forEach","index","increment","length","activeRow","querySelectorAll","join","nextSibling","previousElementSibling","nextElementSibling","tagName","focusableElement","target","tabIndex","focus","setTabIndex","options","option","KeyboardHandler","Component","constructor","isEventFromContainer","props","_isEventFromContainer","noEnterHandling","noSpaceHandling","additionalKeyHandler","createNavigableElements","console","warn","click","containerRef","current","componentDidMount","window","addEventListener","keyHandler","componentWillUnmount","removeEventListener","render","navigableElement"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/KeyboardHandler.tsx"],"sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './util';\n\nexport interface KeyboardHandlerProps {\n  /** Reference of the container to apply keyboard interaction */\n  containerRef: React.RefObject<any>;\n  /** Callback returning an array of navigable elements to be traversable via vertical arrow keys. This array should not include non-navigable elements such as disabled elements. */\n  createNavigableElements: () => Element[];\n  /** Callback to determine if a given event is from the container. By default the function conducts a basic check to see if the containerRef contains the event target */\n  isEventFromContainer?: (event: KeyboardEvent) => boolean;\n  /** Additional key handling outside of the included arrow keys, enter, and space handling */\n  additionalKeyHandler?: (event: KeyboardEvent) => void;\n  /** Callback to determine if a given element from the navigable elements array is the active element of the page */\n  isActiveElement?: (navigableElement: Element) => boolean;\n  /** Callback returning the focusable element of a given element from the navigable elements array */\n  getFocusableElement?: (navigableElement: Element) => Element;\n  /** Valid sibling tags that horizontal arrow handling will focus */\n  validSiblingTags?: string[];\n  /** Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex */\n  updateTabIndex?: boolean;\n  /** Flag indicating that next focusable element of a horizontal movement will be this element's sibling */\n  onlyTraverseSiblings?: boolean;\n  /** Flag indicating that the included vertical arrow key handling should be ignored */\n  noVerticalArrowHandling?: boolean;\n  /** Flag indicating that the included horizontal arrow key handling should be ignored */\n  noHorizontalArrowHandling?: boolean;\n  /** Flag indicating that the included enter key handling should be ignored */\n  noEnterHandling?: boolean;\n  /** Flag indicating that the included space key handling should be ignored */\n  noSpaceHandling?: boolean;\n}\n\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = (\n  event: KeyboardEvent,\n  navigableElements: Element[],\n  isActiveElement: (element: Element) => boolean = element => document.activeElement.contains(element),\n  getFocusableElement: (element: Element) => Element = element => element,\n  validSiblingTags: string[] = ['A', 'BUTTON', 'INPUT'],\n  noVerticalArrowHandling: boolean = false,\n  noHorizontalArrowHandling: boolean = false,\n  updateTabIndex: boolean = true,\n  onlyTraverseSiblings: boolean = true\n) => {\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget: Element = null;\n\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      // Traverse navigableElements to find the element which is currently active\n      let currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0;\n\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                }\n\n                // Set the next target element\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      (activeElement as HTMLElement).tabIndex = -1;\n      (moveTarget as HTMLElement).tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    (moveTarget as HTMLElement).focus();\n  }\n};\n\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = (options: HTMLElement[]) => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach((option: HTMLElement) => {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\n\nexport class KeyboardHandler extends React.Component<KeyboardHandlerProps> {\n  static displayName = 'KeyboardHandler';\n  static defaultProps: KeyboardHandlerProps = {\n    containerRef: null,\n    createNavigableElements: () => null as Element[],\n    isActiveElement: (navigableElement: Element) => document.activeElement === navigableElement,\n    getFocusableElement: (navigableElement: Element) => navigableElement,\n    validSiblingTags: ['BUTTON', 'A'],\n    onlyTraverseSiblings: true,\n    updateTabIndex: true,\n    noHorizontalArrowHandling: false,\n    noVerticalArrowHandling: false,\n    noEnterHandling: false,\n    noSpaceHandling: false\n  };\n\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  keyHandler = (event: KeyboardEvent) => {\n    const { isEventFromContainer } = this.props;\n    // If the passed keyboard event is not from the container, ignore the event by returning\n    if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n      return;\n    }\n\n    const {\n      isActiveElement,\n      getFocusableElement,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      noEnterHandling,\n      noSpaceHandling,\n      updateTabIndex,\n      validSiblingTags,\n      additionalKeyHandler,\n      createNavigableElements,\n      onlyTraverseSiblings\n    } = this.props;\n\n    // Pass the event off to be handled by any custom handler\n    additionalKeyHandler && additionalKeyHandler(event);\n\n    // Initalize navigableElements from the createNavigableElements callback\n    const navigableElements = createNavigableElements();\n    if (!navigableElements) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.'\n      );\n      return;\n    }\n    const key = event.key;\n\n    // Handle enter key. If noEnterHandling is passed, skip this block\n    if (!noEnterHandling) {\n      if (key === 'Enter') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Handle space key. If noSpaceHandling is passed, skip this block\n    if (!noSpaceHandling) {\n      if (key === ' ') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Inject helper handler for arrow navigation\n    handleArrows(\n      event,\n      navigableElements,\n      isActiveElement,\n      getFocusableElement,\n      validSiblingTags,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      updateTabIndex,\n      onlyTraverseSiblings\n    );\n  };\n\n  _isEventFromContainer = (event: KeyboardEvent) => {\n    const { containerRef } = this.props;\n    return containerRef.current && containerRef.current.contains(event.target as HTMLElement);\n  };\n\n  render() {\n    return null as React.ReactNode;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}