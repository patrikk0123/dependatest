{"ast":null,"code":"/**\n * Q (RSQL) param helper\n *\n * Only ';' is supported at this moment\n *\n * @example\n * user.username=like=\"%u1%\";\n * filename=like=\"%te_t%\";\n * filename=like=\"%te%t%\"\n * filename=notlike=\"%test%\";\n * status==REJECTED;\n * temporaryBuild==FALSE;\n * status!=CANCELLED;\n *\n */\n\n/**\n * Operator =like= is converted to =notlike= automatically when qValue starts with ! character,\n * there is no need to declare it manually.\n */\n\n/**\n * List of all supported RSQL operators.\n */\nconst qParamSupportedOperators = ['=like=', '=notlike=', '==', '!='];\n/**\n * @example\n * {\n *   name: ['\"%t1%\"', '\"%t2%\"'],\n *   status: ['CANCELLED', 'SYSTEM_ERROR']\n * }\n */\n\n/**\n * @param qParamString RSQL string: filename=like=\"%te%t%\";status!=CANCELLED\n * @returns Array of individual RSQL items: [filename=like=\"%te%t%\", status!=CANCELLED]\n */\nconst parseQParamShallow = qParamString => {\n  let qParamArray;\n\n  if (qParamString.indexOf(';') > -1) {\n    qParamArray = qParamString.split(';');\n  } else if (qParamString) {\n    qParamArray = [qParamString];\n  } else {\n    qParamArray = [];\n  }\n\n  return qParamArray;\n};\n\nconst constructQParamItem = (id, value, operator) => {\n  switch (operator) {\n    case '=like=':\n      // #support =notlike=\n      // value does NOT contain \"% characters yet, they need to be added\n      // use '=notlike=' when '=like=\"%!' exists, otherwise use '=like='\n      return (id + operator + '\"%' + value + '%\"').replace('=like=\"%!', '=notlike=\"%');\n\n    default:\n      return `${id}${operator}${value}`;\n  }\n};\n/**\n * @returns\n * 1) new Q string containing new param\n * 2) null when Q param is already contained in Q string\n */\n\n\nexport const addQParamItem = (id, value, operator, qParam) => {\n  const qParamItems = parseQParamShallow(qParam);\n  const newItem = constructQParamItem(id, value, operator); // prevent duplicities\n\n  if (qParamItems.indexOf(newItem) === -1) {\n    qParamItems.push(newItem);\n  } else {\n    return null;\n  }\n\n  return qParamItems.join(';');\n};\n/**\n * @param qParam - RSQL string: filename=like=\"%te%t%\";status!=CANCELLED\n * @returns\n * 1) New Q string without specified param\n * 2) Empty string when last param was removed\n */\n\nexport const removeQParamItem = (id, value, operator, qParam) => {\n  const qParamItems = parseQParamShallow(qParam); // #support =notlike=\n  // value already contains \"% characters\n  // use '=notlike=' when '=like=!' exists, otherwise use '=like='\n\n  const removeItem = (id + operator + value).replace('=like=!', '=notlike=');\n  const removeItemIndex = qParamItems.indexOf(removeItem);\n\n  if (removeItemIndex > -1) {\n    qParamItems.splice(removeItemIndex, 1);\n  } else {\n    // #log\n    console.error(`${removeItem} removing failed, it does not exist`);\n  }\n\n  return qParamItems.join(';');\n};\n/**\n * @param qParam - RSQL string: filename=like=\"%te%t%\";status!=CANCELLED\n * @returns Object representing individual RSQL items deeply parsed:\n * {\n *   name: ['\"%te%t%\"'],\n *   status: ['CANCELLED']\n * }\n */\n\nexport const parseQParamDeep = qParam => {\n  let qParamObject = {};\n  let qParamItems = parseQParamShallow(qParam); // loop Q Params Items\n\n  for (let i = 0; i < qParamItems.length; i++) {\n    let isOperatorFound = false; // loop supported operators\n\n    for (let j = 0; j < qParamSupportedOperators.length; j++) {\n      const qOperator = qParamSupportedOperators[j];\n\n      if (qParamItems[i].indexOf(qOperator) > -1) {\n        isOperatorFound = true;\n        let [qKey, qValue] = qParamItems[i].split(qOperator); // add ! character\n        // #support =notlike=\n\n        if (qOperator === '=notlike=') {\n          qValue = '!' + qValue;\n        }\n\n        if (qParamObject[qKey]) {\n          qParamObject[qKey].push(qValue);\n        } else {\n          qParamObject[qKey] = [qValue];\n        }\n      }\n    }\n\n    if (!isOperatorFound) {\n      // #log\n      console.error(`${qParamItems[i]} does not contain any valid operator, supported operators are: ${qParamSupportedOperators}`);\n    }\n  }\n\n  return qParamObject;\n};\nexport const partseSortParam = sortParam => {};","map":{"version":3,"names":["qParamSupportedOperators","parseQParamShallow","qParamString","qParamArray","indexOf","split","constructQParamItem","id","value","operator","replace","addQParamItem","qParam","qParamItems","newItem","push","join","removeQParamItem","removeItem","removeItemIndex","splice","console","error","parseQParamDeep","qParamObject","i","length","isOperatorFound","j","qOperator","qKey","qValue","partseSortParam","sortParam"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/utils/qParamHelper.ts"],"sourcesContent":["/**\n * Q (RSQL) param helper\n *\n * Only ';' is supported at this moment\n *\n * @example\n * user.username=like=\"%u1%\";\n * filename=like=\"%te_t%\";\n * filename=like=\"%te%t%\"\n * filename=notlike=\"%test%\";\n * status==REJECTED;\n * temporaryBuild==FALSE;\n * status!=CANCELLED;\n *\n */\n\n/**\n * Operator =like= is converted to =notlike= automatically when qValue starts with ! character,\n * there is no need to declare it manually.\n */\nexport type IQParamOperators = '=like=' | '==' | '!=';\n\n/**\n * List of all supported RSQL operators.\n */\nconst qParamSupportedOperators = ['=like=', '=notlike=', '==', '!='];\n\n/**\n * @example\n * {\n *   name: ['\"%t1%\"', '\"%t2%\"'],\n *   status: ['CANCELLED', 'SYSTEM_ERROR']\n * }\n */\nexport interface IQParamObject {\n  [key: string]: string[];\n}\n\n/**\n * @param qParamString RSQL string: filename=like=\"%te%t%\";status!=CANCELLED\n * @returns Array of individual RSQL items: [filename=like=\"%te%t%\", status!=CANCELLED]\n */\nconst parseQParamShallow = (qParamString: string): string[] => {\n  let qParamArray: string[];\n  if (qParamString.indexOf(';') > -1) {\n    qParamArray = qParamString.split(';');\n  } else if (qParamString) {\n    qParamArray = [qParamString];\n  } else {\n    qParamArray = [];\n  }\n  return qParamArray;\n};\n\nconst constructQParamItem = (id: string, value: string, operator: IQParamOperators): string => {\n  switch (operator) {\n    case '=like=':\n      // #support =notlike=\n      // value does NOT contain \"% characters yet, they need to be added\n      // use '=notlike=' when '=like=\"%!' exists, otherwise use '=like='\n      return (id + operator + '\"%' + value + '%\"').replace('=like=\"%!', '=notlike=\"%');\n    default:\n      return `${id}${operator}${value}`;\n  }\n};\n\n/**\n * @returns\n * 1) new Q string containing new param\n * 2) null when Q param is already contained in Q string\n */\nexport const addQParamItem = (id: string, value: string, operator: IQParamOperators, qParam: string): string | null => {\n  const qParamItems = parseQParamShallow(qParam);\n  const newItem = constructQParamItem(id, value, operator);\n\n  // prevent duplicities\n  if (qParamItems.indexOf(newItem) === -1) {\n    qParamItems.push(newItem);\n  } else {\n    return null;\n  }\n\n  return qParamItems.join(';');\n};\n\n/**\n * @param qParam - RSQL string: filename=like=\"%te%t%\";status!=CANCELLED\n * @returns\n * 1) New Q string without specified param\n * 2) Empty string when last param was removed\n */\nexport const removeQParamItem = (id: string, value: string, operator: IQParamOperators, qParam: string): string => {\n  const qParamItems = parseQParamShallow(qParam);\n\n  // #support =notlike=\n  // value already contains \"% characters\n  // use '=notlike=' when '=like=!' exists, otherwise use '=like='\n  const removeItem = (id + operator + value).replace('=like=!', '=notlike=');\n  const removeItemIndex = qParamItems.indexOf(removeItem);\n\n  if (removeItemIndex > -1) {\n    qParamItems.splice(removeItemIndex, 1);\n  } else {\n    // #log\n    console.error(`${removeItem} removing failed, it does not exist`);\n  }\n\n  return qParamItems.join(';');\n};\n\n/**\n * @param qParam - RSQL string: filename=like=\"%te%t%\";status!=CANCELLED\n * @returns Object representing individual RSQL items deeply parsed:\n * {\n *   name: ['\"%te%t%\"'],\n *   status: ['CANCELLED']\n * }\n */\nexport const parseQParamDeep = (qParam: string): IQParamObject => {\n  let qParamObject: IQParamObject = {};\n\n  let qParamItems = parseQParamShallow(qParam);\n\n  // loop Q Params Items\n  for (let i = 0; i < qParamItems.length; i++) {\n    let isOperatorFound = false;\n\n    // loop supported operators\n    for (let j = 0; j < qParamSupportedOperators.length; j++) {\n      const qOperator = qParamSupportedOperators[j];\n\n      if (qParamItems[i].indexOf(qOperator) > -1) {\n        isOperatorFound = true;\n        let [qKey, qValue] = qParamItems[i].split(qOperator);\n\n        // add ! character\n        // #support =notlike=\n        if (qOperator === '=notlike=') {\n          qValue = '!' + qValue;\n        }\n\n        if (qParamObject[qKey]) {\n          qParamObject[qKey].push(qValue);\n        } else {\n          qParamObject[qKey] = [qValue];\n        }\n      }\n    }\n    if (!isOperatorFound) {\n      // #log\n      console.error(\n        `${qParamItems[i]} does not contain any valid operator, supported operators are: ${qParamSupportedOperators}`\n      );\n    }\n  }\n  return qParamObject;\n};\n\nexport const partseSortParam = (sortParam: string) => {};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}