{"ast":null,"code":"import createListComponent from './createListComponent';\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nconst getItemMetadata = (props, index, instanceProps) => {\n  const {\n    itemSize\n  } = props;\n  const {\n    itemMetadataMap,\n    lastMeasuredIndex\n  } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      const size = typeof itemSize === 'number' ? itemSize : itemSize(i);\n      itemMetadataMap[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (props, instanceProps, offset) => {\n  const {\n    itemMetadataMap,\n    lastMeasuredIndex\n  } = instanceProps;\n  const lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nconst findNearestItemBinarySearch = (props, instanceProps, high, low, offset) => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (props, instanceProps, index, offset) => {\n  const {\n    itemCount\n  } = props;\n  let interval = 1;\n\n  while (index < itemCount && getItemMetadata(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nconst getEstimatedTotalSize = (_ref, _ref2) => {\n  let {\n    itemCount\n  } = _ref;\n  let {\n    itemMetadataMap,\n    estimatedItemSize,\n    lastMeasuredIndex\n  } = _ref2;\n  let totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nexport const VariableSizeList = createListComponent({\n  getItemOffset: (props, index, instanceProps) => getItemMetadata(props, index, instanceProps).offset,\n  getItemSize: (props, index, instanceProps) => instanceProps.itemMetadataMap[index].size,\n  getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: (props, index, align, scrollOffset, instanceProps) => {\n    const {\n      height\n    } = props;\n    const size = height;\n    const itemMetadata = getItemMetadata(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    const minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: (props, offset, instanceProps) => findNearestItem(props, instanceProps, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, instanceProps) => {\n    const {\n      height,\n      itemCount\n    } = props;\n    const size = height;\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props, instance) {\n    const {\n      estimatedItemSize\n    } = props;\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index) {\n      let shouldForceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: _ref3 => {\n    let {\n      itemSize\n    } = _ref3;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`);\n      }\n    }\n  }\n});","map":{"version":3,"mappings":"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","names":["createListComponent","DEFAULT_ESTIMATED_ITEM_SIZE","getItemMetadata","props","index","instanceProps","itemSize","itemMetadataMap","lastMeasuredIndex","offset","itemMetadata","size","i","findNearestItem","lastMeasuredItemOffset","findNearestItemBinarySearch","findNearestItemExponentialSearch","Math","max","high","low","middle","floor","currentOffset","itemCount","interval","min","getEstimatedTotalSize","estimatedItemSize","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","VariableSizeList","getItemOffset","getItemSize","getOffsetForIndexAndAlignment","align","scrollOffset","height","estimatedTotalSize","maxOffset","minOffset","round","getStartIndexForOffset","getStopIndexForStartIndex","startIndex","stopIndex","initInstanceProps","instance","resetAfterIndex","shouldForceUpdate","_getItemStyleCache","forceUpdate","shouldResetStyleCacheOnItemSizeChange","validateProps","process","env","NODE_ENV","Error"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-log-viewer/src/react-window/VariableSizeList.tsx"],"sourcesContent":["import createListComponent from './createListComponent';\n\nimport { ScrollToAlign, ListProps, InstanceProps, ItemMetadata } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nconst getItemMetadata = (props: ListProps, index: number, instanceProps: InstanceProps): ItemMetadata => {\n  const { itemSize } = props;\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      const size = typeof itemSize === 'number' ? itemSize : itemSize(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (props: ListProps, instanceProps: InstanceProps, offset: number) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: ListProps,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: ListProps,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (index < itemCount && getItemMetadata(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: ListProps,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nexport const VariableSizeList = createListComponent({\n  getItemOffset: (props: ListProps, index: number, instanceProps: InstanceProps): number =>\n    getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (props: ListProps, index: number, instanceProps: InstanceProps): number =>\n    instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: ListProps,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { height } = props;\n\n    const size = height;\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    const minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (props: ListProps, offset: number, instanceProps: InstanceProps): number =>\n    findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: ListProps,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { height, itemCount } = props;\n\n    const size = height;\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: ListProps, instance: any): InstanceProps {\n    const { estimatedItemSize } = props;\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = (index: number, shouldForceUpdate: boolean = true) => {\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1);\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: ListProps) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  }\n});\n"]},"metadata":{},"sourceType":"module"}