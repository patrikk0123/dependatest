{"ast":null,"code":"import _classCallCheck from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as React from 'react';\nimport { canUseDOM } from './util';\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\n\nexport var handleArrows = function handleArrows(event, navigableElements) {\n  var isActiveElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (element) {\n    return document.activeElement.contains(element);\n  };\n  var getFocusableElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (element) {\n    return element;\n  };\n  var validSiblingTags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['A', 'BUTTON', 'INPUT'];\n  var noVerticalArrowHandling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var noHorizontalArrowHandling = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var updateTabIndex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n  var onlyTraverseSiblings = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n  var activeElement = document.activeElement;\n  var key = event.key;\n  var moveTarget = null; // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      // Traverse navigableElements to find the element which is currently active\n\n      var currentIndex = -1; // while (currentIndex === -1) {\n\n      navigableElements.forEach(function (element, index) {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          var increment = 0; // keep increasing the increment until you've tried the whole navigableElement\n\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            } // Set the next target element (undefined if none found)\n\n\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      }); // }\n    }\n  } // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n\n\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      var _currentIndex = -1;\n\n      navigableElements.forEach(function (element, index) {\n        if (isActiveElement(element)) {\n          var activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            var nextSibling = activeElement; // While a sibling exists, check each sibling to determine if it should be focussed\n\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                } // If the sibling's tag is not valid, skip to the next sibling if possible\n\n              }\n            }\n          } else {\n            activeRow.forEach(function (focusableElement, index) {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                var increment = key === 'ArrowLeft' ? -1 : 1;\n                _currentIndex = index + increment;\n\n                if (_currentIndex >= activeRow.length) {\n                  _currentIndex = 0;\n                }\n\n                if (_currentIndex < 0) {\n                  _currentIndex = activeRow.length - 1;\n                } // Set the next target element\n\n\n                moveTarget = activeRow[_currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      activeElement.tabIndex = -1;\n      moveTarget.tabIndex = 0;\n    } // If a move target has been set by either arrow handler, focus that target\n\n\n    moveTarget.focus();\n  }\n};\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\n\nexport var setTabIndex = function setTabIndex(options) {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach(function (option) {\n      option.tabIndex = -1;\n    }); // Manually set the tabIndex of the first option to 0\n\n    options[0].tabIndex = 0;\n  }\n};\nexport var KeyboardHandler = /*#__PURE__*/function (_React$Component) {\n  _inherits(KeyboardHandler, _React$Component);\n\n  var _super = _createSuper(KeyboardHandler);\n\n  function KeyboardHandler() {\n    var _this;\n\n    _classCallCheck(this, KeyboardHandler);\n\n    _this = _super.apply(this, arguments);\n\n    _this.keyHandler = function (event) {\n      var isEventFromContainer = _this.props.isEventFromContainer; // If the passed keyboard event is not from the container, ignore the event by returning\n\n      if (isEventFromContainer ? !isEventFromContainer(event) : !_this._isEventFromContainer(event)) {\n        return;\n      }\n\n      var _this$props = _this.props,\n          isActiveElement = _this$props.isActiveElement,\n          getFocusableElement = _this$props.getFocusableElement,\n          noVerticalArrowHandling = _this$props.noVerticalArrowHandling,\n          noHorizontalArrowHandling = _this$props.noHorizontalArrowHandling,\n          noEnterHandling = _this$props.noEnterHandling,\n          noSpaceHandling = _this$props.noSpaceHandling,\n          updateTabIndex = _this$props.updateTabIndex,\n          validSiblingTags = _this$props.validSiblingTags,\n          additionalKeyHandler = _this$props.additionalKeyHandler,\n          createNavigableElements = _this$props.createNavigableElements,\n          onlyTraverseSiblings = _this$props.onlyTraverseSiblings; // Pass the event off to be handled by any custom handler\n\n      additionalKeyHandler && additionalKeyHandler(event); // Initalize navigableElements from the createNavigableElements callback\n\n      var navigableElements = createNavigableElements();\n\n      if (!navigableElements) {\n        // eslint-disable-next-line no-console\n        console.warn('No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.');\n        return;\n      }\n\n      var key = event.key; // Handle enter key. If noEnterHandling is passed, skip this block\n\n      if (!noEnterHandling) {\n        if (key === 'Enter') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n\n          document.activeElement.click();\n        }\n      } // Handle space key. If noSpaceHandling is passed, skip this block\n\n\n      if (!noSpaceHandling) {\n        if (key === ' ') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n\n          document.activeElement.click();\n        }\n      } // Inject helper handler for arrow navigation\n\n\n      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);\n    };\n\n    _this._isEventFromContainer = function (event) {\n      var containerRef = _this.props.containerRef;\n      return containerRef.current && containerRef.current.contains(event.target);\n    };\n\n    return _this;\n  }\n\n  _createClass(KeyboardHandler, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (canUseDOM) {\n        window.addEventListener('keydown', this.keyHandler);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (canUseDOM) {\n        window.removeEventListener('keydown', this.keyHandler);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return KeyboardHandler;\n}(React.Component);\nKeyboardHandler.displayName = 'KeyboardHandler';\nKeyboardHandler.defaultProps = {\n  containerRef: null,\n  createNavigableElements: function createNavigableElements() {\n    return null;\n  },\n  isActiveElement: function isActiveElement(navigableElement) {\n    return document.activeElement === navigableElement;\n  },\n  getFocusableElement: function getFocusableElement(navigableElement) {\n    return navigableElement;\n  },\n  validSiblingTags: ['BUTTON', 'A'],\n  onlyTraverseSiblings: true,\n  updateTabIndex: true,\n  noHorizontalArrowHandling: false,\n  noVerticalArrowHandling: false,\n  noEnterHandling: false,\n  noSpaceHandling: false\n};","map":{"version":3,"mappings":"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","names":["React","canUseDOM","handleArrows","event","navigableElements","isActiveElement","document","activeElement","contains","element","getFocusableElement","validSiblingTags","noVerticalArrowHandling","noHorizontalArrowHandling","updateTabIndex","onlyTraverseSiblings","key","moveTarget","includes","preventDefault","stopImmediatePropagation","currentIndex","forEach","index","increment","length","activeRow","querySelectorAll","join","nextSibling","previousElementSibling","nextElementSibling","tagName","focusableElement","target","tabIndex","focus","setTabIndex","options","option","KeyboardHandler","isEventFromContainer","props","_isEventFromContainer","noEnterHandling","noSpaceHandling","additionalKeyHandler","createNavigableElements","console","warn","click","containerRef","current","window","addEventListener","keyHandler","removeEventListener","Component","navigableElement"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/KeyboardHandler.tsx"],"sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './util';\n\nexport interface KeyboardHandlerProps {\n  /** Reference of the container to apply keyboard interaction */\n  containerRef: React.RefObject<any>;\n  /** Callback returning an array of navigable elements to be traversable via vertical arrow keys. This array should not include non-navigable elements such as disabled elements. */\n  createNavigableElements: () => Element[];\n  /** Callback to determine if a given event is from the container. By default the function conducts a basic check to see if the containerRef contains the event target */\n  isEventFromContainer?: (event: KeyboardEvent) => boolean;\n  /** Additional key handling outside of the included arrow keys, enter, and space handling */\n  additionalKeyHandler?: (event: KeyboardEvent) => void;\n  /** Callback to determine if a given element from the navigable elements array is the active element of the page */\n  isActiveElement?: (navigableElement: Element) => boolean;\n  /** Callback returning the focusable element of a given element from the navigable elements array */\n  getFocusableElement?: (navigableElement: Element) => Element;\n  /** Valid sibling tags that horizontal arrow handling will focus */\n  validSiblingTags?: string[];\n  /** Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex */\n  updateTabIndex?: boolean;\n  /** Flag indicating that next focusable element of a horizontal movement will be this element's sibling */\n  onlyTraverseSiblings?: boolean;\n  /** Flag indicating that the included vertical arrow key handling should be ignored */\n  noVerticalArrowHandling?: boolean;\n  /** Flag indicating that the included horizontal arrow key handling should be ignored */\n  noHorizontalArrowHandling?: boolean;\n  /** Flag indicating that the included enter key handling should be ignored */\n  noEnterHandling?: boolean;\n  /** Flag indicating that the included space key handling should be ignored */\n  noSpaceHandling?: boolean;\n}\n\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = (\n  event: KeyboardEvent,\n  navigableElements: Element[],\n  isActiveElement: (element: Element) => boolean = element => document.activeElement.contains(element),\n  getFocusableElement: (element: Element) => Element = element => element,\n  validSiblingTags: string[] = ['A', 'BUTTON', 'INPUT'],\n  noVerticalArrowHandling: boolean = false,\n  noHorizontalArrowHandling: boolean = false,\n  updateTabIndex: boolean = true,\n  onlyTraverseSiblings: boolean = true\n) => {\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget: Element = null;\n\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      // Traverse navigableElements to find the element which is currently active\n      let currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0;\n\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                }\n\n                // Set the next target element\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      (activeElement as HTMLElement).tabIndex = -1;\n      (moveTarget as HTMLElement).tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    (moveTarget as HTMLElement).focus();\n  }\n};\n\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = (options: HTMLElement[]) => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach((option: HTMLElement) => {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\n\nexport class KeyboardHandler extends React.Component<KeyboardHandlerProps> {\n  static displayName = 'KeyboardHandler';\n  static defaultProps: KeyboardHandlerProps = {\n    containerRef: null,\n    createNavigableElements: () => null as Element[],\n    isActiveElement: (navigableElement: Element) => document.activeElement === navigableElement,\n    getFocusableElement: (navigableElement: Element) => navigableElement,\n    validSiblingTags: ['BUTTON', 'A'],\n    onlyTraverseSiblings: true,\n    updateTabIndex: true,\n    noHorizontalArrowHandling: false,\n    noVerticalArrowHandling: false,\n    noEnterHandling: false,\n    noSpaceHandling: false\n  };\n\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  keyHandler = (event: KeyboardEvent) => {\n    const { isEventFromContainer } = this.props;\n    // If the passed keyboard event is not from the container, ignore the event by returning\n    if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n      return;\n    }\n\n    const {\n      isActiveElement,\n      getFocusableElement,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      noEnterHandling,\n      noSpaceHandling,\n      updateTabIndex,\n      validSiblingTags,\n      additionalKeyHandler,\n      createNavigableElements,\n      onlyTraverseSiblings\n    } = this.props;\n\n    // Pass the event off to be handled by any custom handler\n    additionalKeyHandler && additionalKeyHandler(event);\n\n    // Initalize navigableElements from the createNavigableElements callback\n    const navigableElements = createNavigableElements();\n    if (!navigableElements) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.'\n      );\n      return;\n    }\n    const key = event.key;\n\n    // Handle enter key. If noEnterHandling is passed, skip this block\n    if (!noEnterHandling) {\n      if (key === 'Enter') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Handle space key. If noSpaceHandling is passed, skip this block\n    if (!noSpaceHandling) {\n      if (key === ' ') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Inject helper handler for arrow navigation\n    handleArrows(\n      event,\n      navigableElements,\n      isActiveElement,\n      getFocusableElement,\n      validSiblingTags,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      updateTabIndex,\n      onlyTraverseSiblings\n    );\n  };\n\n  _isEventFromContainer = (event: KeyboardEvent) => {\n    const { containerRef } = this.props;\n    return containerRef.current && containerRef.current.contains(event.target as HTMLElement);\n  };\n\n  render() {\n    return null as React.ReactNode;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}