{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param delay - delay after which buffer outputs new data (if any)\n * @param preprocessor - function by which each added line is modified\n */\nexport const useDataBuffer = function (delay) {\n  let preprocessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lines => lines;\n  const [dataIn, setDataIn] = useState([]);\n  const [dataOut, setDataOut] = useState([]);\n  const [currentLineCount, setCurrentLineCount] = useState(0);\n  const bufferInterval = useRef();\n  const newLinesCounts = useRef([]);\n  useEffect(() => {\n    bufferInterval.current = setInterval(() => {\n      if (newLinesCounts.current.length) {\n        const newCnt = currentLineCount + newLinesCounts.current[0];\n        setDataOut(dataIn.slice(0, newCnt));\n        setCurrentLineCount(newCnt);\n        newLinesCounts.current.shift();\n      }\n    }, delay);\n  }, [delay, currentLineCount, dataIn]);\n  useEffect(() => {// setDataOut(dataIn.slice(0, currentLineCount));\n    // this code has to execute only when currentLineCount changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentLineCount]); // adds new lines to the buffer\n\n  const addLines = useCallback(lines => {\n    setDataIn([...dataIn, ...preprocessor(lines)]);\n    newLinesCounts.current.push(lines.length);\n  }, [dataIn, preprocessor]);\n  return [dataOut, addLines];\n};","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useDataBuffer","delay","preprocessor","lines","dataIn","setDataIn","dataOut","setDataOut","currentLineCount","setCurrentLineCount","bufferInterval","newLinesCounts","current","setInterval","length","newCnt","slice","shift","addLines","push"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/containers/useDataBuffer.ts"],"sourcesContent":["import { MutableRefObject, useCallback, useEffect, useRef, useState } from 'react';\n\ntype PreprocessorFunction = (lines: string[]) => string[];\ntype AddLinesFunction = (lines: string[]) => void;\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param delay - delay after which buffer outputs new data (if any)\n * @param preprocessor - function by which each added line is modified\n */\nexport const useDataBuffer = (\n  delay: number,\n  preprocessor: PreprocessorFunction = (lines: string[]) => lines\n): [string[], AddLinesFunction] => {\n  const [dataIn, setDataIn] = useState<string[]>([]);\n  const [dataOut, setDataOut] = useState<string[]>([]);\n  const [currentLineCount, setCurrentLineCount] = useState<number>(0);\n\n  const bufferInterval: MutableRefObject<NodeJS.Timer | undefined> = useRef();\n\n  const newLinesCounts = useRef<number[]>([]);\n\n  useEffect(() => {\n    bufferInterval.current = setInterval(() => {\n      if (newLinesCounts.current.length) {\n        const newCnt = currentLineCount + newLinesCounts.current[0];\n        setDataOut(dataIn.slice(0, newCnt));\n        setCurrentLineCount(newCnt);\n        newLinesCounts.current.shift();\n      }\n    }, delay);\n  }, [delay, currentLineCount, dataIn]);\n\n  useEffect(() => {\n    // setDataOut(dataIn.slice(0, currentLineCount));\n    // this code has to execute only when currentLineCount changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentLineCount]);\n\n  // adds new lines to the buffer\n  const addLines = useCallback(\n    (lines: string[]) => {\n      setDataIn([...dataIn, ...preprocessor(lines)]);\n      newLinesCounts.current.push(lines.length);\n    },\n    [dataIn, preprocessor]\n  );\n\n  return [dataOut, addLines];\n};\n"],"mappings":"AAAA,SAA2BA,WAA3B,EAAwCC,SAAxC,EAAmDC,MAAnD,EAA2DC,QAA3D,QAA2E,OAA3E;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG,UAC3BC,KAD2B,EAGM;EAAA,IADjCC,YACiC,uEADKC,KAAD,IAAqBA,KACzB;EACjC,MAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAW,EAAX,CAApC;EACA,MAAM,CAACO,OAAD,EAAUC,UAAV,IAAwBR,QAAQ,CAAW,EAAX,CAAtC;EACA,MAAM,CAACS,gBAAD,EAAmBC,mBAAnB,IAA0CV,QAAQ,CAAS,CAAT,CAAxD;EAEA,MAAMW,cAA0D,GAAGZ,MAAM,EAAzE;EAEA,MAAMa,cAAc,GAAGb,MAAM,CAAW,EAAX,CAA7B;EAEAD,SAAS,CAAC,MAAM;IACda,cAAc,CAACE,OAAf,GAAyBC,WAAW,CAAC,MAAM;MACzC,IAAIF,cAAc,CAACC,OAAf,CAAuBE,MAA3B,EAAmC;QACjC,MAAMC,MAAM,GAAGP,gBAAgB,GAAGG,cAAc,CAACC,OAAf,CAAuB,CAAvB,CAAlC;QACAL,UAAU,CAACH,MAAM,CAACY,KAAP,CAAa,CAAb,EAAgBD,MAAhB,CAAD,CAAV;QACAN,mBAAmB,CAACM,MAAD,CAAnB;QACAJ,cAAc,CAACC,OAAf,CAAuBK,KAAvB;MACD;IACF,CAPmC,EAOjChB,KAPiC,CAApC;EAQD,CATQ,EASN,CAACA,KAAD,EAAQO,gBAAR,EAA0BJ,MAA1B,CATM,CAAT;EAWAP,SAAS,CAAC,MAAM,CACd;IACA;IACA;EACD,CAJQ,EAIN,CAACW,gBAAD,CAJM,CAAT,CApBiC,CA0BjC;;EACA,MAAMU,QAAQ,GAAGtB,WAAW,CACzBO,KAAD,IAAqB;IACnBE,SAAS,CAAC,CAAC,GAAGD,MAAJ,EAAY,GAAGF,YAAY,CAACC,KAAD,CAA3B,CAAD,CAAT;IACAQ,cAAc,CAACC,OAAf,CAAuBO,IAAvB,CAA4BhB,KAAK,CAACW,MAAlC;EACD,CAJyB,EAK1B,CAACV,MAAD,EAASF,YAAT,CAL0B,CAA5B;EAQA,OAAO,CAACI,OAAD,EAAUY,QAAV,CAAP;AACD,CAvCM"},"metadata":{},"sourceType":"module"}