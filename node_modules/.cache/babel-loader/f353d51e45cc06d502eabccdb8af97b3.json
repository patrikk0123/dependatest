{"ast":null,"code":"import _classCallCheck from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport { parseTime, validateTime, makeTimeOptions, amSuffix, pmSuffix, getHours, getMinutes, isWithinMinMax, getSeconds } from './TimePickerUtils';\nexport var TimePicker = /*#__PURE__*/function (_React$Component) {\n  _inherits(TimePicker, _React$Component);\n\n  var _super = _createSuper(TimePicker);\n\n  function TimePicker(props) {\n    var _this;\n\n    _classCallCheck(this, TimePicker);\n\n    _this = _super.call(this, props);\n    _this.baseComponentRef = React.createRef();\n    _this.toggleRef = React.createRef();\n    _this.inputRef = React.createRef();\n    _this.menuRef = React.createRef();\n\n    _this.onDocClick = function (event) {\n      var _a, _b, _c, _d;\n\n      var clickedOnToggle = (_b = (_a = _this.toggleRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);\n      var clickedWithinMenu = (_d = (_c = _this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);\n\n      if (_this.state.isOpen && !(clickedOnToggle || clickedWithinMenu)) {\n        _this.onToggle(false);\n      }\n    };\n\n    _this.handleGlobalKeys = function (event) {\n      var _a, _b, _c, _d;\n\n      var _this$state = _this.state,\n          isOpen = _this$state.isOpen,\n          focusedIndex = _this$state.focusedIndex,\n          scrollIndex = _this$state.scrollIndex; // keyboard pressed while focus on toggle\n\n      if ((_b = (_a = _this.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {\n        if (!isOpen && event.key !== KeyTypes.Tab) {\n          _this.onToggle(true);\n        } else if (isOpen) {\n          if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n            _this.onToggle(false);\n          } else if (event.key === KeyTypes.Enter) {\n            if (focusedIndex !== null) {\n              _this.focusSelection(focusedIndex);\n\n              event.stopPropagation();\n            } else {\n              _this.onToggle(false);\n            }\n          } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n            _this.focusSelection(scrollIndex);\n\n            _this.updateFocusedIndex(0);\n\n            event.preventDefault();\n          }\n        } // keyboard pressed while focus on menu item\n\n      } else if ((_d = (_c = _this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {\n        if (event.key === KeyTypes.ArrowDown) {\n          _this.updateFocusedIndex(1);\n\n          event.preventDefault();\n        } else if (event.key === KeyTypes.ArrowUp) {\n          _this.updateFocusedIndex(-1);\n\n          event.preventDefault();\n        } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          _this.inputRef.current.focus();\n\n          _this.onToggle(false);\n        }\n      }\n    };\n\n    _this.updateFocusedIndex = function (increment) {\n      _this.setState(function (prevState) {\n        var maxIndex = _this.getOptions().length - 1;\n        var nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n\n        if (nextIndex < 0) {\n          nextIndex = maxIndex;\n        } else if (nextIndex > maxIndex) {\n          nextIndex = 0;\n        }\n\n        _this.scrollToIndex(nextIndex);\n\n        return {\n          focusedIndex: nextIndex\n        };\n      });\n    }; // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n\n\n    _this.getIndexToScroll = function (index) {\n      if (_this.props.menuAppendTo === 'inline') {\n        return index > 0 ? index - 1 : 0;\n      }\n\n      return index;\n    };\n\n    _this.scrollToIndex = function (index) {\n      _this.getOptions()[index].closest(\".\".concat(menuStyles.menuContent)).scrollTop = _this.getOptions()[_this.getIndexToScroll(index)].offsetTop;\n    };\n\n    _this.focusSelection = function (index) {\n      var _a;\n\n      var indexToFocus = index !== -1 ? index : 0;\n\n      if ((_a = _this.menuRef) === null || _a === void 0 ? void 0 : _a.current) {\n        _this.getOptions()[indexToFocus].querySelector(\".\".concat(menuStyles.menuItem)).focus();\n      }\n    };\n\n    _this.scrollToSelection = function (time) {\n      var _this$props = _this.props,\n          delimiter = _this$props.delimiter,\n          is24Hour = _this$props.is24Hour;\n      var splitTime = time.split(_this.props.delimiter);\n      var focusedIndex = null; // build out the rest of the time assuming hh:00 if it's a partial time\n\n      if (splitTime.length < 2) {\n        time = \"\".concat(time).concat(delimiter, \"00\");\n        splitTime = time.split(delimiter); // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n      } else if (splitTime.length > 2) {\n        time = parseTime(time, _this.state.timeRegex, delimiter, !is24Hour, false);\n        splitTime = time.split(delimiter);\n      } // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n\n\n      if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n        var minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n        time = \"\".concat(splitTime[0]).concat(delimiter).concat(minutes).concat(new Date().getHours() > 11 ? pmSuffix : amSuffix);\n      } else if (!is24Hour && splitTime.length > 1 && splitTime[1].length === 2 && !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) && !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n        time = \"\".concat(time).concat(new Date().getHours() > 11 ? pmSuffix : amSuffix);\n      }\n\n      var scrollIndex = _this.getOptions().findIndex(function (option) {\n        return option.innerText === time;\n      }); // if we found an exact match, scroll to match and return index of match for focus\n\n\n      if (scrollIndex !== -1) {\n        _this.scrollToIndex(scrollIndex);\n\n        focusedIndex = scrollIndex;\n      } else if (splitTime.length === 2) {\n        // no exact match, scroll to closest hour but don't return index for focus\n        var amPm = '';\n\n        if (!is24Hour) {\n          if (splitTime[1].toUpperCase().includes('P')) {\n            amPm = pmSuffix;\n          } else if (splitTime[1].toUpperCase().includes('A')) {\n            amPm = amSuffix;\n          }\n        }\n\n        time = \"\".concat(splitTime[0]).concat(delimiter, \"00\").concat(amPm);\n        scrollIndex = _this.getOptions().findIndex(function (option) {\n          return option.innerText === time;\n        });\n\n        if (scrollIndex !== -1) {\n          _this.scrollToIndex(scrollIndex);\n        }\n      }\n\n      _this.setState({\n        focusedIndex: focusedIndex,\n        scrollIndex: scrollIndex\n      });\n    };\n\n    _this.getRegExp = function () {\n      var includeSeconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var _this$props2 = _this.props,\n          is24Hour = _this$props2.is24Hour,\n          delimiter = _this$props2.delimiter;\n      var baseRegex = \"\\\\s*(\\\\d\\\\d?)\".concat(delimiter, \"([0-5]\\\\d)\");\n\n      if (includeSeconds) {\n        baseRegex += \"\".concat(delimiter, \"?([0-5]\\\\d)?\");\n      }\n\n      return new RegExp(\"^\".concat(baseRegex).concat(is24Hour ? '' : '\\\\s*([AaPp][Mm])?', \"\\\\s*$\"));\n    };\n\n    _this.getOptions = function () {\n      var _a;\n\n      return ((_a = _this.menuRef) === null || _a === void 0 ? void 0 : _a.current) ? Array.from(_this.menuRef.current.querySelectorAll(\".\".concat(menuStyles.menuListItem))) : [];\n    };\n\n    _this.isValidFormat = function (time) {\n      if (_this.props.validateTime) {\n        return _this.props.validateTime(time);\n      }\n\n      var _this$props3 = _this.props,\n          delimiter = _this$props3.delimiter,\n          is24Hour = _this$props3.is24Hour,\n          includeSeconds = _this$props3.includeSeconds;\n      return validateTime(time, _this.getRegExp(includeSeconds), delimiter, !is24Hour);\n    };\n\n    _this.isValidTime = function (time) {\n      var _this$props4 = _this.props,\n          delimiter = _this$props4.delimiter,\n          includeSeconds = _this$props4.includeSeconds;\n      var _this$state2 = _this.state,\n          minTimeState = _this$state2.minTimeState,\n          maxTimeState = _this$state2.maxTimeState;\n      return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n    };\n\n    _this.isValid = function (time) {\n      return _this.isValidFormat(time) && _this.isValidTime(time);\n    };\n\n    _this.onToggle = function (isOpen) {\n      // on close, parse and validate input\n      _this.setState(function (prevState) {\n        var timeRegex = prevState.timeRegex,\n            isInvalid = prevState.isInvalid;\n        var _this$props5 = _this.props,\n            delimiter = _this$props5.delimiter,\n            is24Hour = _this$props5.is24Hour,\n            includeSeconds = _this$props5.includeSeconds;\n        var time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n        return {\n          isOpen: isOpen,\n          timeState: time,\n          isInvalid: isOpen ? isInvalid : !_this.isValid(time)\n        };\n      });\n    };\n\n    _this.onSelect = function (e) {\n      var _this$state3 = _this.state,\n          timeRegex = _this$state3.timeRegex,\n          timeState = _this$state3.timeState;\n      var _this$props6 = _this.props,\n          delimiter = _this$props6.delimiter,\n          is24Hour = _this$props6.is24Hour,\n          includeSeconds = _this$props6.includeSeconds;\n      var time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      if (time !== timeState) {\n        _this.onInputChange(time);\n      }\n\n      _this.inputRef.current.focus();\n\n      _this.setState({\n        isOpen: false,\n        isInvalid: false\n      });\n    };\n\n    _this.onInputClick = function (e) {\n      if (!_this.state.isOpen) {\n        _this.onToggle(true);\n      }\n\n      e.stopPropagation();\n    };\n\n    _this.onInputChange = function (newTime) {\n      var onChange = _this.props.onChange;\n      var timeRegex = _this.state.timeRegex;\n\n      if (onChange) {\n        onChange(newTime, getHours(newTime, timeRegex), getMinutes(newTime, timeRegex), getSeconds(newTime, timeRegex), _this.isValid(newTime));\n      }\n\n      _this.scrollToSelection(newTime);\n\n      _this.setState({\n        timeState: newTime\n      });\n    };\n\n    _this.onBlur = function (event) {\n      var timeRegex = _this.state.timeRegex;\n      var _this$props7 = _this.props,\n          delimiter = _this$props7.delimiter,\n          is24Hour = _this$props7.is24Hour,\n          includeSeconds = _this$props7.includeSeconds;\n      var time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      _this.setState({\n        isInvalid: !_this.isValid(time)\n      });\n    };\n\n    var _this$props8 = _this.props,\n        is24Hour = _this$props8.is24Hour,\n        delimiter = _this$props8.delimiter,\n        time = _this$props8.time,\n        includeSeconds = _this$props8.includeSeconds;\n    var _this$props9 = _this.props,\n        minTime = _this$props9.minTime,\n        maxTime = _this$props9.maxTime;\n\n    if (minTime === '') {\n      var minSeconds = includeSeconds ? \"\".concat(delimiter, \"00\") : '';\n      minTime = is24Hour ? \"00\".concat(delimiter, \"00\").concat(minSeconds) : \"12\".concat(delimiter, \"00\").concat(minSeconds, \" AM\");\n    }\n\n    if (maxTime === '') {\n      var maxSeconds = includeSeconds ? \"\".concat(delimiter, \"59\") : '';\n      maxTime = is24Hour ? \"23\".concat(delimiter, \"59\").concat(maxSeconds) : \"11\".concat(delimiter, \"59\").concat(maxSeconds, \" PM\");\n    }\n\n    var timeRegex = _this.getRegExp();\n\n    _this.state = {\n      isInvalid: false,\n      isOpen: false,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex: timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n    return _this;\n  }\n\n  _createClass(TimePicker, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      document.addEventListener('mousedown', this.onDocClick);\n      document.addEventListener('touchstart', this.onDocClick);\n      document.addEventListener('keydown', this.handleGlobalKeys);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.removeEventListener('mousedown', this.onDocClick);\n      document.removeEventListener('touchstart', this.onDocClick);\n      document.removeEventListener('keydown', this.handleGlobalKeys);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$state4 = this.state,\n          timeState = _this$state4.timeState,\n          isOpen = _this$state4.isOpen,\n          isInvalid = _this$state4.isInvalid,\n          timeRegex = _this$state4.timeRegex;\n      var _this$props10 = this.props,\n          time = _this$props10.time,\n          is24Hour = _this$props10.is24Hour,\n          delimiter = _this$props10.delimiter,\n          includeSeconds = _this$props10.includeSeconds;\n\n      if (isOpen && !prevState.isOpen && timeState && !isInvalid) {\n        this.scrollToSelection(timeState);\n      }\n\n      if (delimiter !== prevProps.delimiter) {\n        this.setState({\n          timeRegex: this.getRegExp()\n        });\n      }\n\n      if (time !== '' && time !== prevProps.time) {\n        this.setState({\n          timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _a = this.props,\n          ariaLabel = _a['aria-label'],\n          isDisabled = _a.isDisabled,\n          className = _a.className,\n          placeholder = _a.placeholder,\n          id = _a.id,\n          menuAppendTo = _a.menuAppendTo,\n          is24Hour = _a.is24Hour,\n          invalidFormatErrorMessage = _a.invalidFormatErrorMessage,\n          invalidMinMaxErrorMessage = _a.invalidMinMaxErrorMessage,\n          stepMinutes = _a.stepMinutes,\n          width = _a.width,\n          delimiter = _a.delimiter,\n          inputProps = _a.inputProps,\n          onChange = _a.onChange,\n          time = _a.time,\n          validateTime = _a.validateTime,\n          minTime = _a.minTime,\n          maxTime = _a.maxTime,\n          includeSeconds = _a.includeSeconds,\n          props = __rest(_a, ['aria-label', \"isDisabled\", \"className\", \"placeholder\", \"id\", \"menuAppendTo\", \"is24Hour\", \"invalidFormatErrorMessage\", \"invalidMinMaxErrorMessage\", \"stepMinutes\", \"width\", \"delimiter\", \"inputProps\", \"onChange\", \"time\", \"validateTime\", \"minTime\", \"maxTime\", \"includeSeconds\"]);\n\n      var _this$state5 = this.state,\n          timeState = _this$state5.timeState,\n          isOpen = _this$state5.isOpen,\n          isInvalid = _this$state5.isInvalid,\n          minTimeState = _this$state5.minTimeState,\n          maxTimeState = _this$state5.maxTimeState;\n      var style = {\n        '--pf-c-date-picker__input--c-form-control--Width': width\n      };\n      var options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n      var isValidFormat = this.isValidFormat(timeState);\n      var randomId = id || getUniqueId('time-picker');\n\n      var getParentElement = function getParentElement() {\n        if (_this2.baseComponentRef && _this2.baseComponentRef.current) {\n          return _this2.baseComponentRef.current.parentElement;\n        }\n\n        return null;\n      };\n\n      var menuContainer = React.createElement(Menu, {\n        ref: this.menuRef,\n        isScrollable: true\n      }, React.createElement(MenuContent, {\n        maxMenuHeight: \"200px\"\n      }, React.createElement(MenuList, {\n        \"aria-label\": ariaLabel\n      }, options.map(function (option, index) {\n        return React.createElement(MenuItem, {\n          onClick: _this2.onSelect,\n          key: option,\n          id: \"\".concat(randomId, \"-option-\").concat(index)\n        }, option);\n      }))));\n      var textInput = React.createElement(TextInput, Object.assign({\n        \"aria-haspopup\": \"menu\",\n        className: css(formStyles.formControl),\n        id: \"\".concat(randomId, \"-input\"),\n        \"aria-label\": ariaLabel,\n        validated: isInvalid ? 'error' : 'default',\n        placeholder: placeholder,\n        value: timeState || '',\n        type: \"text\",\n        iconVariant: \"clock\",\n        onClick: this.onInputClick,\n        onChange: this.onInputChange,\n        onBlur: this.onBlur,\n        autoComplete: \"off\",\n        isDisabled: isDisabled,\n        ref: this.inputRef\n      }, inputProps));\n      return React.createElement(\"div\", {\n        ref: this.baseComponentRef,\n        className: css(datePickerStyles.datePicker, className)\n      }, React.createElement(\"div\", Object.assign({\n        className: css(datePickerStyles.datePickerInput),\n        style: style\n      }, props), React.createElement(InputGroup, null, React.createElement(\"div\", {\n        id: randomId\n      }, React.createElement(\"div\", {\n        ref: this.toggleRef,\n        style: {\n          paddingLeft: '0'\n        }\n      }, menuAppendTo !== 'inline' ? React.createElement(Popper, {\n        appendTo: menuAppendTo === 'parent' ? getParentElement() : menuAppendTo,\n        trigger: textInput,\n        popper: menuContainer,\n        isVisible: isOpen\n      }) : textInput), isOpen && menuAppendTo === 'inline' && menuContainer)), isInvalid && React.createElement(\"div\", {\n        className: css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)\n      }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)));\n    }\n  }]);\n\n  return TimePicker;\n}(React.Component);\nTimePicker.displayName = 'TimePicker';\nTimePicker.defaultProps = {\n  className: '',\n  isDisabled: false,\n  time: '',\n  is24Hour: false,\n  invalidFormatErrorMessage: 'Invalid time format',\n  invalidMinMaxErrorMessage: 'Invalid time entered',\n  placeholder: 'hh:mm',\n  delimiter: ':',\n  'aria-label': 'Time picker',\n  width: '150px',\n  menuAppendTo: 'inline',\n  stepMinutes: 30,\n  inputProps: {},\n  minTime: '',\n  maxTime: ''\n};","map":{"version":3,"mappings":"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","names":["React","css","datePickerStyles","formStyles","menuStyles","getUniqueId","Popper","Menu","MenuContent","MenuList","MenuItem","InputGroup","TextInput","KeyTypes","parseTime","validateTime","makeTimeOptions","amSuffix","pmSuffix","getHours","getMinutes","isWithinMinMax","getSeconds","TimePicker","props","createRef","event","clickedOnToggle","toggleRef","_a","current","_b","contains","target","clickedWithinMenu","menuRef","_c","_d","state","isOpen","onToggle","focusedIndex","scrollIndex","inputRef","key","Tab","Escape","Enter","focusSelection","stopPropagation","ArrowDown","ArrowUp","updateFocusedIndex","preventDefault","focus","increment","setState","maxIndex","getOptions","length","nextIndex","prevState","scrollToIndex","index","menuAppendTo","closest","menuContent","scrollTop","getIndexToScroll","offsetTop","indexToFocus","querySelector","menuItem","time","delimiter","is24Hour","splitTime","split","timeRegex","minutes","Date","toUpperCase","includes","trim","findIndex","option","innerText","amPm","includeSeconds","baseRegex","RegExp","Array","from","querySelectorAll","menuListItem","getRegExp","minTimeState","maxTimeState","isValidFormat","isValidTime","isInvalid","timeState","isValid","e","textContent","onInputChange","newTime","onChange","scrollToSelection","currentTarget","value","minTime","maxTime","minSeconds","maxSeconds","document","addEventListener","onDocClick","handleGlobalKeys","removeEventListener","prevProps","ariaLabel","isDisabled","className","placeholder","id","invalidFormatErrorMessage","invalidMinMaxErrorMessage","stepMinutes","width","inputProps","__rest","style","options","randomId","getParentElement","baseComponentRef","parentElement","menuContainer","ref","isScrollable","maxMenuHeight","map","onClick","onSelect","textInput","Object","formControl","validated","type","iconVariant","onInputClick","onBlur","autoComplete","datePicker","datePickerInput","paddingLeft","appendTo","trigger","popper","isVisible","datePickerHelperText","modifiers","error","Component"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/components/TimePicker/TimePicker.tsx"],"sourcesContent":["import * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput, TextInputProps } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport {\n  parseTime,\n  validateTime,\n  makeTimeOptions,\n  amSuffix,\n  pmSuffix,\n  getHours,\n  getMinutes,\n  isWithinMinMax,\n  getSeconds\n} from './TimePickerUtils';\n\nexport interface TimePickerProps\n  extends Omit<React.HTMLProps<HTMLDivElement>, 'onChange' | 'onFocus' | 'onBlur' | 'disabled' | 'ref'> {\n  /** Additional classes added to the time picker. */\n  className?: string;\n  /** Accessible label for the time picker */\n  'aria-label'?: string;\n  /** Flag indicating the time picker is disabled */\n  isDisabled?: boolean;\n  /** String to display in the empty time picker field as a hint for the expected time format */\n  placeholder?: string;\n  /** Character to display between the hour and minute */\n  delimiter?: string;\n  /** A time string. The format could be  an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  time?: string | Date;\n  /** Error message to display when the time is provided in an invalid format. */\n  invalidFormatErrorMessage?: string;\n  /** Error message to display when the time provided is not within the minTime/maxTime constriants */\n  invalidMinMaxErrorMessage?: string;\n  /** True if the time is 24 hour time. False if the time is 12 hour time */\n  is24Hour?: boolean;\n  /** Optional event handler called each time the value in the time picker input changes. */\n  onChange?: (time: string, hour?: number, minute?: number, seconds?: number, isValid?: boolean) => void;\n  /** Optional validator can be provided to override the internal time validator. */\n  validateTime?: (time: string) => boolean;\n  /** Id of the time picker */\n  id?: string;\n  /** Width of the time picker. */\n  width?: string;\n  /** The container to append the menu to. Defaults to 'inline'.\n   * If your menu is being cut off you can append it to an element higher up the DOM tree.\n   * Some examples:\n   * menuAppendTo=\"parent\"\n   * menuAppendTo={() => document.body}\n   * menuAppendTo={document.getElementById('target')}\n   */\n  menuAppendTo?: HTMLElement | (() => HTMLElement) | 'inline' | 'parent';\n  /** Size of step between time options in minutes.*/\n  stepMinutes?: number;\n  /** Additional props for input field */\n  inputProps?: TextInputProps;\n  /** A time string indicating the minimum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  minTime?: string | Date;\n  /** A time string indicating the maximum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  maxTime?: string | Date;\n  /** Includes number of seconds with the chosen time and allows users to manually edit the seconds value. */\n  includeSeconds?: boolean;\n}\n\ninterface TimePickerState {\n  isInvalid: boolean;\n  isOpen: boolean;\n  timeState: string;\n  focusedIndex: number;\n  scrollIndex: number;\n  timeRegex: RegExp;\n  minTimeState: string;\n  maxTimeState: string;\n}\n\nexport class TimePicker extends React.Component<TimePickerProps, TimePickerState> {\n  static displayName = 'TimePicker';\n  private baseComponentRef = React.createRef<any>();\n  private toggleRef = React.createRef<HTMLDivElement>();\n  private inputRef = React.createRef<HTMLInputElement>();\n  private menuRef = React.createRef<HTMLDivElement>();\n\n  static defaultProps = {\n    className: '',\n    isDisabled: false,\n    time: '',\n    is24Hour: false,\n    invalidFormatErrorMessage: 'Invalid time format',\n    invalidMinMaxErrorMessage: 'Invalid time entered',\n    placeholder: 'hh:mm',\n    delimiter: ':',\n    'aria-label': 'Time picker',\n    width: '150px',\n    menuAppendTo: 'inline',\n    stepMinutes: 30,\n    inputProps: {},\n    minTime: '',\n    maxTime: ''\n  };\n\n  constructor(props: TimePickerProps) {\n    super(props);\n    const { is24Hour, delimiter, time, includeSeconds } = this.props;\n    let { minTime, maxTime } = this.props;\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isOpen: false,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  onDocClick = (event: MouseEvent | TouchEvent) => {\n    const clickedOnToggle = this.toggleRef?.current?.contains(event.target as Node);\n    const clickedWithinMenu = this.menuRef?.current?.contains(event.target as Node);\n    if (this.state.isOpen && !(clickedOnToggle || clickedWithinMenu)) {\n      this.onToggle(false);\n    }\n  };\n\n  handleGlobalKeys = (event: KeyboardEvent) => {\n    const { isOpen, focusedIndex, scrollIndex } = this.state;\n    // keyboard pressed while focus on toggle\n    if (this.inputRef?.current?.contains(event.target as Node)) {\n      if (!isOpen && event.key !== KeyTypes.Tab) {\n        this.onToggle(true);\n      } else if (isOpen) {\n        if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.onToggle(false);\n        } else if (event.key === KeyTypes.Enter) {\n          if (focusedIndex !== null) {\n            this.focusSelection(focusedIndex);\n            event.stopPropagation();\n          } else {\n            this.onToggle(false);\n          }\n        } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n          this.focusSelection(scrollIndex);\n          this.updateFocusedIndex(0);\n          event.preventDefault();\n        }\n      }\n      // keyboard pressed while focus on menu item\n    } else if (this.menuRef?.current?.contains(event.target as Node)) {\n      if (event.key === KeyTypes.ArrowDown) {\n        this.updateFocusedIndex(1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.ArrowUp) {\n        this.updateFocusedIndex(-1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n        this.inputRef.current.focus();\n        this.onToggle(false);\n      }\n    }\n  };\n\n  componentDidUpdate(prevProps: TimePickerProps, prevState: TimePickerState) {\n    const { timeState, isOpen, isInvalid, timeRegex } = this.state;\n    const { time, is24Hour, delimiter, includeSeconds } = this.props;\n    if (isOpen && !prevState.isOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n    if (time !== '' && time !== prevProps.time) {\n      this.setState({\n        timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n\n  updateFocusedIndex = (increment: number) => {\n    this.setState(prevState => {\n      const maxIndex = this.getOptions().length - 1;\n      let nextIndex =\n        prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n      if (nextIndex < 0) {\n        nextIndex = maxIndex;\n      } else if (nextIndex > maxIndex) {\n        nextIndex = 0;\n      }\n      this.scrollToIndex(nextIndex);\n      return {\n        focusedIndex: nextIndex\n      };\n    });\n  };\n\n  // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n  getIndexToScroll = (index: number) => {\n    if (this.props.menuAppendTo === 'inline') {\n      return index > 0 ? index - 1 : 0;\n    }\n    return index;\n  };\n\n  scrollToIndex = (index: number) => {\n    this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[\n      this.getIndexToScroll(index)\n    ].offsetTop;\n  };\n\n  focusSelection = (index: number) => {\n    const indexToFocus = index !== -1 ? index : 0;\n\n    if (this.menuRef?.current) {\n      (this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`) as HTMLElement).focus();\n    }\n  };\n\n  scrollToSelection = (time: string) => {\n    const { delimiter, is24Hour } = this.props;\n    let splitTime = time.split(this.props.delimiter);\n    let focusedIndex = null;\n\n    // build out the rest of the time assuming hh:00 if it's a partial time\n    if (splitTime.length < 2) {\n      time = `${time}${delimiter}00`;\n      splitTime = time.split(delimiter);\n      // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n    } else if (splitTime.length > 2) {\n      time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n      splitTime = time.split(delimiter);\n    }\n\n    // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n    if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n      const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n      time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    } else if (\n      !is24Hour &&\n      splitTime.length > 1 &&\n      splitTime[1].length === 2 &&\n      !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) &&\n      !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())\n    ) {\n      time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    }\n    let scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n\n    // if we found an exact match, scroll to match and return index of match for focus\n    if (scrollIndex !== -1) {\n      this.scrollToIndex(scrollIndex);\n      focusedIndex = scrollIndex;\n    } else if (splitTime.length === 2) {\n      // no exact match, scroll to closest hour but don't return index for focus\n      let amPm = '';\n      if (!is24Hour) {\n        if (splitTime[1].toUpperCase().includes('P')) {\n          amPm = pmSuffix;\n        } else if (splitTime[1].toUpperCase().includes('A')) {\n          amPm = amSuffix;\n        }\n      }\n      time = `${splitTime[0]}${delimiter}00${amPm}`;\n      scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n      }\n    }\n    this.setState({\n      focusedIndex,\n      scrollIndex\n    });\n  };\n\n  getRegExp = (includeSeconds: boolean = true) => {\n    const { is24Hour, delimiter } = this.props;\n    let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n\n    if (includeSeconds) {\n      baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n    }\n\n    return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n  };\n\n  getOptions = () =>\n    (this.menuRef?.current\n      ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`))\n      : []) as HTMLElement[];\n\n  isValidFormat = (time: string) => {\n    if (this.props.validateTime) {\n      return this.props.validateTime(time);\n    }\n\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n  };\n\n  isValidTime = (time: string) => {\n    const { delimiter, includeSeconds } = this.props;\n    const { minTimeState, maxTimeState } = this.state;\n\n    return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n  };\n\n  isValid = (time: string) => this.isValidFormat(time) && this.isValidTime(time);\n\n  onToggle = (isOpen: boolean) => {\n    // on close, parse and validate input\n    this.setState(prevState => {\n      const { timeRegex, isInvalid } = prevState;\n      const { delimiter, is24Hour, includeSeconds } = this.props;\n      const time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      return {\n        isOpen,\n        timeState: time,\n        isInvalid: isOpen ? isInvalid : !this.isValid(time)\n      };\n    });\n  };\n\n  onSelect = (e: any) => {\n    const { timeRegex, timeState } = this.state;\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n    if (time !== timeState) {\n      this.onInputChange(time);\n    }\n\n    this.inputRef.current.focus();\n    this.setState({\n      isOpen: false,\n      isInvalid: false\n    });\n  };\n\n  onInputClick = (e: any) => {\n    if (!this.state.isOpen) {\n      this.onToggle(true);\n    }\n    e.stopPropagation();\n  };\n\n  onInputChange = (newTime: string) => {\n    const { onChange } = this.props;\n    const { timeRegex } = this.state;\n\n    if (onChange) {\n      onChange(\n        newTime,\n        getHours(newTime, timeRegex),\n        getMinutes(newTime, timeRegex),\n        getSeconds(newTime, timeRegex),\n        this.isValid(newTime)\n      );\n    }\n    this.scrollToSelection(newTime);\n    this.setState({\n      timeState: newTime\n    });\n  };\n\n  onBlur = (event: React.FocusEvent<HTMLInputElement>) => {\n    const { timeRegex } = this.state;\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    const time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n    this.setState({\n      isInvalid: !this.isValid(time)\n    });\n  };\n\n  render() {\n    const {\n      'aria-label': ariaLabel,\n      isDisabled,\n      className,\n      placeholder,\n      id,\n      menuAppendTo,\n      is24Hour,\n      invalidFormatErrorMessage,\n      invalidMinMaxErrorMessage,\n      stepMinutes,\n      width,\n      delimiter,\n      inputProps,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      onChange,\n      time,\n      validateTime,\n      minTime,\n      maxTime,\n      includeSeconds,\n      /* eslint-enable @typescript-eslint/no-unused-vars */\n      ...props\n    } = this.props;\n    const { timeState, isOpen, isInvalid, minTimeState, maxTimeState } = this.state;\n    const style = { '--pf-c-date-picker__input--c-form-control--Width': width } as React.CSSProperties;\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n      return null;\n    };\n\n    const menuContainer = (\n      <Menu ref={this.menuRef} isScrollable>\n        <MenuContent maxMenuHeight=\"200px\">\n          <MenuList aria-label={ariaLabel}>\n            {options.map((option, index) => (\n              <MenuItem onClick={this.onSelect} key={option} id={`${randomId}-option-${index}`}>\n                {option}\n              </MenuItem>\n            ))}\n          </MenuList>\n        </MenuContent>\n      </Menu>\n    );\n\n    const textInput = (\n      <TextInput\n        aria-haspopup=\"menu\"\n        className={css(formStyles.formControl)}\n        id={`${randomId}-input`}\n        aria-label={ariaLabel}\n        validated={isInvalid ? 'error' : 'default'}\n        placeholder={placeholder}\n        value={timeState || ''}\n        type=\"text\"\n        iconVariant=\"clock\"\n        onClick={this.onInputClick}\n        onChange={this.onInputChange}\n        onBlur={this.onBlur}\n        autoComplete=\"off\"\n        isDisabled={isDisabled}\n        ref={this.inputRef}\n        {...inputProps}\n      />\n    );\n\n    return (\n      <div ref={this.baseComponentRef} className={css(datePickerStyles.datePicker, className)}>\n        <div className={css(datePickerStyles.datePickerInput)} style={style} {...props}>\n          <InputGroup>\n            <div id={randomId}>\n              <div ref={this.toggleRef} style={{ paddingLeft: '0' }}>\n                {menuAppendTo !== 'inline' ? (\n                  <Popper\n                    appendTo={menuAppendTo === 'parent' ? getParentElement() : menuAppendTo}\n                    trigger={textInput}\n                    popper={menuContainer}\n                    isVisible={isOpen}\n                  />\n                ) : (\n                  textInput\n                )}\n              </div>\n              {isOpen && menuAppendTo === 'inline' && menuContainer}\n            </div>\n          </InputGroup>\n          {isInvalid && (\n            <div className={css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)}>\n              {!isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}