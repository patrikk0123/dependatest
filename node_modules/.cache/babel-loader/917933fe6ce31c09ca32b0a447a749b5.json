{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { createFocusTrap } from 'focus-trap';\nexport class FocusTrap extends React.Component {\n  constructor(props) {\n    super(props);\n    this.divRef = React.createRef();\n\n    if (typeof document !== 'undefined') {\n      this.previouslyFocusedElement = document.activeElement;\n    }\n  }\n\n  componentDidMount() {\n    // We need to hijack the returnFocusOnDeactivate option,\n    // because React can move focus into the element before we arrived at\n    // this lifecycle hook (e.g. with autoFocus inputs). So the component\n    // captures the previouslyFocusedElement in componentWillMount,\n    // then (optionally) returns focus to it in componentWillUnmount.\n    this.focusTrap = createFocusTrap(this.divRef.current, Object.assign(Object.assign({}, this.props.focusTrapOptions), {\n      returnFocusOnDeactivate: false\n    }));\n\n    if (this.props.active) {\n      this.focusTrap.activate();\n    }\n\n    if (this.props.paused) {\n      this.focusTrap.pause();\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.active && !this.props.active) {\n      this.focusTrap.deactivate();\n    } else if (!prevProps.active && this.props.active) {\n      this.focusTrap.activate();\n    }\n\n    if (prevProps.paused && !this.props.paused) {\n      this.focusTrap.unpause();\n    } else if (!prevProps.paused && this.props.paused) {\n      this.focusTrap.pause();\n    }\n  }\n\n  componentWillUnmount() {\n    this.focusTrap.deactivate();\n\n    if (this.props.focusTrapOptions.returnFocusOnDeactivate !== false && this.previouslyFocusedElement && this.previouslyFocusedElement.focus) {\n      this.previouslyFocusedElement.focus({\n        preventScroll: this.props.preventScrollOnDeactivate\n      });\n    }\n  }\n\n  render() {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const _a = this.props,\n          {\n      children,\n      className,\n      focusTrapOptions,\n      active,\n      paused,\n      preventScrollOnDeactivate\n    } = _a,\n          rest = __rest(_a, [\"children\", \"className\", \"focusTrapOptions\", \"active\", \"paused\", \"preventScrollOnDeactivate\"]);\n\n    return React.createElement(\"div\", Object.assign({\n      ref: this.divRef,\n      className: className\n    }, rest), children);\n  }\n\n}\nFocusTrap.displayName = 'FocusTrap';\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  preventScrollOnDeactivate: false\n};","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,eAAT,QAAsF,YAAtF;AAYA,OAAM,MAAOC,SAAP,SAAyBF,KAAK,CAACG,SAA/B,CAAwD;EAa5DC,YAAYC,KAAZ,EAAiC;IAC/B,MAAMA,KAAN;IAVF,cAASL,KAAK,CAACM,SAAN,EAAT;;IAYE,IAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqC;MACnC,KAAKC,wBAAL,GAAgCD,QAAQ,CAACE,aAAzC;IACD;EACF;;EAEDC,iBAAiB;IACf;IACA;IACA;IACA;IACA;IACA,KAAKC,SAAL,GAAiBV,eAAe,CAAC,KAAKW,MAAL,CAAYC,OAAb,EAAoBC,gCAC/C,KAAKT,KAAL,CAAWU,gBADoC,GACpB;MAC9BC,uBAAuB,EAAE;IADK,CADoB,CAApB,CAAhC;;IAIA,IAAI,KAAKX,KAAL,CAAWY,MAAf,EAAuB;MACrB,KAAKN,SAAL,CAAeO,QAAf;IACD;;IACD,IAAI,KAAKb,KAAL,CAAWc,MAAf,EAAuB;MACrB,KAAKR,SAAL,CAAeS,KAAf;IACD;EACF;;EAEDC,kBAAkB,CAACC,SAAD,EAA0B;IAC1C,IAAIA,SAAS,CAACL,MAAV,IAAoB,CAAC,KAAKZ,KAAL,CAAWY,MAApC,EAA4C;MAC1C,KAAKN,SAAL,CAAeY,UAAf;IACD,CAFD,MAEO,IAAI,CAACD,SAAS,CAACL,MAAX,IAAqB,KAAKZ,KAAL,CAAWY,MAApC,EAA4C;MACjD,KAAKN,SAAL,CAAeO,QAAf;IACD;;IAED,IAAII,SAAS,CAACH,MAAV,IAAoB,CAAC,KAAKd,KAAL,CAAWc,MAApC,EAA4C;MAC1C,KAAKR,SAAL,CAAea,OAAf;IACD,CAFD,MAEO,IAAI,CAACF,SAAS,CAACH,MAAX,IAAqB,KAAKd,KAAL,CAAWc,MAApC,EAA4C;MACjD,KAAKR,SAAL,CAAeS,KAAf;IACD;EACF;;EAEDK,oBAAoB;IAClB,KAAKd,SAAL,CAAeY,UAAf;;IACA,IACE,KAAKlB,KAAL,CAAWU,gBAAX,CAA4BC,uBAA5B,KAAwD,KAAxD,IACA,KAAKR,wBADL,IAEA,KAAKA,wBAAL,CAA8BkB,KAHhC,EAIE;MACA,KAAKlB,wBAAL,CAA8BkB,KAA9B,CAAoC;QAAEC,aAAa,EAAE,KAAKtB,KAAL,CAAWuB;MAA5B,CAApC;IACD;EACF;;EAEDC,MAAM;IACJ;IACA,MAAMC,KAAgG,KAAKzB,KAA3G;IAAA,MAAM;MAAE0B,QAAF;MAAYC,SAAZ;MAAuBjB,gBAAvB;MAAyCE,MAAzC;MAAiDE,MAAjD;MAAyDS;IAAzD,IAAkFE,EAAxF;IAAA,MAA6FG,IAAI,cAA3F,8FAA2F,CAAjG;;IACA,OACEjC;MAAKkC,GAAG,EAAE,KAAKtB,MAAf;MAAuBoB,SAAS,EAAEA;IAAlC,GAAiDC,IAAjD,GACGF,QADH,CADF;EAKD;;AAxE2D;AACrD7B,wBAAc,WAAd;AAKAA,yBAAe;EACpBe,MAAM,EAAE,IADY;EAEpBE,MAAM,EAAE,KAFY;EAGpBJ,gBAAgB,EAAE,EAHE;EAIpBa,yBAAyB,EAAE;AAJP,CAAf","names":["React","createFocusTrap","FocusTrap","Component","constructor","props","createRef","document","previouslyFocusedElement","activeElement","componentDidMount","focusTrap","divRef","current","Object","focusTrapOptions","returnFocusOnDeactivate","active","activate","paused","pause","componentDidUpdate","prevProps","deactivate","unpause","componentWillUnmount","focus","preventScroll","preventScrollOnDeactivate","render","_a","children","className","rest","ref"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/FocusTrap/FocusTrap.tsx"],"sourcesContent":["import * as React from 'react';\nimport { createFocusTrap, Options as FocusTrapOptions, FocusTrap as IFocusTrap } from 'focus-trap';\n\ninterface FocusTrapProps extends React.HTMLProps<HTMLDivElement> {\n  children: React.ReactNode;\n  className?: string;\n  active?: boolean;\n  paused?: boolean;\n  focusTrapOptions?: FocusTrapOptions;\n  /** Prevent from scrolling to the previously focused element on deactivation */\n  preventScrollOnDeactivate?: boolean;\n}\n\nexport class FocusTrap extends React.Component<FocusTrapProps> {\n  static displayName = 'FocusTrap';\n  previouslyFocusedElement: HTMLElement;\n  focusTrap: IFocusTrap;\n  divRef = React.createRef<HTMLDivElement>();\n\n  static defaultProps = {\n    active: true,\n    paused: false,\n    focusTrapOptions: {},\n    preventScrollOnDeactivate: false\n  };\n\n  constructor(props: FocusTrapProps) {\n    super(props);\n\n    if (typeof document !== 'undefined') {\n      this.previouslyFocusedElement = document.activeElement as HTMLElement;\n    }\n  }\n\n  componentDidMount() {\n    // We need to hijack the returnFocusOnDeactivate option,\n    // because React can move focus into the element before we arrived at\n    // this lifecycle hook (e.g. with autoFocus inputs). So the component\n    // captures the previouslyFocusedElement in componentWillMount,\n    // then (optionally) returns focus to it in componentWillUnmount.\n    this.focusTrap = createFocusTrap(this.divRef.current, {\n      ...this.props.focusTrapOptions,\n      returnFocusOnDeactivate: false\n    });\n    if (this.props.active) {\n      this.focusTrap.activate();\n    }\n    if (this.props.paused) {\n      this.focusTrap.pause();\n    }\n  }\n\n  componentDidUpdate(prevProps: FocusTrapProps) {\n    if (prevProps.active && !this.props.active) {\n      this.focusTrap.deactivate();\n    } else if (!prevProps.active && this.props.active) {\n      this.focusTrap.activate();\n    }\n\n    if (prevProps.paused && !this.props.paused) {\n      this.focusTrap.unpause();\n    } else if (!prevProps.paused && this.props.paused) {\n      this.focusTrap.pause();\n    }\n  }\n\n  componentWillUnmount() {\n    this.focusTrap.deactivate();\n    if (\n      this.props.focusTrapOptions.returnFocusOnDeactivate !== false &&\n      this.previouslyFocusedElement &&\n      this.previouslyFocusedElement.focus\n    ) {\n      this.previouslyFocusedElement.focus({ preventScroll: this.props.preventScrollOnDeactivate });\n    }\n  }\n\n  render() {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { children, className, focusTrapOptions, active, paused, preventScrollOnDeactivate, ...rest } = this.props;\n    return (\n      <div ref={this.divRef} className={className} {...rest}>\n        {children}\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}