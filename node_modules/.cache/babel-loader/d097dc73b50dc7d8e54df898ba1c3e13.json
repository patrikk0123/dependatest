{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport { parseTime, validateTime, makeTimeOptions, amSuffix, pmSuffix, getHours, getMinutes, isWithinMinMax, getSeconds } from './TimePickerUtils';\nexport class TimePicker extends React.Component {\n  constructor(props) {\n    var _this;\n\n    super(props);\n    _this = this;\n    this.baseComponentRef = React.createRef();\n    this.toggleRef = React.createRef();\n    this.inputRef = React.createRef();\n    this.menuRef = React.createRef();\n\n    this.onDocClick = event => {\n      var _a, _b, _c, _d;\n\n      const clickedOnToggle = (_b = (_a = this.toggleRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);\n      const clickedWithinMenu = (_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);\n\n      if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n        this.onToggle(false);\n      }\n    };\n\n    this.handleGlobalKeys = event => {\n      var _a, _b, _c, _d;\n\n      const {\n        isTimeOptionsOpen,\n        focusedIndex,\n        scrollIndex\n      } = this.state; // keyboard pressed while focus on toggle\n\n      if ((_b = (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {\n        if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n          this.onToggle(true);\n        } else if (isTimeOptionsOpen) {\n          if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n            this.onToggle(false);\n          } else if (event.key === KeyTypes.Enter) {\n            if (focusedIndex !== null) {\n              this.focusSelection(focusedIndex);\n              event.stopPropagation();\n            } else {\n              this.onToggle(false);\n            }\n          } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n            this.focusSelection(scrollIndex);\n            this.updateFocusedIndex(0);\n            event.preventDefault();\n          }\n        } // keyboard pressed while focus on menu item\n\n      } else if ((_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {\n        if (event.key === KeyTypes.ArrowDown) {\n          this.updateFocusedIndex(1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.ArrowUp) {\n          this.updateFocusedIndex(-1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.inputRef.current.focus();\n          this.onToggle(false);\n        }\n      }\n    };\n\n    this.updateFocusedIndex = increment => {\n      this.setState(prevState => {\n        const maxIndex = this.getOptions().length - 1;\n        let nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n\n        if (nextIndex < 0) {\n          nextIndex = maxIndex;\n        } else if (nextIndex > maxIndex) {\n          nextIndex = 0;\n        }\n\n        this.scrollToIndex(nextIndex);\n        return {\n          focusedIndex: nextIndex\n        };\n      });\n    }; // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n\n\n    this.getIndexToScroll = index => {\n      if (this.props.menuAppendTo === 'inline') {\n        return index > 0 ? index - 1 : 0;\n      }\n\n      return index;\n    };\n\n    this.scrollToIndex = index => {\n      this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[this.getIndexToScroll(index)].offsetTop;\n    };\n\n    this.focusSelection = index => {\n      var _a;\n\n      const indexToFocus = index !== -1 ? index : 0;\n\n      if ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) {\n        this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`).focus();\n      }\n    };\n\n    this.scrollToSelection = time => {\n      const {\n        delimiter,\n        is24Hour\n      } = this.props;\n      let splitTime = time.split(this.props.delimiter);\n      let focusedIndex = null; // build out the rest of the time assuming hh:00 if it's a partial time\n\n      if (splitTime.length < 2) {\n        time = `${time}${delimiter}00`;\n        splitTime = time.split(delimiter); // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n      } else if (splitTime.length > 2) {\n        time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n        splitTime = time.split(delimiter);\n      } // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n\n\n      if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n        const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n        time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      } else if (!is24Hour && splitTime.length > 1 && splitTime[1].length === 2 && !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) && !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n        time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      }\n\n      let scrollIndex = this.getOptions().findIndex(option => option.innerText === time); // if we found an exact match, scroll to match and return index of match for focus\n\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n        focusedIndex = scrollIndex;\n      } else if (splitTime.length === 2) {\n        // no exact match, scroll to closest hour but don't return index for focus\n        let amPm = '';\n\n        if (!is24Hour) {\n          if (splitTime[1].toUpperCase().includes('P')) {\n            amPm = pmSuffix;\n          } else if (splitTime[1].toUpperCase().includes('A')) {\n            amPm = amSuffix;\n          }\n        }\n\n        time = `${splitTime[0]}${delimiter}00${amPm}`;\n        scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n\n        if (scrollIndex !== -1) {\n          this.scrollToIndex(scrollIndex);\n        }\n      }\n\n      this.setState({\n        focusedIndex,\n        scrollIndex\n      });\n    };\n\n    this.getRegExp = function () {\n      let includeSeconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      const {\n        is24Hour,\n        delimiter\n      } = _this.props;\n      let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n\n      if (includeSeconds) {\n        baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n      }\n\n      return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n    };\n\n    this.getOptions = () => {\n      var _a;\n\n      return ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`)) : [];\n    };\n\n    this.isValidFormat = time => {\n      if (this.props.validateTime) {\n        return this.props.validateTime(time);\n      }\n\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds\n      } = this.props;\n      return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n    };\n\n    this.isValidTime = time => {\n      const {\n        delimiter,\n        includeSeconds\n      } = this.props;\n      const {\n        minTimeState,\n        maxTimeState\n      } = this.state;\n      return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n    };\n\n    this.isValid = time => this.isValidFormat(time) && this.isValidTime(time);\n\n    this.onToggle = isOpen => {\n      // on close, parse and validate input\n      this.setState(prevState => {\n        const {\n          timeRegex,\n          isInvalid\n        } = prevState;\n        const {\n          delimiter,\n          is24Hour,\n          includeSeconds\n        } = this.props;\n        const time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n        return {\n          isTimeOptionsOpen: isOpen,\n          timeState: time,\n          isInvalid: isOpen ? isInvalid : !this.isValid(time)\n        };\n      });\n      this.props.setIsOpen(isOpen);\n\n      if (!isOpen) {\n        this.inputRef.current.focus();\n      }\n    };\n\n    this.onSelect = e => {\n      const {\n        timeRegex,\n        timeState\n      } = this.state;\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds,\n        setIsOpen\n      } = this.props;\n      const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      if (time !== timeState) {\n        this.onInputChange(time);\n      }\n\n      this.inputRef.current.focus();\n      this.setState({\n        isTimeOptionsOpen: false,\n        isInvalid: false\n      });\n      setIsOpen(false);\n    };\n\n    this.onInputClick = e => {\n      if (!this.state.isTimeOptionsOpen) {\n        this.onToggle(true);\n      }\n\n      e.stopPropagation();\n    };\n\n    this.onInputChange = newTime => {\n      const {\n        onChange\n      } = this.props;\n      const {\n        timeRegex\n      } = this.state;\n\n      if (onChange) {\n        onChange(newTime, getHours(newTime, timeRegex), getMinutes(newTime, timeRegex), getSeconds(newTime, timeRegex), this.isValid(newTime));\n      }\n\n      this.scrollToSelection(newTime);\n      this.setState({\n        timeState: newTime\n      });\n    };\n\n    this.onBlur = event => {\n      const {\n        timeRegex\n      } = this.state;\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds\n      } = this.props;\n      const time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n      this.setState({\n        isInvalid: !this.isValid(time)\n      });\n    };\n\n    const {\n      is24Hour,\n      delimiter,\n      time,\n      includeSeconds,\n      isOpen\n    } = this.props;\n    let {\n      minTime,\n      maxTime\n    } = this.props;\n\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isTimeOptionsOpen: isOpen,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      timeState,\n      isTimeOptionsOpen,\n      isInvalid,\n      timeRegex\n    } = this.state;\n    const {\n      time,\n      is24Hour,\n      delimiter,\n      includeSeconds,\n      isOpen\n    } = this.props;\n\n    if (prevProps.isOpen !== isOpen) {\n      this.onToggle(isOpen);\n    }\n\n    if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n\n    if (time !== '' && time !== prevProps.time) {\n      this.setState({\n        timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      'aria-label': ariaLabel,\n      isDisabled,\n      className,\n      placeholder,\n      id,\n      menuAppendTo,\n      is24Hour,\n      invalidFormatErrorMessage,\n      invalidMinMaxErrorMessage,\n      stepMinutes,\n      width,\n      delimiter,\n      inputProps,\n\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      onChange,\n\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      setIsOpen,\n\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      isOpen,\n      time,\n      validateTime,\n      minTime,\n      maxTime,\n      includeSeconds\n    } = _a,\n\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    props = __rest(_a, ['aria-label', \"isDisabled\", \"className\", \"placeholder\", \"id\", \"menuAppendTo\", \"is24Hour\", \"invalidFormatErrorMessage\", \"invalidMinMaxErrorMessage\", \"stepMinutes\", \"width\", \"delimiter\", \"inputProps\", \"onChange\", \"setIsOpen\", \"isOpen\", \"time\", \"validateTime\", \"minTime\", \"maxTime\", \"includeSeconds\"]);\n\n    const {\n      timeState,\n      isTimeOptionsOpen,\n      isInvalid,\n      minTimeState,\n      maxTimeState\n    } = this.state;\n    const style = {\n      '--pf-c-date-picker__input--c-form-control--Width': width\n    };\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n\n      return null;\n    };\n\n    const menuContainer = React.createElement(Menu, {\n      ref: this.menuRef,\n      isScrollable: true\n    }, React.createElement(MenuContent, {\n      maxMenuHeight: \"200px\"\n    }, React.createElement(MenuList, {\n      \"aria-label\": ariaLabel\n    }, options.map((option, index) => React.createElement(MenuItem, {\n      onClick: this.onSelect,\n      key: option,\n      id: `${randomId}-option-${index}`\n    }, option)))));\n    const textInput = React.createElement(TextInput, Object.assign({\n      \"aria-haspopup\": \"menu\",\n      className: css(formStyles.formControl),\n      id: `${randomId}-input`,\n      \"aria-label\": ariaLabel,\n      validated: isInvalid ? 'error' : 'default',\n      placeholder: placeholder,\n      value: timeState || '',\n      type: \"text\",\n      iconVariant: \"clock\",\n      onClick: this.onInputClick,\n      onChange: this.onInputChange,\n      onBlur: this.onBlur,\n      autoComplete: \"off\",\n      isDisabled: isDisabled,\n      ref: this.inputRef\n    }, inputProps));\n    return React.createElement(\"div\", {\n      ref: this.baseComponentRef,\n      className: css(datePickerStyles.datePicker, className)\n    }, React.createElement(\"div\", Object.assign({\n      className: css(datePickerStyles.datePickerInput),\n      style: style\n    }, props), React.createElement(InputGroup, null, React.createElement(\"div\", {\n      id: randomId\n    }, React.createElement(\"div\", {\n      ref: this.toggleRef,\n      style: {\n        paddingLeft: '0'\n      }\n    }, menuAppendTo !== 'inline' ? React.createElement(Popper, {\n      appendTo: menuAppendTo === 'parent' ? getParentElement() : menuAppendTo,\n      trigger: textInput,\n      popper: menuContainer,\n      isVisible: isTimeOptionsOpen\n    }) : textInput), isTimeOptionsOpen && menuAppendTo === 'inline' && menuContainer)), isInvalid && React.createElement(\"div\", {\n      className: css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)\n    }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)));\n  }\n\n}\nTimePicker.displayName = 'TimePicker';\nTimePicker.defaultProps = {\n  className: '',\n  isDisabled: false,\n  time: '',\n  is24Hour: false,\n  invalidFormatErrorMessage: 'Invalid time format',\n  invalidMinMaxErrorMessage: 'Invalid time entered',\n  placeholder: 'hh:mm',\n  delimiter: ':',\n  'aria-label': 'Time picker',\n  width: '150px',\n  menuAppendTo: 'inline',\n  stepMinutes: 30,\n  inputProps: {},\n  minTime: '',\n  maxTime: '',\n  setIsOpen: () => {}\n};","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,GAAT,QAAoB,0BAApB;AACA,OAAOC,gBAAP,MAA6B,gEAA7B;AACA,OAAOC,UAAP,MAAuB,kEAAvB;AACA,OAAOC,UAAP,MAAuB,mDAAvB;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAASC,MAAT,QAAuB,6BAAvB;AACA,SAASC,IAAT,EAAeC,WAAf,EAA4BC,QAA5B,EAAsCC,QAAtC,QAAsD,SAAtD;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,SAASC,SAAT,QAA0C,cAA1C;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SACEC,SADF,EAEEC,YAFF,EAGEC,eAHF,EAIEC,QAJF,EAKEC,QALF,EAMEC,QANF,EAOEC,UAPF,EAQEC,cARF,EASEC,UATF,QAUO,mBAVP;AA2EA,OAAM,MAAOC,UAAP,SAA0BvB,KAAK,CAACwB,SAAhC,CAA2E;EA0B/EC,YAAYC,KAAZ,EAAkC;IAAA;;IAChC,MAAMA,KAAN,CADgC;IAAA;IAxB1B,wBAAmB1B,KAAK,CAAC2B,SAAN,EAAnB;IACA,iBAAY3B,KAAK,CAAC2B,SAAN,EAAZ;IACA,gBAAW3B,KAAK,CAAC2B,SAAN,EAAX;IACA,eAAU3B,KAAK,CAAC2B,SAAN,EAAV;;IA0DR,kBAAcC,KAAD,IAAmC;;;MAC9C,MAAMC,eAAe,GAAG,iBAAKC,SAAL,MAAc,IAAd,IAAcC,aAAd,GAAc,MAAd,GAAcA,GAAEC,OAAhB,MAAuB,IAAvB,IAAuBC,aAAvB,GAAuB,MAAvB,GAAuBA,GAAEC,QAAF,CAAWN,KAAK,CAACO,MAAjB,CAA/C;MACA,MAAMC,iBAAiB,GAAG,iBAAKC,OAAL,MAAY,IAAZ,IAAYC,aAAZ,GAAY,MAAZ,GAAYA,GAAEN,OAAd,MAAqB,IAArB,IAAqBO,aAArB,GAAqB,MAArB,GAAqBA,GAAEL,QAAF,CAAWN,KAAK,CAACO,MAAjB,CAA/C;;MACA,IAAI,KAAKK,KAAL,CAAWC,iBAAX,IAAgC,EAAEZ,eAAe,IAAIO,iBAArB,CAApC,EAA6E;QAC3E,KAAKM,QAAL,CAAc,KAAd;MACD;IACF,CAND;;IAQA,wBAAoBd,KAAD,IAAyB;;;MAC1C,MAAM;QAAEa,iBAAF;QAAqBE,YAArB;QAAmCC;MAAnC,IAAmD,KAAKJ,KAA9D,CAD0C,CAE1C;;MACA,IAAI,iBAAKK,QAAL,MAAa,IAAb,IAAad,aAAb,GAAa,MAAb,GAAaA,GAAEC,OAAf,MAAsB,IAAtB,IAAsBC,aAAtB,GAAsB,MAAtB,GAAsBA,GAAEC,QAAF,CAAWN,KAAK,CAACO,MAAjB,CAA1B,EAA4D;QAC1D,IAAI,CAACM,iBAAD,IAAsBb,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACkC,GAA7C,IAAoDnB,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACmC,MAA/E,EAAuF;UACrF,KAAKN,QAAL,CAAc,IAAd;QACD,CAFD,MAEO,IAAID,iBAAJ,EAAuB;UAC5B,IAAIb,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACmC,MAAvB,IAAiCpB,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACkC,GAA5D,EAAiE;YAC/D,KAAKL,QAAL,CAAc,KAAd;UACD,CAFD,MAEO,IAAId,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACoC,KAA3B,EAAkC;YACvC,IAAIN,YAAY,KAAK,IAArB,EAA2B;cACzB,KAAKO,cAAL,CAAoBP,YAApB;cACAf,KAAK,CAACuB,eAAN;YACD,CAHD,MAGO;cACL,KAAKT,QAAL,CAAc,KAAd;YACD;UACF,CAPM,MAOA,IAAId,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACuC,SAAvB,IAAoCxB,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACwC,OAA/D,EAAwE;YAC7E,KAAKH,cAAL,CAAoBN,WAApB;YACA,KAAKU,kBAAL,CAAwB,CAAxB;YACA1B,KAAK,CAAC2B,cAAN;UACD;QACF,CAlByD,CAmB1D;;MACD,CApBD,MAoBO,IAAI,iBAAKlB,OAAL,MAAY,IAAZ,IAAYC,aAAZ,GAAY,MAAZ,GAAYA,GAAEN,OAAd,MAAqB,IAArB,IAAqBO,aAArB,GAAqB,MAArB,GAAqBA,GAAEL,QAAF,CAAWN,KAAK,CAACO,MAAjB,CAAzB,EAA2D;QAChE,IAAIP,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACuC,SAA3B,EAAsC;UACpC,KAAKE,kBAAL,CAAwB,CAAxB;UACA1B,KAAK,CAAC2B,cAAN;QACD,CAHD,MAGO,IAAI3B,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACwC,OAA3B,EAAoC;UACzC,KAAKC,kBAAL,CAAwB,CAAC,CAAzB;UACA1B,KAAK,CAAC2B,cAAN;QACD,CAHM,MAGA,IAAI3B,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACmC,MAAvB,IAAiCpB,KAAK,CAACkB,GAAN,KAAcjC,QAAQ,CAACkC,GAA5D,EAAiE;UACtE,KAAKF,QAAL,CAAcb,OAAd,CAAsBwB,KAAtB;UACA,KAAKd,QAAL,CAAc,KAAd;QACD;MACF;IACF,CAnCD;;IA2DA,0BAAsBe,SAAD,IAAsB;MACzC,KAAKC,QAAL,CAAcC,SAAS,IAAG;QACxB,MAAMC,QAAQ,GAAG,KAAKC,UAAL,GAAkBC,MAAlB,GAA2B,CAA5C;QACA,IAAIC,SAAS,GACXJ,SAAS,CAAChB,YAAV,KAA2B,IAA3B,GAAkCgB,SAAS,CAAChB,YAAV,GAAyBc,SAA3D,GAAuEE,SAAS,CAACf,WAAV,GAAwBa,SADjG;;QAEA,IAAIM,SAAS,GAAG,CAAhB,EAAmB;UACjBA,SAAS,GAAGH,QAAZ;QACD,CAFD,MAEO,IAAIG,SAAS,GAAGH,QAAhB,EAA0B;UAC/BG,SAAS,GAAG,CAAZ;QACD;;QACD,KAAKC,aAAL,CAAmBD,SAAnB;QACA,OAAO;UACLpB,YAAY,EAAEoB;QADT,CAAP;MAGD,CAbD;IAcD,CAfD,CAxGkC,CAyHlC;;;IACA,wBAAoBE,KAAD,IAAkB;MACnC,IAAI,KAAKvC,KAAL,CAAWwC,YAAX,KAA4B,QAAhC,EAA0C;QACxC,OAAOD,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAA/B;MACD;;MACD,OAAOA,KAAP;IACD,CALD;;IAOA,qBAAiBA,KAAD,IAAkB;MAChC,KAAKJ,UAAL,GAAkBI,KAAlB,EAAyBE,OAAzB,CAAiC,IAAI/D,UAAU,CAACgE,WAAW,EAA3D,EAA+DC,SAA/D,GAA2E,KAAKR,UAAL,GACzE,KAAKS,gBAAL,CAAsBL,KAAtB,CADyE,EAEzEM,SAFF;IAGD,CAJD;;IAMA,sBAAkBN,KAAD,IAAkB;;;MACjC,MAAMO,YAAY,GAAGP,KAAK,KAAK,CAAC,CAAX,GAAeA,KAAf,GAAuB,CAA5C;;MAEA,IAAI,WAAK5B,OAAL,MAAY,IAAZ,IAAYN,aAAZ,GAAY,MAAZ,GAAYA,GAAEC,OAAlB,EAA2B;QACxB,KAAK6B,UAAL,GAAkBW,YAAlB,EAAgCC,aAAhC,CAA8C,IAAIrE,UAAU,CAACsE,QAAQ,EAArE,EAAyFlB,KAAzF;MACF;IACF,CAND;;IAQA,yBAAqBmB,IAAD,IAAiB;MACnC,MAAM;QAAEC,SAAF;QAAaC;MAAb,IAA0B,KAAKnD,KAArC;MACA,IAAIoD,SAAS,GAAGH,IAAI,CAACI,KAAL,CAAW,KAAKrD,KAAL,CAAWkD,SAAtB,CAAhB;MACA,IAAIjC,YAAY,GAAG,IAAnB,CAHmC,CAKnC;;MACA,IAAImC,SAAS,CAAChB,MAAV,GAAmB,CAAvB,EAA0B;QACxBa,IAAI,GAAG,GAAGA,IAAI,GAAGC,SAAS,IAA1B;QACAE,SAAS,GAAGH,IAAI,CAACI,KAAL,CAAWH,SAAX,CAAZ,CAFwB,CAGxB;MACD,CAJD,MAIO,IAAIE,SAAS,CAAChB,MAAV,GAAmB,CAAvB,EAA0B;QAC/Ba,IAAI,GAAG7D,SAAS,CAAC6D,IAAD,EAAO,KAAKnC,KAAL,CAAWwC,SAAlB,EAA6BJ,SAA7B,EAAwC,CAACC,QAAzC,EAAmD,KAAnD,CAAhB;QACAC,SAAS,GAAGH,IAAI,CAACI,KAAL,CAAWH,SAAX,CAAZ;MACD,CAbkC,CAenC;;;MACA,IAAI,CAACC,QAAD,IAAaC,SAAS,CAAChB,MAAV,GAAmB,CAAhC,IAAqCgB,SAAS,CAAC,CAAD,CAAT,CAAahB,MAAb,GAAsB,CAA/D,EAAkE;QAChE,MAAMmB,OAAO,GAAGH,SAAS,CAAC,CAAD,CAAT,CAAahB,MAAb,KAAwB,CAAxB,GAA4B,IAA5B,GAAmCgB,SAAS,CAAC,CAAD,CAAT,GAAe,GAAlE;QACAH,IAAI,GAAG,GAAGG,SAAS,CAAC,CAAD,CAAG,GAAGF,SAAS,GAAGK,OAAO,GAAG,IAAIC,IAAJ,GAAW/D,QAAX,KAAwB,EAAxB,GAA6BD,QAA7B,GAAwCD,QAAQ,EAA/F;MACD,CAHD,MAGO,IACL,CAAC4D,QAAD,IACAC,SAAS,CAAChB,MAAV,GAAmB,CADnB,IAEAgB,SAAS,CAAC,CAAD,CAAT,CAAahB,MAAb,KAAwB,CAFxB,IAGA,CAACa,IAAI,CAACQ,WAAL,GAAmBC,QAAnB,CAA4BnE,QAAQ,CAACkE,WAAT,GAAuBE,IAAvB,EAA5B,CAHD,IAIA,CAACV,IAAI,CAACQ,WAAL,GAAmBC,QAAnB,CAA4BlE,QAAQ,CAACiE,WAAT,GAAuBE,IAAvB,EAA5B,CALI,EAML;QACAV,IAAI,GAAG,GAAGA,IAAI,GAAG,IAAIO,IAAJ,GAAW/D,QAAX,KAAwB,EAAxB,GAA6BD,QAA7B,GAAwCD,QAAQ,EAAjE;MACD;;MACD,IAAI2B,WAAW,GAAG,KAAKiB,UAAL,GAAkByB,SAAlB,CAA4BC,MAAM,IAAIA,MAAM,CAACC,SAAP,KAAqBb,IAA3D,CAAlB,CA5BmC,CA8BnC;;MACA,IAAI/B,WAAW,KAAK,CAAC,CAArB,EAAwB;QACtB,KAAKoB,aAAL,CAAmBpB,WAAnB;QACAD,YAAY,GAAGC,WAAf;MACD,CAHD,MAGO,IAAIkC,SAAS,CAAChB,MAAV,KAAqB,CAAzB,EAA4B;QACjC;QACA,IAAI2B,IAAI,GAAG,EAAX;;QACA,IAAI,CAACZ,QAAL,EAAe;UACb,IAAIC,SAAS,CAAC,CAAD,CAAT,CAAaK,WAAb,GAA2BC,QAA3B,CAAoC,GAApC,CAAJ,EAA8C;YAC5CK,IAAI,GAAGvE,QAAP;UACD,CAFD,MAEO,IAAI4D,SAAS,CAAC,CAAD,CAAT,CAAaK,WAAb,GAA2BC,QAA3B,CAAoC,GAApC,CAAJ,EAA8C;YACnDK,IAAI,GAAGxE,QAAP;UACD;QACF;;QACD0D,IAAI,GAAG,GAAGG,SAAS,CAAC,CAAD,CAAG,GAAGF,SAAS,KAAKa,IAAI,EAA3C;QACA7C,WAAW,GAAG,KAAKiB,UAAL,GAAkByB,SAAlB,CAA4BC,MAAM,IAAIA,MAAM,CAACC,SAAP,KAAqBb,IAA3D,CAAd;;QACA,IAAI/B,WAAW,KAAK,CAAC,CAArB,EAAwB;UACtB,KAAKoB,aAAL,CAAmBpB,WAAnB;QACD;MACF;;MACD,KAAKc,QAAL,CAAc;QACZf,YADY;QAEZC;MAFY,CAAd;IAID,CAtDD;;IAwDA,iBAAY,YAAmC;MAAA,IAAlC8C,cAAkC,uEAAR,IAAQ;MAC7C,MAAM;QAAEb,QAAF;QAAYD;MAAZ,IAA0B,KAAI,CAAClD,KAArC;MACA,IAAIiE,SAAS,GAAG,gBAAgBf,SAAS,YAAzC;;MAEA,IAAIc,cAAJ,EAAoB;QAClBC,SAAS,IAAI,GAAGf,SAAS,cAAzB;MACD;;MAED,OAAO,IAAIgB,MAAJ,CAAW,IAAID,SAAS,GAAGd,QAAQ,GAAG,EAAH,GAAQ,mBAAmB,OAA9D,CAAP;IACD,CATD;;IAWA,kBAAa,MAAK;;;MAChB,OAAC,YAAKxC,OAAL,MAAY,IAAZ,IAAYN,aAAZ,GAAY,MAAZ,GAAYA,GAAEC,OAAd,IACG6D,KAAK,CAACC,IAAN,CAAW,KAAKzD,OAAL,CAAaL,OAAb,CAAqB+D,gBAArB,CAAsC,IAAI3F,UAAU,CAAC4F,YAAY,EAAjE,CAAX,CADH,GAEG,EAFJ;IAEwB,CAH1B;;IAKA,qBAAiBrB,IAAD,IAAiB;MAC/B,IAAI,KAAKjD,KAAL,CAAWX,YAAf,EAA6B;QAC3B,OAAO,KAAKW,KAAL,CAAWX,YAAX,CAAwB4D,IAAxB,CAAP;MACD;;MAED,MAAM;QAAEC,SAAF;QAAaC,QAAb;QAAuBa;MAAvB,IAA0C,KAAKhE,KAArD;MACA,OAAOX,YAAY,CAAC4D,IAAD,EAAO,KAAKsB,SAAL,CAAeP,cAAf,CAAP,EAAuCd,SAAvC,EAAkD,CAACC,QAAnD,CAAnB;IACD,CAPD;;IASA,mBAAeF,IAAD,IAAiB;MAC7B,MAAM;QAAEC,SAAF;QAAac;MAAb,IAAgC,KAAKhE,KAA3C;MACA,MAAM;QAAEwE,YAAF;QAAgBC;MAAhB,IAAiC,KAAK3D,KAA5C;MAEA,OAAOnB,cAAc,CAAC6E,YAAD,EAAeC,YAAf,EAA6BxB,IAA7B,EAAmCC,SAAnC,EAA8Cc,cAA9C,CAArB;IACD,CALD;;IAOA,eAAWf,IAAD,IAAkB,KAAKyB,aAAL,CAAmBzB,IAAnB,KAA4B,KAAK0B,WAAL,CAAiB1B,IAAjB,CAAxD;;IAEA,gBAAY2B,MAAD,IAAoB;MAC7B;MACA,KAAK5C,QAAL,CAAcC,SAAS,IAAG;QACxB,MAAM;UAAEqB,SAAF;UAAauB;QAAb,IAA2B5C,SAAjC;QACA,MAAM;UAAEiB,SAAF;UAAaC,QAAb;UAAuBa;QAAvB,IAA0C,KAAKhE,KAArD;QACA,MAAMiD,IAAI,GAAG7D,SAAS,CAAC6C,SAAS,CAAC6C,SAAX,EAAsBxB,SAAtB,EAAiCJ,SAAjC,EAA4C,CAACC,QAA7C,EAAuDa,cAAvD,CAAtB;QACA,OAAO;UACLjD,iBAAiB,EAAE6D,MADd;UAELE,SAAS,EAAE7B,IAFN;UAGL4B,SAAS,EAAED,MAAM,GAAGC,SAAH,GAAe,CAAC,KAAKE,OAAL,CAAa9B,IAAb;QAH5B,CAAP;MAKD,CATD;MAUA,KAAKjD,KAAL,CAAWgF,SAAX,CAAqBJ,MAArB;;MACA,IAAI,CAACA,MAAL,EAAa;QACX,KAAKzD,QAAL,CAAcb,OAAd,CAAsBwB,KAAtB;MACD;IACF,CAhBD;;IAkBA,gBAAYmD,CAAD,IAAW;MACpB,MAAM;QAAE3B,SAAF;QAAawB;MAAb,IAA2B,KAAKhE,KAAtC;MACA,MAAM;QAAEoC,SAAF;QAAaC,QAAb;QAAuBa,cAAvB;QAAuCgB;MAAvC,IAAqD,KAAKhF,KAAhE;MACA,MAAMiD,IAAI,GAAG7D,SAAS,CAAC6F,CAAC,CAACxE,MAAF,CAASyE,WAAV,EAAuB5B,SAAvB,EAAkCJ,SAAlC,EAA6C,CAACC,QAA9C,EAAwDa,cAAxD,CAAtB;;MACA,IAAIf,IAAI,KAAK6B,SAAb,EAAwB;QACtB,KAAKK,aAAL,CAAmBlC,IAAnB;MACD;;MAED,KAAK9B,QAAL,CAAcb,OAAd,CAAsBwB,KAAtB;MACA,KAAKE,QAAL,CAAc;QACZjB,iBAAiB,EAAE,KADP;QAEZ8D,SAAS,EAAE;MAFC,CAAd;MAIAG,SAAS,CAAC,KAAD,CAAT;IACD,CAdD;;IAgBA,oBAAgBC,CAAD,IAAW;MACxB,IAAI,CAAC,KAAKnE,KAAL,CAAWC,iBAAhB,EAAmC;QACjC,KAAKC,QAAL,CAAc,IAAd;MACD;;MACDiE,CAAC,CAACxD,eAAF;IACD,CALD;;IAOA,qBAAiB2D,OAAD,IAAoB;MAClC,MAAM;QAAEC;MAAF,IAAe,KAAKrF,KAA1B;MACA,MAAM;QAAEsD;MAAF,IAAgB,KAAKxC,KAA3B;;MAEA,IAAIuE,QAAJ,EAAc;QACZA,QAAQ,CACND,OADM,EAEN3F,QAAQ,CAAC2F,OAAD,EAAU9B,SAAV,CAFF,EAGN5D,UAAU,CAAC0F,OAAD,EAAU9B,SAAV,CAHJ,EAIN1D,UAAU,CAACwF,OAAD,EAAU9B,SAAV,CAJJ,EAKN,KAAKyB,OAAL,CAAaK,OAAb,CALM,CAAR;MAOD;;MACD,KAAKE,iBAAL,CAAuBF,OAAvB;MACA,KAAKpD,QAAL,CAAc;QACZ8C,SAAS,EAAEM;MADC,CAAd;IAGD,CAjBD;;IAmBA,cAAUlF,KAAD,IAA8C;MACrD,MAAM;QAAEoD;MAAF,IAAgB,KAAKxC,KAA3B;MACA,MAAM;QAAEoC,SAAF;QAAaC,QAAb;QAAuBa;MAAvB,IAA0C,KAAKhE,KAArD;MACA,MAAMiD,IAAI,GAAG7D,SAAS,CAACc,KAAK,CAACqF,aAAN,CAAoBC,KAArB,EAA4BlC,SAA5B,EAAuCJ,SAAvC,EAAkD,CAACC,QAAnD,EAA6Da,cAA7D,CAAtB;MAEA,KAAKhC,QAAL,CAAc;QACZ6C,SAAS,EAAE,CAAC,KAAKE,OAAL,CAAa9B,IAAb;MADA,CAAd;IAGD,CARD;;IAnSE,MAAM;MAAEE,QAAF;MAAYD,SAAZ;MAAuBD,IAAvB;MAA6Be,cAA7B;MAA6CY;IAA7C,IAAwD,KAAK5E,KAAnE;IACA,IAAI;MAAEyF,OAAF;MAAWC;IAAX,IAAuB,KAAK1F,KAAhC;;IACA,IAAIyF,OAAO,KAAK,EAAhB,EAAoB;MAClB,MAAME,UAAU,GAAG3B,cAAc,GAAG,GAAGd,SAAS,IAAf,GAAsB,EAAvD;MACAuC,OAAO,GAAGtC,QAAQ,GAAG,KAAKD,SAAS,KAAKyC,UAAU,EAAhC,GAAqC,KAAKzC,SAAS,KAAKyC,UAAU,KAApF;IACD;;IACD,IAAID,OAAO,KAAK,EAAhB,EAAoB;MAClB,MAAME,UAAU,GAAG5B,cAAc,GAAG,GAAGd,SAAS,IAAf,GAAsB,EAAvD;MACAwC,OAAO,GAAGvC,QAAQ,GAAG,KAAKD,SAAS,KAAK0C,UAAU,EAAhC,GAAqC,KAAK1C,SAAS,KAAK0C,UAAU,KAApF;IACD;;IACD,MAAMtC,SAAS,GAAG,KAAKiB,SAAL,EAAlB;IACA,KAAKzD,KAAL,GAAa;MACX+D,SAAS,EAAE,KADA;MAEX9D,iBAAiB,EAAE6D,MAFR;MAGXE,SAAS,EAAE1F,SAAS,CAAC6D,IAAD,EAAOK,SAAP,EAAkBJ,SAAlB,EAA6B,CAACC,QAA9B,EAAwCa,cAAxC,CAHT;MAIX/C,YAAY,EAAE,IAJH;MAKXC,WAAW,EAAE,CALF;MAMXoC,SANW;MAOXkB,YAAY,EAAEpF,SAAS,CAACqG,OAAD,EAAUnC,SAAV,EAAqBJ,SAArB,EAAgC,CAACC,QAAjC,EAA2Ca,cAA3C,CAPZ;MAQXS,YAAY,EAAErF,SAAS,CAACsG,OAAD,EAAUpC,SAAV,EAAqBJ,SAArB,EAAgC,CAACC,QAAjC,EAA2Ca,cAA3C;IARZ,CAAb;EAUD;;EAED6B,iBAAiB;IACfC,QAAQ,CAACC,gBAAT,CAA0B,WAA1B,EAAuC,KAAKC,UAA5C;IACAF,QAAQ,CAACC,gBAAT,CAA0B,YAA1B,EAAwC,KAAKC,UAA7C;IACAF,QAAQ,CAACC,gBAAT,CAA0B,SAA1B,EAAqC,KAAKE,gBAA1C;EACD;;EAEDC,oBAAoB;IAClBJ,QAAQ,CAACK,mBAAT,CAA6B,WAA7B,EAA0C,KAAKH,UAA/C;IACAF,QAAQ,CAACK,mBAAT,CAA6B,YAA7B,EAA2C,KAAKH,UAAhD;IACAF,QAAQ,CAACK,mBAAT,CAA6B,SAA7B,EAAwC,KAAKF,gBAA7C;EACD;;EA+CDG,kBAAkB,CAACC,SAAD,EAA6BpE,SAA7B,EAAuD;IACvE,MAAM;MAAE6C,SAAF;MAAa/D,iBAAb;MAAgC8D,SAAhC;MAA2CvB;IAA3C,IAAyD,KAAKxC,KAApE;IACA,MAAM;MAAEmC,IAAF;MAAQE,QAAR;MAAkBD,SAAlB;MAA6Bc,cAA7B;MAA6CY;IAA7C,IAAwD,KAAK5E,KAAnE;;IACA,IAAIqG,SAAS,CAACzB,MAAV,KAAqBA,MAAzB,EAAiC;MAC/B,KAAK5D,QAAL,CAAc4D,MAAd;IACD;;IAED,IAAI7D,iBAAiB,IAAI,CAACkB,SAAS,CAAClB,iBAAhC,IAAqD+D,SAArD,IAAkE,CAACD,SAAvE,EAAkF;MAChF,KAAKS,iBAAL,CAAuBR,SAAvB;IACD;;IACD,IAAI5B,SAAS,KAAKmD,SAAS,CAACnD,SAA5B,EAAuC;MACrC,KAAKlB,QAAL,CAAc;QACZsB,SAAS,EAAE,KAAKiB,SAAL;MADC,CAAd;IAGD;;IACD,IAAItB,IAAI,KAAK,EAAT,IAAeA,IAAI,KAAKoD,SAAS,CAACpD,IAAtC,EAA4C;MAC1C,KAAKjB,QAAL,CAAc;QACZ8C,SAAS,EAAE1F,SAAS,CAAC6D,IAAD,EAAOK,SAAP,EAAkBJ,SAAlB,EAA6B,CAACC,QAA9B,EAAwCa,cAAxC;MADR,CAAd;IAGD;EACF;;EAyMDsC,MAAM;IACJ,MAAMjG,KA2BF,KAAKL,KA3BT;IAAA,MAAM;MACJ,cAAcuG,SADV;MAEJC,UAFI;MAGJC,SAHI;MAIJC,WAJI;MAKJC,EALI;MAMJnE,YANI;MAOJW,QAPI;MAQJyD,yBARI;MASJC,yBATI;MAUJC,WAVI;MAWJC,KAXI;MAYJ7D,SAZI;MAaJ8D,UAbI;;MAcJ;MACA3B,QAfI;;MAgBJ;MACAL,SAjBI;;MAkBJ;MACAJ,MAnBI;MAoBJ3B,IApBI;MAqBJ5D,YArBI;MAsBJoG,OAtBI;MAuBJC,OAvBI;MAwBJ1B;IAxBI,IAwBU3D,EAxBhB;;IAyBE;IACGL,KAAK,cA1BJ,0SA0BI,CA1BV;;IA4BA,MAAM;MAAE8E,SAAF;MAAa/D,iBAAb;MAAgC8D,SAAhC;MAA2CL,YAA3C;MAAyDC;IAAzD,IAA0E,KAAK3D,KAArF;IACA,MAAMmG,KAAK,GAAG;MAAE,oDAAoDF;IAAtD,CAAd;IACA,MAAMG,OAAO,GAAG5H,eAAe,CAACwH,WAAD,EAAc,CAAC3D,QAAf,EAAyBD,SAAzB,EAAoCsB,YAApC,EAAkDC,YAAlD,EAAgET,cAAhE,CAA/B;IACA,MAAMU,aAAa,GAAG,KAAKA,aAAL,CAAmBI,SAAnB,CAAtB;IACA,MAAMqC,QAAQ,GAAGR,EAAE,IAAIhI,WAAW,CAAC,aAAD,CAAlC;;IAEA,MAAMyI,gBAAgB,GAAG,MAAK;MAC5B,IAAI,KAAKC,gBAAL,IAAyB,KAAKA,gBAAL,CAAsB/G,OAAnD,EAA4D;QAC1D,OAAO,KAAK+G,gBAAL,CAAsB/G,OAAtB,CAA8BgH,aAArC;MACD;;MACD,OAAO,IAAP;IACD,CALD;;IAOA,MAAMC,aAAa,GACjBjJ,oBAACO,IAAD,EAAK;MAAC2I,GAAG,EAAE,KAAK7G,OAAX;MAAoB8G,YAAY;IAAhC,CAAL,EACEnJ,oBAACQ,WAAD,EAAY;MAAC4I,aAAa,EAAC;IAAf,CAAZ,EACEpJ,oBAACS,QAAD,EAAS;MAAA,cAAawH;IAAb,CAAT,EACGW,OAAO,CAACS,GAAR,CAAY,CAAC9D,MAAD,EAAStB,KAAT,KACXjE,oBAACU,QAAD,EAAS;MAAC4I,OAAO,EAAE,KAAKC,QAAf;MAAyBzG,GAAG,EAAEyC,MAA9B;MAAsC8C,EAAE,EAAE,GAAGQ,QAAQ,WAAW5E,KAAK;IAArE,CAAT,EACGsB,MADH,CADD,CADH,CADF,CADF,CADF;IAcA,MAAMiE,SAAS,GACbxJ,oBAACY,SAAD,EAAU6I;MAAA,iBACM,MADN;MAERtB,SAAS,EAAElI,GAAG,CAACE,UAAU,CAACuJ,WAAZ,CAFN;MAGRrB,EAAE,EAAE,GAAGQ,QAAQ,QAHP;MAGe,cACXZ,SAJJ;MAKR0B,SAAS,EAAEpD,SAAS,GAAG,OAAH,GAAa,SALzB;MAMR6B,WAAW,EAAEA,WANL;MAORlB,KAAK,EAAEV,SAAS,IAAI,EAPZ;MAQRoD,IAAI,EAAC,MARG;MASRC,WAAW,EAAC,OATJ;MAURP,OAAO,EAAE,KAAKQ,YAVN;MAWR/C,QAAQ,EAAE,KAAKF,aAXP;MAYRkD,MAAM,EAAE,KAAKA,MAZL;MAaRC,YAAY,EAAC,KAbL;MAcR9B,UAAU,EAAEA,UAdJ;MAeRgB,GAAG,EAAE,KAAKrG;IAfF,GAgBJ6F,UAhBI,CAAV,CADF;IAqBA,OACE1I;MAAKkJ,GAAG,EAAE,KAAKH,gBAAf;MAAiCZ,SAAS,EAAElI,GAAG,CAACC,gBAAgB,CAAC+J,UAAlB,EAA8B9B,SAA9B;IAA/C,GACEnI;MAAKmI,SAAS,EAAElI,GAAG,CAACC,gBAAgB,CAACgK,eAAlB,CAAnB;MAAuDvB,KAAK,EAAEA;IAA9D,GAAyEjH,KAAzE,GACE1B,oBAACW,UAAD,EAAW,IAAX,EACEX;MAAKqI,EAAE,EAAEQ;IAAT,GACE7I;MAAKkJ,GAAG,EAAE,KAAKpH,SAAf;MAA0B6G,KAAK,EAAE;QAAEwB,WAAW,EAAE;MAAf;IAAjC,GACGjG,YAAY,KAAK,QAAjB,GACClE,oBAACM,MAAD,EAAO;MACL8J,QAAQ,EAAElG,YAAY,KAAK,QAAjB,GAA4B4E,gBAAgB,EAA5C,GAAiD5E,YADtD;MAELmG,OAAO,EAAEb,SAFJ;MAGLc,MAAM,EAAErB,aAHH;MAILsB,SAAS,EAAE9H;IAJN,CAAP,CADD,GAQC+G,SATJ,CADF,EAaG/G,iBAAiB,IAAIyB,YAAY,KAAK,QAAtC,IAAkD+E,aAbrD,CADF,CADF,EAkBG1C,SAAS,IACRvG;MAAKmI,SAAS,EAAElI,GAAG,CAACC,gBAAgB,CAACsK,oBAAlB,EAAwCtK,gBAAgB,CAACuK,SAAjB,CAA2BC,KAAnE;IAAnB,GACG,CAACtE,aAAD,GAAiBkC,yBAAjB,GAA6CC,yBADhD,CAnBJ,CADF,CADF;EA4BD;;AAlb8E;AACxEhH,yBAAc,YAAd;AAMAA,0BAAe;EACpB4G,SAAS,EAAE,EADS;EAEpBD,UAAU,EAAE,KAFQ;EAGpBvD,IAAI,EAAE,EAHc;EAIpBE,QAAQ,EAAE,KAJU;EAKpByD,yBAAyB,EAAE,qBALP;EAMpBC,yBAAyB,EAAE,sBANP;EAOpBH,WAAW,EAAE,OAPO;EAQpBxD,SAAS,EAAE,GARS;EASpB,cAAc,aATM;EAUpB6D,KAAK,EAAE,OAVa;EAWpBvE,YAAY,EAAE,QAXM;EAYpBsE,WAAW,EAAE,EAZO;EAapBE,UAAU,EAAE,EAbQ;EAcpBvB,OAAO,EAAE,EAdW;EAepBC,OAAO,EAAE,EAfW;EAgBpBV,SAAS,EAAE,MAAK,CAAG;AAhBC,CAAf","names":["React","css","datePickerStyles","formStyles","menuStyles","getUniqueId","Popper","Menu","MenuContent","MenuList","MenuItem","InputGroup","TextInput","KeyTypes","parseTime","validateTime","makeTimeOptions","amSuffix","pmSuffix","getHours","getMinutes","isWithinMinMax","getSeconds","TimePicker","Component","constructor","props","createRef","event","clickedOnToggle","toggleRef","_a","current","_b","contains","target","clickedWithinMenu","menuRef","_c","_d","state","isTimeOptionsOpen","onToggle","focusedIndex","scrollIndex","inputRef","key","Tab","Escape","Enter","focusSelection","stopPropagation","ArrowDown","ArrowUp","updateFocusedIndex","preventDefault","focus","increment","setState","prevState","maxIndex","getOptions","length","nextIndex","scrollToIndex","index","menuAppendTo","closest","menuContent","scrollTop","getIndexToScroll","offsetTop","indexToFocus","querySelector","menuItem","time","delimiter","is24Hour","splitTime","split","timeRegex","minutes","Date","toUpperCase","includes","trim","findIndex","option","innerText","amPm","includeSeconds","baseRegex","RegExp","Array","from","querySelectorAll","menuListItem","getRegExp","minTimeState","maxTimeState","isValidFormat","isValidTime","isOpen","isInvalid","timeState","isValid","setIsOpen","e","textContent","onInputChange","newTime","onChange","scrollToSelection","currentTarget","value","minTime","maxTime","minSeconds","maxSeconds","componentDidMount","document","addEventListener","onDocClick","handleGlobalKeys","componentWillUnmount","removeEventListener","componentDidUpdate","prevProps","render","ariaLabel","isDisabled","className","placeholder","id","invalidFormatErrorMessage","invalidMinMaxErrorMessage","stepMinutes","width","inputProps","style","options","randomId","getParentElement","baseComponentRef","parentElement","menuContainer","ref","isScrollable","maxMenuHeight","map","onClick","onSelect","textInput","Object","formControl","validated","type","iconVariant","onInputClick","onBlur","autoComplete","datePicker","datePickerInput","paddingLeft","appendTo","trigger","popper","isVisible","datePickerHelperText","modifiers","error"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/components/TimePicker/TimePicker.tsx"],"sourcesContent":["import * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput, TextInputProps } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport {\n  parseTime,\n  validateTime,\n  makeTimeOptions,\n  amSuffix,\n  pmSuffix,\n  getHours,\n  getMinutes,\n  isWithinMinMax,\n  getSeconds\n} from './TimePickerUtils';\n\nexport interface TimePickerProps\n  extends Omit<React.HTMLProps<HTMLDivElement>, 'onChange' | 'onFocus' | 'onBlur' | 'disabled' | 'ref'> {\n  /** Additional classes added to the time picker. */\n  className?: string;\n  /** Accessible label for the time picker */\n  'aria-label'?: string;\n  /** Flag indicating the time picker is disabled */\n  isDisabled?: boolean;\n  /** String to display in the empty time picker field as a hint for the expected time format */\n  placeholder?: string;\n  /** Character to display between the hour and minute */\n  delimiter?: string;\n  /** A time string. The format could be  an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  time?: string | Date;\n  /** Error message to display when the time is provided in an invalid format. */\n  invalidFormatErrorMessage?: string;\n  /** Error message to display when the time provided is not within the minTime/maxTime constriants */\n  invalidMinMaxErrorMessage?: string;\n  /** True if the time is 24 hour time. False if the time is 12 hour time */\n  is24Hour?: boolean;\n  /** Optional event handler called each time the value in the time picker input changes. */\n  onChange?: (time: string, hour?: number, minute?: number, seconds?: number, isValid?: boolean) => void;\n  /** Optional validator can be provided to override the internal time validator. */\n  validateTime?: (time: string) => boolean;\n  /** Id of the time picker */\n  id?: string;\n  /** Width of the time picker. */\n  width?: string;\n  /** The container to append the menu to. Defaults to 'inline'.\n   * If your menu is being cut off you can append it to an element higher up the DOM tree.\n   * Some examples:\n   * menuAppendTo=\"parent\"\n   * menuAppendTo={() => document.body}\n   * menuAppendTo={document.getElementById('target')}\n   */\n  menuAppendTo?: HTMLElement | (() => HTMLElement) | 'inline' | 'parent';\n  /** Size of step between time options in minutes.*/\n  stepMinutes?: number;\n  /** Additional props for input field */\n  inputProps?: TextInputProps;\n  /** A time string indicating the minimum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  minTime?: string | Date;\n  /** A time string indicating the maximum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  maxTime?: string | Date;\n  /** Includes number of seconds with the chosen time and allows users to manually edit the seconds value. */\n  includeSeconds?: boolean;\n  /** Flag to control the opened state of the time picker menu */\n  isOpen?: boolean;\n  /** Handler invoked each time the open state of time picker updates */\n  setIsOpen?: (isOpen?: boolean) => void;\n}\n\ninterface TimePickerState {\n  isInvalid: boolean;\n  isTimeOptionsOpen: boolean;\n  timeState: string;\n  focusedIndex: number;\n  scrollIndex: number;\n  timeRegex: RegExp;\n  minTimeState: string;\n  maxTimeState: string;\n}\n\nexport class TimePicker extends React.Component<TimePickerProps, TimePickerState> {\n  static displayName = 'TimePicker';\n  private baseComponentRef = React.createRef<any>();\n  private toggleRef = React.createRef<HTMLDivElement>();\n  private inputRef = React.createRef<HTMLInputElement>();\n  private menuRef = React.createRef<HTMLDivElement>();\n\n  static defaultProps = {\n    className: '',\n    isDisabled: false,\n    time: '',\n    is24Hour: false,\n    invalidFormatErrorMessage: 'Invalid time format',\n    invalidMinMaxErrorMessage: 'Invalid time entered',\n    placeholder: 'hh:mm',\n    delimiter: ':',\n    'aria-label': 'Time picker',\n    width: '150px',\n    menuAppendTo: 'inline',\n    stepMinutes: 30,\n    inputProps: {},\n    minTime: '',\n    maxTime: '',\n    setIsOpen: () => {}\n  };\n\n  constructor(props: TimePickerProps) {\n    super(props);\n    const { is24Hour, delimiter, time, includeSeconds, isOpen } = this.props;\n    let { minTime, maxTime } = this.props;\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isTimeOptionsOpen: isOpen,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  onDocClick = (event: MouseEvent | TouchEvent) => {\n    const clickedOnToggle = this.toggleRef?.current?.contains(event.target as Node);\n    const clickedWithinMenu = this.menuRef?.current?.contains(event.target as Node);\n    if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n      this.onToggle(false);\n    }\n  };\n\n  handleGlobalKeys = (event: KeyboardEvent) => {\n    const { isTimeOptionsOpen, focusedIndex, scrollIndex } = this.state;\n    // keyboard pressed while focus on toggle\n    if (this.inputRef?.current?.contains(event.target as Node)) {\n      if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n        this.onToggle(true);\n      } else if (isTimeOptionsOpen) {\n        if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.onToggle(false);\n        } else if (event.key === KeyTypes.Enter) {\n          if (focusedIndex !== null) {\n            this.focusSelection(focusedIndex);\n            event.stopPropagation();\n          } else {\n            this.onToggle(false);\n          }\n        } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n          this.focusSelection(scrollIndex);\n          this.updateFocusedIndex(0);\n          event.preventDefault();\n        }\n      }\n      // keyboard pressed while focus on menu item\n    } else if (this.menuRef?.current?.contains(event.target as Node)) {\n      if (event.key === KeyTypes.ArrowDown) {\n        this.updateFocusedIndex(1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.ArrowUp) {\n        this.updateFocusedIndex(-1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n        this.inputRef.current.focus();\n        this.onToggle(false);\n      }\n    }\n  };\n\n  componentDidUpdate(prevProps: TimePickerProps, prevState: TimePickerState) {\n    const { timeState, isTimeOptionsOpen, isInvalid, timeRegex } = this.state;\n    const { time, is24Hour, delimiter, includeSeconds, isOpen } = this.props;\n    if (prevProps.isOpen !== isOpen) {\n      this.onToggle(isOpen);\n    }\n\n    if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n    if (time !== '' && time !== prevProps.time) {\n      this.setState({\n        timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n\n  updateFocusedIndex = (increment: number) => {\n    this.setState(prevState => {\n      const maxIndex = this.getOptions().length - 1;\n      let nextIndex =\n        prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n      if (nextIndex < 0) {\n        nextIndex = maxIndex;\n      } else if (nextIndex > maxIndex) {\n        nextIndex = 0;\n      }\n      this.scrollToIndex(nextIndex);\n      return {\n        focusedIndex: nextIndex\n      };\n    });\n  };\n\n  // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n  getIndexToScroll = (index: number) => {\n    if (this.props.menuAppendTo === 'inline') {\n      return index > 0 ? index - 1 : 0;\n    }\n    return index;\n  };\n\n  scrollToIndex = (index: number) => {\n    this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[\n      this.getIndexToScroll(index)\n    ].offsetTop;\n  };\n\n  focusSelection = (index: number) => {\n    const indexToFocus = index !== -1 ? index : 0;\n\n    if (this.menuRef?.current) {\n      (this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`) as HTMLElement).focus();\n    }\n  };\n\n  scrollToSelection = (time: string) => {\n    const { delimiter, is24Hour } = this.props;\n    let splitTime = time.split(this.props.delimiter);\n    let focusedIndex = null;\n\n    // build out the rest of the time assuming hh:00 if it's a partial time\n    if (splitTime.length < 2) {\n      time = `${time}${delimiter}00`;\n      splitTime = time.split(delimiter);\n      // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n    } else if (splitTime.length > 2) {\n      time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n      splitTime = time.split(delimiter);\n    }\n\n    // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n    if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n      const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n      time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    } else if (\n      !is24Hour &&\n      splitTime.length > 1 &&\n      splitTime[1].length === 2 &&\n      !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) &&\n      !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())\n    ) {\n      time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    }\n    let scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n\n    // if we found an exact match, scroll to match and return index of match for focus\n    if (scrollIndex !== -1) {\n      this.scrollToIndex(scrollIndex);\n      focusedIndex = scrollIndex;\n    } else if (splitTime.length === 2) {\n      // no exact match, scroll to closest hour but don't return index for focus\n      let amPm = '';\n      if (!is24Hour) {\n        if (splitTime[1].toUpperCase().includes('P')) {\n          amPm = pmSuffix;\n        } else if (splitTime[1].toUpperCase().includes('A')) {\n          amPm = amSuffix;\n        }\n      }\n      time = `${splitTime[0]}${delimiter}00${amPm}`;\n      scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n      }\n    }\n    this.setState({\n      focusedIndex,\n      scrollIndex\n    });\n  };\n\n  getRegExp = (includeSeconds: boolean = true) => {\n    const { is24Hour, delimiter } = this.props;\n    let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n\n    if (includeSeconds) {\n      baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n    }\n\n    return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n  };\n\n  getOptions = () =>\n    (this.menuRef?.current\n      ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`))\n      : []) as HTMLElement[];\n\n  isValidFormat = (time: string) => {\n    if (this.props.validateTime) {\n      return this.props.validateTime(time);\n    }\n\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n  };\n\n  isValidTime = (time: string) => {\n    const { delimiter, includeSeconds } = this.props;\n    const { minTimeState, maxTimeState } = this.state;\n\n    return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n  };\n\n  isValid = (time: string) => this.isValidFormat(time) && this.isValidTime(time);\n\n  onToggle = (isOpen: boolean) => {\n    // on close, parse and validate input\n    this.setState(prevState => {\n      const { timeRegex, isInvalid } = prevState;\n      const { delimiter, is24Hour, includeSeconds } = this.props;\n      const time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n      return {\n        isTimeOptionsOpen: isOpen,\n        timeState: time,\n        isInvalid: isOpen ? isInvalid : !this.isValid(time)\n      };\n    });\n    this.props.setIsOpen(isOpen);\n    if (!isOpen) {\n      this.inputRef.current.focus();\n    }\n  };\n\n  onSelect = (e: any) => {\n    const { timeRegex, timeState } = this.state;\n    const { delimiter, is24Hour, includeSeconds, setIsOpen } = this.props;\n    const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n    if (time !== timeState) {\n      this.onInputChange(time);\n    }\n\n    this.inputRef.current.focus();\n    this.setState({\n      isTimeOptionsOpen: false,\n      isInvalid: false\n    });\n    setIsOpen(false);\n  };\n\n  onInputClick = (e: any) => {\n    if (!this.state.isTimeOptionsOpen) {\n      this.onToggle(true);\n    }\n    e.stopPropagation();\n  };\n\n  onInputChange = (newTime: string) => {\n    const { onChange } = this.props;\n    const { timeRegex } = this.state;\n\n    if (onChange) {\n      onChange(\n        newTime,\n        getHours(newTime, timeRegex),\n        getMinutes(newTime, timeRegex),\n        getSeconds(newTime, timeRegex),\n        this.isValid(newTime)\n      );\n    }\n    this.scrollToSelection(newTime);\n    this.setState({\n      timeState: newTime\n    });\n  };\n\n  onBlur = (event: React.FocusEvent<HTMLInputElement>) => {\n    const { timeRegex } = this.state;\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    const time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n    this.setState({\n      isInvalid: !this.isValid(time)\n    });\n  };\n\n  render() {\n    const {\n      'aria-label': ariaLabel,\n      isDisabled,\n      className,\n      placeholder,\n      id,\n      menuAppendTo,\n      is24Hour,\n      invalidFormatErrorMessage,\n      invalidMinMaxErrorMessage,\n      stepMinutes,\n      width,\n      delimiter,\n      inputProps,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      onChange,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      setIsOpen,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      isOpen,\n      time,\n      validateTime,\n      minTime,\n      maxTime,\n      includeSeconds,\n      /* eslint-enable @typescript-eslint/no-unused-vars */\n      ...props\n    } = this.props;\n    const { timeState, isTimeOptionsOpen, isInvalid, minTimeState, maxTimeState } = this.state;\n    const style = { '--pf-c-date-picker__input--c-form-control--Width': width } as React.CSSProperties;\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n      return null;\n    };\n\n    const menuContainer = (\n      <Menu ref={this.menuRef} isScrollable>\n        <MenuContent maxMenuHeight=\"200px\">\n          <MenuList aria-label={ariaLabel}>\n            {options.map((option, index) => (\n              <MenuItem onClick={this.onSelect} key={option} id={`${randomId}-option-${index}`}>\n                {option}\n              </MenuItem>\n            ))}\n          </MenuList>\n        </MenuContent>\n      </Menu>\n    );\n\n    const textInput = (\n      <TextInput\n        aria-haspopup=\"menu\"\n        className={css(formStyles.formControl)}\n        id={`${randomId}-input`}\n        aria-label={ariaLabel}\n        validated={isInvalid ? 'error' : 'default'}\n        placeholder={placeholder}\n        value={timeState || ''}\n        type=\"text\"\n        iconVariant=\"clock\"\n        onClick={this.onInputClick}\n        onChange={this.onInputChange}\n        onBlur={this.onBlur}\n        autoComplete=\"off\"\n        isDisabled={isDisabled}\n        ref={this.inputRef}\n        {...inputProps}\n      />\n    );\n\n    return (\n      <div ref={this.baseComponentRef} className={css(datePickerStyles.datePicker, className)}>\n        <div className={css(datePickerStyles.datePickerInput)} style={style} {...props}>\n          <InputGroup>\n            <div id={randomId}>\n              <div ref={this.toggleRef} style={{ paddingLeft: '0' }}>\n                {menuAppendTo !== 'inline' ? (\n                  <Popper\n                    appendTo={menuAppendTo === 'parent' ? getParentElement() : menuAppendTo}\n                    trigger={textInput}\n                    popper={menuContainer}\n                    isVisible={isTimeOptionsOpen}\n                  />\n                ) : (\n                  textInput\n                )}\n              </div>\n              {isTimeOptionsOpen && menuAppendTo === 'inline' && menuContainer}\n            </div>\n          </InputGroup>\n          {isInvalid && (\n            <div className={css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)}>\n              {!isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}