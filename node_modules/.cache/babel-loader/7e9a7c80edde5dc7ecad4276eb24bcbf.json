{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param preprocessor - function by which each added line is modified\n * @param delay - delay after which buffer sends new data\n */\nexport const useDataBuffer = function (delay) {\n  let preprocessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lines => lines;\n  const [data, setData] = useState([]);\n  const [buffer, setBuffer] = useState([]);\n  const [currentLineCount, setCurrentLineCount] = useState(0);\n  const savedTimer = useRef();\n  const inputCnts = useRef([]);\n  const currInput = useRef(0);\n  useEffect(() => {\n    savedTimer.current = setInterval(() => {\n      console.log(inputCnts.current);\n\n      if (inputCnts.current.length) {\n        setCurrentLineCount(currentLineCount => currentLineCount + inputCnts.current[0]); // currInput.current += 1;\n\n        inputCnts.current.shift();\n      }\n    }, delay);\n  }, [delay]); // useEffect(() => {\n  //   if (data.length > buffer.length) {\n  //     savedTimer.current = setTimeout(() => {\n  //       setCurrentLineCount((currentLineCount) => currentLineCount + 5);\n  //     }, 1500);\n  //   }\n  //   return () => {\n  //     clearTimeout(savedTimer.current);\n  //   };\n  // }, [data.length, buffer.length]);\n\n  useEffect(() => {\n    if (data.length > buffer.length) setBuffer(data.slice(0, currentLineCount)); // if (currentLineCount > initLogData.length) {\n    //   clearInterval(savedTimer.current);\n    // } else {\n    //   // setLogData(initLogData.slice(0, currentLineCount));\n    //   addLines(initLogData.slice(currentLineCount - 3, currentLineCount));\n    // }\n  }, [currentLineCount]); // useEffect(() => {\n  //   setTimeout(() => {\n  //     setBuffer(data);\n  //   }, 3000);\n  // }, [data]);\n\n  const addLines = useCallback(lines => {\n    setData([...data, ...preprocessor(lines)]);\n    inputCnts.current.push(lines.length);\n  }, [data, preprocessor]);\n  return {\n    buffer,\n    addLines\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useDataBuffer","delay","preprocessor","lines","data","setData","buffer","setBuffer","currentLineCount","setCurrentLineCount","savedTimer","inputCnts","currInput","current","setInterval","console","log","length","shift","slice","addLines","push"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/src/containers/useDataBuffer.ts"],"sourcesContent":["import { MutableRefObject, useCallback, useEffect, useRef, useState } from 'react';\n\ntype PreprocessorFunction = (lines: string[]) => string[];\n\n/**\n * Buffer of data with delay.\n * Data are in the format of array of string.\n *\n * Provides a way to delay inputted data before they are used.\n * Data can be preprocessed by preprocessor function, which processes inputted lines as programmer wishes.\n *\n * To add new lines, use addLines function. After that, they will be preprocessed with preprocessor function.\n * Each added group of lines is treated as a batch and outputted together.\n * Buffer periodically (with delay) checks if any new lines were added, and if so, it will add oldest batch of lines not yet ouputted.\n * Then, after delay, next batch will be outputted (if any), etc.\n *\n * @param preprocessor - function by which each added line is modified\n * @param delay - delay after which buffer sends new data\n */\nexport const useDataBuffer = (delay: number, preprocessor: PreprocessorFunction = (lines: string[]) => lines) => {\n  const [data, setData] = useState<string[]>([]);\n  const [buffer, setBuffer] = useState<string[]>([]);\n  const [currentLineCount, setCurrentLineCount] = useState<number>(0);\n  const savedTimer: MutableRefObject<NodeJS.Timer | undefined> = useRef();\n\n  const inputCnts = useRef<number[]>([]);\n  const currInput = useRef<number>(0);\n\n  useEffect(() => {\n    savedTimer.current = setInterval(() => {\n      console.log(inputCnts.current);\n      if (inputCnts.current.length) {\n        setCurrentLineCount((currentLineCount) => currentLineCount + inputCnts.current[0]);\n        // currInput.current += 1;\n        inputCnts.current.shift();\n      }\n    }, delay);\n  }, [delay]);\n\n  // useEffect(() => {\n  //   if (data.length > buffer.length) {\n  //     savedTimer.current = setTimeout(() => {\n  //       setCurrentLineCount((currentLineCount) => currentLineCount + 5);\n  //     }, 1500);\n  //   }\n  //   return () => {\n  //     clearTimeout(savedTimer.current);\n  //   };\n  // }, [data.length, buffer.length]);\n\n  useEffect(() => {\n    if (data.length > buffer.length) setBuffer(data.slice(0, currentLineCount));\n    // if (currentLineCount > initLogData.length) {\n    //   clearInterval(savedTimer.current);\n    // } else {\n    //   // setLogData(initLogData.slice(0, currentLineCount));\n    //   addLines(initLogData.slice(currentLineCount - 3, currentLineCount));\n    // }\n  }, [currentLineCount]);\n\n  // useEffect(() => {\n  //   setTimeout(() => {\n  //     setBuffer(data);\n  //   }, 3000);\n  // }, [data]);\n\n  const addLines = useCallback(\n    (lines: string[]) => {\n      setData([...data, ...preprocessor(lines)]);\n      inputCnts.current.push(lines.length);\n    },\n    [data, preprocessor]\n  );\n\n  return { buffer, addLines };\n};\n"],"mappings":"AAAA,SAA2BA,WAA3B,EAAwCC,SAAxC,EAAmDC,MAAnD,EAA2DC,QAA3D,QAA2E,OAA3E;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG,UAACC,KAAD,EAAoF;EAAA,IAApEC,YAAoE,uEAA9BC,KAAD,IAAqBA,KAAU;EAC/G,MAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBN,QAAQ,CAAW,EAAX,CAAhC;EACA,MAAM,CAACO,MAAD,EAASC,SAAT,IAAsBR,QAAQ,CAAW,EAAX,CAApC;EACA,MAAM,CAACS,gBAAD,EAAmBC,mBAAnB,IAA0CV,QAAQ,CAAS,CAAT,CAAxD;EACA,MAAMW,UAAsD,GAAGZ,MAAM,EAArE;EAEA,MAAMa,SAAS,GAAGb,MAAM,CAAW,EAAX,CAAxB;EACA,MAAMc,SAAS,GAAGd,MAAM,CAAS,CAAT,CAAxB;EAEAD,SAAS,CAAC,MAAM;IACda,UAAU,CAACG,OAAX,GAAqBC,WAAW,CAAC,MAAM;MACrCC,OAAO,CAACC,GAAR,CAAYL,SAAS,CAACE,OAAtB;;MACA,IAAIF,SAAS,CAACE,OAAV,CAAkBI,MAAtB,EAA8B;QAC5BR,mBAAmB,CAAED,gBAAD,IAAsBA,gBAAgB,GAAGG,SAAS,CAACE,OAAV,CAAkB,CAAlB,CAA1C,CAAnB,CAD4B,CAE5B;;QACAF,SAAS,CAACE,OAAV,CAAkBK,KAAlB;MACD;IACF,CAP+B,EAO7BjB,KAP6B,CAAhC;EAQD,CATQ,EASN,CAACA,KAAD,CATM,CAAT,CAT+G,CAoB/G;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEAJ,SAAS,CAAC,MAAM;IACd,IAAIO,IAAI,CAACa,MAAL,GAAcX,MAAM,CAACW,MAAzB,EAAiCV,SAAS,CAACH,IAAI,CAACe,KAAL,CAAW,CAAX,EAAcX,gBAAd,CAAD,CAAT,CADnB,CAEd;IACA;IACA;IACA;IACA;IACA;EACD,CARQ,EAQN,CAACA,gBAAD,CARM,CAAT,CA/B+G,CAyC/G;EACA;EACA;EACA;EACA;;EAEA,MAAMY,QAAQ,GAAGxB,WAAW,CACzBO,KAAD,IAAqB;IACnBE,OAAO,CAAC,CAAC,GAAGD,IAAJ,EAAU,GAAGF,YAAY,CAACC,KAAD,CAAzB,CAAD,CAAP;IACAQ,SAAS,CAACE,OAAV,CAAkBQ,IAAlB,CAAuBlB,KAAK,CAACc,MAA7B;EACD,CAJyB,EAK1B,CAACb,IAAD,EAAOF,YAAP,CAL0B,CAA5B;EAQA,OAAO;IAAEI,MAAF;IAAUc;EAAV,CAAP;AACD,CAxDM"},"metadata":{},"sourceType":"module"}