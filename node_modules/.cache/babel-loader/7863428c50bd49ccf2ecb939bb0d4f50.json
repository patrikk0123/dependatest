{"ast":null,"code":"import _defineProperty from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\n\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\n\nexport function getUniqueId() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'pf';\n  var uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return \"\".concat(prefix, \"-\").concat(uid);\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\n\nexport function debounce(func, wait) {\n  var _this = this;\n\n  var timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return func.apply(_this, args);\n    }, wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\n\nexport function isElementInView(container, element, partial) {\n  var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!container || !element) {\n    return false;\n  }\n\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.ceil(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.ceil(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  var isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  var isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight); // Return outcome\n\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\n\nexport function sideElementIsOutOfView(container, element) {\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.floor(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.floor(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  var isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  var isOffRight = elementBoundsRight > containerBoundsRight;\n  var side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  } // Return outcome\n\n\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\n\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, function (_, match) {\n    return templateVars[match] || '';\n  });\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\n\nexport function keyHandler(index, innerIndex, position, refsCollection, kids) {\n  var custom = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (!Array.isArray(kids)) {\n    return;\n  }\n\n  var isMultiDimensional = refsCollection.filter(function (ref) {\n    return ref;\n  })[0].constructor === Array;\n  var nextIndex = index;\n  var nextInnerIndex = innerIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    } // eslint-disable-next-line react/no-find-dom-node\n\n\n    var element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\n\nexport function findTabbableElements(containerRef, tababbleSelectors) {\n  var tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  var list = Array.prototype.filter.call(tabbable, function (item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\n\nexport function getNextIndex(index, position, collection) {\n  var nextIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\n\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = \"\".concat(singular, \"s\");\n  }\n\n  return \"\".concat(i || 0, \" \").concat(i === 1 ? singular : plural);\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\n\nexport var setBreakpointCssVars = function setBreakpointCssVars(mods, cssVar) {\n  return Object.entries(mods || {}).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        breakpoint = _ref2[0],\n        value = _ref2[1];\n\n    return breakpoint === 'default' ? Object.assign(Object.assign({}, acc), _defineProperty({}, cssVar, value)) : Object.assign(Object.assign({}, acc), _defineProperty({}, \"\".concat(cssVar, \"-on-\").concat(breakpoint), value));\n  }, {});\n};\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\n\nexport var formatBreakpointMods = function formatBreakpointMods(mods, styles) {\n  var stylePrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var breakpoint = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (!mods) {\n    return '';\n  }\n\n  if (breakpoint) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(\"\".concat(stylePrefix).concat(mods[breakpoint]))];\n    } // the current breakpoint is not specified in mods, so we try to find the next nearest\n\n\n    var breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    var breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n\n    for (var i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(\"\".concat(stylePrefix).concat(mods[breakpointsOrder[i]]))];\n      }\n    }\n\n    return '';\n  }\n\n  return Object.entries(mods || {}).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        breakpoint = _ref4[0],\n        mod = _ref4[1];\n\n    return \"\".concat(stylePrefix).concat(mod).concat(breakpoint !== 'default' ? \"-on-\".concat(breakpoint) : '');\n  }).map(toCamel).map(function (mod) {\n    return mod.replace(/-?(\\dxl)/gi, function (_res, group) {\n      return \"_\".concat(group);\n    });\n  }).map(function (modifierKey) {\n    return styles.modifiers[modifierKey];\n  }).filter(Boolean).join(' ');\n};\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\n\nexport var getBreakpoint = function getBreakpoint(width) {\n  if (width === null) {\n    return null;\n  }\n\n  if (width >= 1450) {\n    return '2xl';\n  }\n\n  if (width >= 1200) {\n    return 'xl';\n  }\n\n  if (width >= 992) {\n    return 'lg';\n  }\n\n  if (width >= 768) {\n    return 'md';\n  }\n\n  if (width >= 576) {\n    return 'sm';\n  }\n\n  return 'default';\n};\n\nvar camelize = function camelize(s) {\n  return s.toUpperCase().replace('-', '').replace('_', '');\n};\n/**\n *\n * @param {string} s string to make camelCased\n */\n\n\nexport var toCamel = function toCamel(s) {\n  return s.replace(/([-_][a-z])/gi, camelize);\n};\n/**\n * Copied from exenv\n */\n\nexport var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\n\nexport var getTextWidth = function getTextWidth(text, node) {\n  var computedStyle = getComputedStyle(node); // Firefox returns the empty string for .font, so this function creates the .font property manually\n\n  var getFontFromComputedStyle = function getFontFromComputedStyle() {\n    var computedFont = ''; // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n\n    var fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    }; // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n\n    var fontStretch;\n\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n\n    computedFont = computedStyle.fontStyle + ' ' + computedStyle.fontVariant + ' ' + computedStyle.fontWeight + ' ' + fontStretch + ' ' + computedStyle.fontSize + '/' + computedStyle.lineHeight + ' ' + computedStyle.fontFamily;\n    return computedFont;\n  };\n\n  var canvas = document.createElement('canvas');\n  var context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n  return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\n\nexport var innerDimensions = function innerDimensions(node) {\n  var computedStyle = getComputedStyle(node);\n  var width = node.clientWidth; // width with padding\n\n  var height = node.clientHeight; // height with padding\n\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return {\n    height: height,\n    width: width\n  };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\n\nexport var trimLeft = function trimLeft(node, value) {\n  var availableWidth = innerDimensions(node).width;\n  var newValue = value;\n\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(\"...\".concat(newValue), node) > availableWidth) {\n      newValue = newValue.substring(1);\n    } // replace text with our truncated text\n\n\n    if (node.value) {\n      node.value = \"...\".concat(newValue);\n    } else {\n      node.innerText = \"...\".concat(newValue);\n    }\n  } else {\n    if (node.value) {\n      node.value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\n\nexport var preventedEvents = function preventedEvents(events) {\n  return events.reduce(function (handlers, eventToPrevent) {\n    return Object.assign(Object.assign({}, handlers), _defineProperty({}, eventToPrevent, function (event) {\n      event.preventDefault();\n    }));\n  }, {});\n};","map":{"version":3,"mappings":"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","names":["ReactDOM","SIDE","capitalize","input","toUpperCase","substring","getUniqueId","prefix","uid","Date","getTime","Math","random","toString","slice","debounce","func","wait","timeout","args","clearTimeout","setTimeout","apply","isElementInView","container","element","partial","strict","containerBounds","getBoundingClientRect","elementBounds","containerBoundsLeft","ceil","left","containerBoundsRight","floor","right","elementBoundsLeft","elementBoundsRight","isTotallyInView","isPartiallyInView","width","sideElementIsOutOfView","isOffLeft","isOffRight","side","NONE","BOTH","RIGHT","LEFT","fillTemplate","templateString","templateVars","replace","_","match","keyHandler","index","innerIndex","position","refsCollection","kids","custom","Array","isArray","isMultiDimensional","filter","ref","constructor","nextIndex","nextInnerIndex","length","undefined","focus","findDOMNode","findTabbableElements","containerRef","tababbleSelectors","tabbable","current","querySelectorAll","list","prototype","call","item","tabIndex","getNextIndex","collection","pluralize","i","singular","plural","setBreakpointCssVars","mods","cssVar","Object","entries","reduce","acc","breakpoint","value","formatBreakpointMods","styles","stylePrefix","modifiers","toCamel","breakpointsOrder","breakpointsIndex","indexOf","map","mod","_res","group","modifierKey","Boolean","join","getBreakpoint","camelize","s","canUseDOM","window","document","createElement","getTextWidth","text","node","computedStyle","getComputedStyle","getFontFromComputedStyle","computedFont","fontStretchLookupTable","fontStretch","fontStyle","fontVariant","fontWeight","fontSize","lineHeight","fontFamily","canvas","context","getContext","font","measureText","innerDimensions","clientWidth","height","clientHeight","parseFloat","paddingTop","paddingBottom","paddingLeft","paddingRight","trimLeft","availableWidth","newValue","innerText","preventedEvents","events","handlers","eventToPrevent","event","preventDefault"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/util.ts"],"sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\n\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input: string) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId(prefix = 'pf') {\n  const uid =\n    new Date().getTime() +\n    Math.random()\n      .toString(36)\n      .slice(2);\n  return `${prefix}-${uid}`;\n}\n\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(this: any, func: (...args: any[]) => any, wait: number) {\n  let timeout: number;\n  return (...args: any[]) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait) as any;\n  };\n}\n\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(\n  container: HTMLElement,\n  element: HTMLElement,\n  partial: boolean,\n  strict: boolean = false\n): boolean {\n  if (!container || !element) {\n    return false;\n  }\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.ceil(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.ceil(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView =\n    (partial || (!strict && containerBounds.width < elementBounds.width)) &&\n    ((elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft) ||\n      (elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight));\n\n  // Return outcome\n  return isTotallyInView || isPartiallyInView;\n}\n\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container: HTMLElement, element: HTMLElement): string {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  }\n  // Return outcome\n  return side;\n}\n\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString: string, templateVars: any) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(\n  index: number,\n  innerIndex: number,\n  position: string,\n  refsCollection: any[],\n  kids: any[],\n  custom = false\n) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n  if (\n    refsCollection[nextIndex] === null ||\n    refsCollection[nextIndex] === undefined ||\n    (isMultiDimensional &&\n      (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined))\n  ) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    }\n    // eslint-disable-next-line react/no-find-dom-node\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]) as HTMLElement;\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef: any, tababbleSelectors: string): any[] {\n  const tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  const list = Array.prototype.filter.call(tabbable, function(item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index: number, position: string, collection: any[]): number {\n  let nextIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i: number, singular: string, plural?: string) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport const setBreakpointCssVars = (\n  mods: {\n    default?: string;\n    sm?: string;\n    md?: string;\n    lg?: string;\n    xl?: string;\n    '2xl'?: string;\n    '3xl'?: string;\n  },\n  cssVar: string\n): React.CSSProperties =>\n  Object.entries(mods || {}).reduce(\n    (acc, [breakpoint, value]) =>\n      breakpoint === 'default' ? { ...acc, [cssVar]: value } : { ...acc, [`${cssVar}-on-${breakpoint}`]: value },\n    {}\n  );\n\nexport interface Mods {\n  default?: string;\n  sm?: string;\n  md?: string;\n  lg?: string;\n  xl?: string;\n  '2xl'?: string;\n  '3xl'?: string;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = (\n  mods: Mods,\n  styles: any,\n  stylePrefix: string = '',\n  breakpoint?: 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'\n) => {\n  if (!mods) {\n    return '';\n  }\n  if (breakpoint) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint as keyof Mods]}`)];\n    }\n    // the current breakpoint is not specified in mods, so we try to find the next nearest\n    const breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i] as keyof Mods]}`)];\n      }\n    }\n    return '';\n  }\n  return Object.entries(mods || {})\n    .map(([breakpoint, mod]) => `${stylePrefix}${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}`)\n    .map(toCamel)\n    .map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`))\n    .map(modifierKey => styles.modifiers[modifierKey])\n    .filter(Boolean)\n    .join(' ');\n};\n\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getBreakpoint = (width: number): 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' => {\n  if (width === null) {\n    return null;\n  }\n  if (width >= 1450) {\n    return '2xl';\n  }\n  if (width >= 1200) {\n    return 'xl';\n  }\n  if (width >= 992) {\n    return 'lg';\n  }\n  if (width >= 768) {\n    return 'md';\n  }\n  if (width >= 576) {\n    return 'sm';\n  }\n  return 'default';\n};\n\nconst camelize = (s: string) =>\n  s\n    .toUpperCase()\n    .replace('-', '')\n    .replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = (s: string) => s.replace(/([-_][a-z])/gi, camelize);\n\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text: string, node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n  // Firefox returns the empty string for .font, so this function creates the .font property manually\n  const getFontFromComputedStyle = () => {\n    let computedFont = '';\n    // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n    const fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    };\n    // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n    let fontStretch;\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = (fontStretchLookupTable as any)[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n    computedFont =\n      computedStyle.fontStyle +\n      ' ' +\n      computedStyle.fontVariant +\n      ' ' +\n      computedStyle.fontWeight +\n      ' ' +\n      fontStretch +\n      ' ' +\n      computedStyle.fontSize +\n      '/' +\n      computedStyle.lineHeight +\n      ' ' +\n      computedStyle.fontFamily;\n    return computedFont;\n  };\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n\n  return context.measureText(text).width;\n};\n\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = (node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n\n  let width = node.clientWidth; // width with padding\n  let height = node.clientHeight; // height with padding\n\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return { height, width };\n};\n\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node: HTMLElement, value: string) => {\n  const availableWidth = innerDimensions(node).width;\n  let newValue = value;\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n      newValue = newValue.substring(1);\n    }\n    // replace text with our truncated text\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = `...${newValue}`;\n    } else {\n      node.innerText = `...${newValue}`;\n    }\n  } else {\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = (events: string[]) =>\n  events.reduce(\n    (handlers, eventToPrevent) => ({\n      ...handlers,\n      [eventToPrevent]: (event: React.SyntheticEvent<HTMLElement>) => {\n        event.preventDefault();\n      }\n    }),\n    {}\n  );\n"]},"metadata":{},"sourceType":"module"}