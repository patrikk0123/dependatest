{"ast":null,"code":"import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\n\nexport default function detectOverflow(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$placement = options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","map":{"version":3,"mappings":"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","names":["getBoundingClientRect","getClippingRect","getDocumentElement","computeOffsets","rectToClientRect","clippingParents","reference","popper","bottom","top","right","basePlacements","viewport","isElement","mergePaddingObject","expandToHashMap","detectOverflow","state","options","placement","boundary","rootBoundary","elementContext","altBoundary","padding","paddingObject","altContext","referenceElement","elements","popperRect","rects","element","clippingClientRect","contextElement","referenceClientRect","popperOffsets","strategy","popperClientRect","elementClientRect","overflowOffsets","left","offsetData","modifiersData","offset","Object","keys","forEach","multiply","indexOf","key","axis"],"sources":["/home/pkorytar/Projects/RedHat/pnc-web-ui-react/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.ts"],"sourcesContent":["// @ts-nocheck\nimport { State, SideObject, Padding } from '../types';\nimport { Placement, Boundary, RootBoundary, Context } from '../enums';\nimport getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  placement: Placement;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  elementContext: Context;\n  altBoundary: boolean;\n  padding: Padding;\n}\n\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state: State, options: Partial<Options> = {}): SideObject {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements)\n  );\n\n  const altContext = elementContext === popper ? reference : popper;\n\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n\n  const clippingClientRect = getClippingRect(\n    isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper),\n    boundary,\n    rootBoundary\n  );\n\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n\n  const popperClientRect = rectToClientRect({\n    ...popperRect,\n    ...popperOffsets\n  });\n\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n\n  const offsetData = state.modifiersData.offset;\n\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n"]},"metadata":{},"sourceType":"module"}